(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{540:function(i,t,d){"use strict";d.r(t);var a=d(34),r=Object(a.a)({},(function(){var i=this,t=i.$createElement,d=i._self._c||t;return d("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[d("h1",{attrs:{id:"id生成器"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#id生成器"}},[i._v("#")]),i._v(" id生成器")]),i._v(" "),d("p",[i._v("id生成器设计、开发、运维")]),i._v(" "),d("p",[i._v("id生成器是负责生成唯一id的服务、组件。")]),i._v(" "),d("h2",{attrs:{id:"为什么需要id生成器"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要id生成器"}},[i._v("#")]),i._v(" 为什么需要id生成器")]),i._v(" "),d("p",[i._v("id是identifier唯一标识符的常用缩写，在大多数业务场景中，每个业务模型都需要一个该业务模型内唯一的id与其他系统进行通信。")]),i._v(" "),d("p",[i._v("比如用户系统中，用户模型的设计，每个用户都由一个唯一id，用户系统对外会提供使用id查询用户信息的接口，如果在其他系统中需要管理用户信息，id也是该用户的关联信息，比如存储一个用户的粉丝列表，只需要存储粉丝的id，而不需要冗余存储全部的粉丝用户信息")]),i._v(" "),d("h3",{attrs:{id:"表自增id的问题"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#表自增id的问题"}},[i._v("#")]),i._v(" 表自增id的问题")]),i._v(" "),d("p",[i._v("对于一些数据量比较少的业务，在存储时，可以使用单个表存储，这时使用数据库的自增id即可作为唯一id使用。")]),i._v(" "),d("p",[i._v("但是对于数据量可能比较大的业务，在业务发展起来后，单库单表无法满足读写性能，需要拆表，自增id会遇到比较大的麻烦，因为拆分到不同表之后，各个表使用自己的自增id，互相会出现id重复。\n使用一个外部的id生成器来生成id，能够避免此类分表后的id重复问题。")]),i._v(" "),d("h2",{attrs:{id:"id生成器有哪些需求"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#id生成器有哪些需求"}},[i._v("#")]),i._v(" id生成器有哪些需求")]),i._v(" "),d("p",[i._v("除了唯一性，在不同的场景下经常会对id有定制化需求。")]),i._v(" "),d("ol",[d("li",[i._v("递增性/顺序性")])]),i._v(" "),d("p",[i._v("递增性是指，后生成的id比先生成的id大。")]),i._v(" "),d("p",[i._v("在一些业务场景下，如果id能够保证递增性，会使用id作为排序的依据，比如如果评论id是递增的，则评论列表可以使用id作为排序的条件。")]),i._v(" "),d("p",[i._v("我更建议使用id而不使用时间戳排序，是因为id能够保证唯一性，而时间戳不能，在分页获取时，通过id能够更方便的实现分页查找（比如redis或数据库中查找大于等于某个id的N条数据）")]),i._v(" "),d("ol",{attrs:{start:"2"}},[d("li",[i._v("连续性")])]),i._v(" "),d("p",[i._v("连续性是指生成的id是连续的，比如1,2,3,4,5。")]),i._v(" "),d("p",[i._v("有的业务场景不希望id是连续的，比如很多订单系统的订单号，不希望订单id展示在前端后被外部看到订单增长情况；如果id是连续的，可能有爬虫风险，外部爬虫可能会通过遍历id的方式快速获取网站的数据。\n有的业务场景希望id是连续的，比如内部系统希望按照id进行遍历处理数据。")]),i._v(" "),d("h2",{attrs:{id:"id生成器系统需求"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#id生成器系统需求"}},[i._v("#")]),i._v(" id生成器系统需求")]),i._v(" "),d("p",[i._v("高性能: qps高、延迟低。\n极高可靠性: 生成id是很多接口处理的第一步操作，也是不可降级依赖。\n支持多租户: id生成器需要支持多个租户（id生成器的业务方，比如用户id、订单id是两个不同的业务方），保证单个业务方内部的唯一性，让新业务接入简单便捷。")]),i._v(" "),d("h2",{attrs:{id:"id生成器有哪些实现方案"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#id生成器有哪些实现方案"}},[i._v("#")]),i._v(" id生成器有哪些实现方案")]),i._v(" "),d("h3",{attrs:{id:"uuid"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#uuid"}},[i._v("#")]),i._v(" uuid")]),i._v(" "),d("p",[i._v("uuid能够生成字符串类型的id，对于一些业务场景，使用uuid即可满足需求。\n优点是实现简单，没有外部依赖。\n缺点是生成的id是字符串类型、没有顺序性连续性。")]),i._v(" "),d("h3",{attrs:{id:"mysql自增表"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#mysql自增表"}},[i._v("#")]),i._v(" mysql自增表")]),i._v(" "),d("p",[i._v("创建一个单独的表，只包含mysql自增id字段，通过insert后获取自增的结果来生成id。")]),i._v(" "),d("p",[i._v("优点是实现相对简单，具备非常好的id递增性连续性，依赖少，只需要一个常用的mysql。不同的id业务创建不同的自增表即可，如果要扩容把表分散到不同的数据库即可。\n缺点是可靠性依赖于mysql，当主库故障发生主从切换时，如果主从间数据有延迟可能导致id重复。生成id的qps上限受限于mysql的性能（一般在几万qps）")]),i._v(" "),d("p",[i._v("这种简单便捷的方案对于小规模的业务场景比较实用。")]),i._v(" "),d("h3",{attrs:{id:"redis自增"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#redis自增"}},[i._v("#")]),i._v(" redis自增")]),i._v(" "),d("p",[i._v("通过redis的incr命令进行自增，也是一种生成id的方案。")]),i._v(" "),d("p",[i._v("优点，使用简单，redis也是一种常用缓存，不需要提前建表，能保证比较好的递增性和连续性。\n缺点，redis相对于mysql，不能保证非常高的数据可靠性，当发生机器故障重启、缓存逐出时，可能发生数据丢失导致id从0开始重新自增进而导致id重复。")]),i._v(" "),d("h3",{attrs:{id:"snowflake雪花及其变种"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#snowflake雪花及其变种"}},[i._v("#")]),i._v(" snowflake雪花及其变种")]),i._v(" "),d("p",[i._v("snowflake生成算法或者叫雪花算法是一种很多人熟知的id生成方式。\n它把long类型的id的64bit位分为若干个部分，保存时间戳、机房id（可选）、机器唯一id、机器内相同时间戳内生成的自增序列。")]),i._v(" "),d("p",[i._v("一种snowflake默认的划分方案是 1 + 41 + 5 +5 + 12。")]),i._v(" "),d("div",{staticClass:"language- line-numbers-mode"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[i._v("首位bit固定为0 | 41bit保存时间戳 | 5bit机房id | 5bit机器id | 12位时间戳相同时的自增序列\n")])]),i._v(" "),d("div",{staticClass:"line-numbers-wrapper"},[d("span",{staticClass:"line-number"},[i._v("1")]),d("br")])]),d("p",[i._v("一般会把id生成封装成独立的服务，对外提供rpc调用。这样能够比较好的分配机器id。\n41位的时间戳保存的是服务创建时间开始的时间，能够降低时间戳占用的空间，41bit，如果存储毫秒，则可以使用2的41次方毫秒，大约是69年。\n另外可以针对自己的需求调整各个部分的长度，比如机房id、机器id等，来调整id的长度，因为有的业务场景下，还希望在id前后追加一些业务信息，\n比如用户id后几位等，这时要注意预留给时间戳的空间是否充足。")]),i._v(" "),d("p",[i._v("snowflake优点是实现简单，生成时无外部依赖、id前缀是时间戳，能够保持比较好的时间有序性，\n缺点是id的长度比较长不连续，在一些业务下不适用（比如生成qq号、手机号）。")]),i._v(" "),d("h4",{attrs:{id:"机器id的分配方式"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#机器id的分配方式"}},[i._v("#")]),i._v(" 机器id的分配方式")]),i._v(" "),d("p",[i._v("保证机器id的唯一性是保证id不重复的关键，为每个机器分配唯一的id（准确说是为每个启动的进程）就十分关键")]),i._v(" "),d("ul",[d("li",[i._v("数据库写入分配，机器id作为唯一健，通过insert 机器信息、workerId成功表示这个机器抢占成功")]),i._v(" "),d("li",[i._v("zookeeper分配，类似数据库，通过zookeeper写入包含workerId的路径成功表示抢占成功")])]),i._v(" "),d("p",[i._v("在进程结束时，通过关闭时清理比如注册ShutdownHook可以进行在进程关闭时清除数据库或zookeeper中的数据从而能够")]),i._v(" "),d("p",[i._v("定期上报，由于机器可能出现故障重启或进程因为异常原因退出没有及时清理到之前占用的机器id，进而可能导致新启动的进程没有\n可用机器id。所以需要增加一个定期上报和清理机制。\n在某个机器id一定时间没有使用后，可以进行自动清理。\n并且在上报时，也要把当前机器的时间戳也上报上，在新的进程启动时，读取要使用的机器id之前所在机器上报的时间戳，和自己当前的时间戳进行判断，\n相差一定的范围时再启动，这可以避免不同机器间时间戳有间隔时可能导致的id重复问题。")]),i._v(" "),d("h4",{attrs:{id:"自增序列尾号0的问题"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#自增序列尾号0的问题"}},[i._v("#")]),i._v(" 自增序列尾号0的问题")]),i._v(" "),d("p",[i._v("最后的12bit的作用时，在同一个时间戳内，收到多个生成id的请求，为了避免id重复，或使用这12bit在内存内进行递增，当时间戳更换时，12bit从0开始重新计数。\n但是这样实现带来一个问题，就是当生成的qps不高时，比如每秒只有一个请求，则每次请求过来时，时间戳和上次的时间戳都不通，12bit的sequence序列都是从\n0开始，这样最终生成的id的最后一个bit都是0，也就是id都是偶数，如果业务上使用这个id进行分表，则会导致数据在各个表中不均匀。\n为了解决这个问题，在每次时间戳更换时，可以不从0开始递增12位的sequence，而是在一段范围内进行random随机，比如0到100内random。")]),i._v(" "),d("h4",{attrs:{id:"时间戳回退问题"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#时间戳回退问题"}},[i._v("#")]),i._v(" 时间戳回退问题")]),i._v(" "),d("p",[i._v("snowflake的id的唯一性，基于机器id唯一和相同的机器id内时间戳不重复。\n而在一个机器运行过程中，时间戳在极端情况下可能出现回退的可能，比如ntp同步出现异常。这时需要snowflake的实现记录下上一次的时间戳，如果新的时间戳比\n上一次的要小，则需要原地等待直到时间戳大于等于上一次使用的时间戳才能使用。\n另外对于进程启动时，也需要判断上一个使用这个机器id的时间戳，避免不同机器间时间不一致可能引发的id重复。")]),i._v(" "),d("h3",{attrs:{id:"数据库号段生成模式"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#数据库号段生成模式"}},[i._v("#")]),i._v(" 数据库号段生成模式")]),i._v(" "),d("p",[i._v("数据库号段生成模式是除snowflake外另一种常用的生成方案。\n对于每个id生成的场景，在数据库存储中保存每个业务对应的当前已经分配出去的id最大值，\n然后id生成器服务会到数据库中更新对应业务的这个id最大值，每次增大一定值，然后获取增大之后的值（在一个加锁事务中操作），\n这样这段id就归属于这个id生成服务的进程所拥有，可以在内存内对外分配id（通过加锁或cas的方式处理并发问题）")]),i._v(" "),d("p",[i._v("优点，相比snowflake,id的长度是从1开始增加的（当然可以调整初始的id），具备比较高的性能，可以通过双buffer的方式也就是id范围快用完时异步获取下一个id范围降低卡顿。\n缺点，顺序性不能得到保证，解决方案是，可以通过定制化RPC路由的方式，将同一个业务的请求都路由到一个机器上实现有序性。")]),i._v(" "),d("p",[i._v("数据库号段实现的难点主要在于双buffer的异步实现，可以参考tinyid的实现代码。")]),i._v(" "),d("h4",{attrs:{id:"主从切换主从延迟问题"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#主从切换主从延迟问题"}},[i._v("#")]),i._v(" 主从切换主从延迟问题")]),i._v(" "),d("p",[i._v("使用mysql数据库的一个风险点是如果出现主从切换，且主从之间恰好有数据没同步完的情况，可能出现id的重复。\n为了解决这个问题，可以更换存储为强一致的存储，比如zookeeper或其他的raft协议的实现比如etcd等。")]),i._v(" "),d("h2",{attrs:{id:"id其他需求"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#id其他需求"}},[i._v("#")]),i._v(" id其他需求")]),i._v(" "),d("h3",{attrs:{id:"加密"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#加密"}},[i._v("#")]),i._v(" 加密")]),i._v(" "),d("p",[i._v("id加密的目的是把对外输出的id进行混淆转换，避免被竞对发现业务量级、避免被爬虫遍历爬取数据。\n加密方式，加密方式一般采用对称加密。")]),i._v(" "),d("h2",{attrs:{id:"一些开源实现"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#一些开源实现"}},[i._v("#")]),i._v(" 一些开源实现")]),i._v(" "),d("ul",[d("li",[d("a",{attrs:{href:"https://github.com/Meituan-Dianping/Leaf",target:"_blank",rel:"noopener noreferrer"}},[i._v("美团的leaf"),d("OutboundLink")],1),i._v(" 提出了批量+双buffer的优化")]),i._v(" "),d("li",[d("a",{attrs:{href:"https://github.com/baidu/uid-generator",target:"_blank",rel:"noopener noreferrer"}},[i._v("百度的uid generator"),d("OutboundLink")],1),i._v(" 提供了ringbuffer的优化")]),i._v(" "),d("li",[d("a",{attrs:{href:"https://github.com/didi/tinyid",target:"_blank",rel:"noopener noreferrer"}},[i._v("滴滴的tinyid"),d("OutboundLink")],1),i._v(" 提供了客户端获取批量进而减少远程调用的优化")]),i._v(" "),d("li",[d("a",{attrs:{href:"https://github.com/twitter-archive/snowflake",target:"_blank",rel:"noopener noreferrer"}},[i._v("twitter的snowflake"),d("OutboundLink")],1),i._v(" snowflake的原始实现")])])])}),[],!1,null,null,null);t.default=r.exports}}]);