(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{626:function(e,s,a){"use strict";a.r(s);var t=a(34),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"enhancedredefine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enhancedredefine"}},[e._v("#")]),e._v(" enhancedRedefine")]),e._v(" "),a("h2",{attrs:{id:"load-new-class-versions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#load-new-class-versions"}},[e._v("#")]),e._v(" load_new_class_versions")]),e._v(" "),a("p",[e._v("find_sorted_affected_classes: 找到更新的类和它所有的子类（包括子类的子类等），并按照继承关系进行拓扑排序。\n对要redefine的类klass设置_redefine_flags标识(MarkedAsAffected)。\n遍历ClassLoaderDataGraph，对所有的类，查看类自身以及所有的父类、接口中是否有MarkedAsAffected标识，如果有，加到_affected_klasses数组中。")]),e._v(" "),a("p",[e._v("对于每个_affected_klass。")]),e._v(" "),a("ul",[a("li",[e._v("查找类的新class_bytes，如果这个类正在被redefine（参数里明确指定的），则返回被redefine的class bytes，否则返回之前类的class bytes。")]),e._v(" "),a("li",[e._v("如果是匿名内部类，从class bytes解析出InstanceKlass，记为k。修改class_loader_data为原来类的class_loader_data")]),e._v(" "),a("li",[e._v("如果不是匿名内部类，从class bytes解析出InstanceKlass，记为k。")]),e._v(" "),a("li",[e._v("设置the_class的new_version为新创建出来的InstanceKlass k。")])]),e._v(" "),a("p",[e._v("解析类的resolve_from_stream过程，会创建InstanceKlass，并添加到systemDictionary中替换之前的old_klass。")]),e._v(" "),a("p",[e._v("calculate_redefinition_flags: 计算新旧类的差异。(field change, method change, supertype change等)\n如果出现了删除类的supertype，目前是不支持更新的，抛出异常。")]),e._v(" "),a("p",[e._v("如果出现field修改，计算复制旧字段到新字段需要的offset, size等信息，用于后面的gc迁移旧对象字段到新对象位置字段使用。\n如果没修改，只会复制旧的类的JVM_ACC_FIELD_MODIFICATION_WATCHED等JVMTI flag到新字段（这些是debug时动态添加的，不在class bytes中）")]),e._v(" "),a("p",[e._v("link、verify，链接验证新类。")]),e._v(" "),a("h2",{attrs:{id:"vm-enhancedredefineclasses-doit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vm-enhancedredefineclasses-doit"}},[e._v("#")]),e._v(" VM_EnhancedRedefineClasses::doit")]),e._v(" "),a("h3",{attrs:{id:"redefine-single-class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redefine-single-class"}},[e._v("#")]),e._v(" redefine_single_class")]),e._v(" "),a("h3",{attrs:{id:"flush-dependent-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flush-dependent-code"}},[e._v("#")]),e._v(" flush_dependent_code")]),e._v(" "),a("p",[e._v("清理所有的JvmtiExport::all_dependencies_are_recorded的codecache、")]),e._v(" "),a("h3",{attrs:{id:"clear-cpool-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clear-cpool-cache"}},[e._v("#")]),e._v(" clear_cpool_cache")]),e._v(" "),a("p",[e._v("扫描所有类。\n调整常量池对于匿名内部类，修改host_klass为新的host_klass(旧host_klass的newest_version())\n查看如果有对旧的类的常量池引用，修改为引用newst_version。\n清理常量池缓存，这样下次使用常量池缓存时会重新解析。")]),e._v(" "),a("h3",{attrs:{id:"changepointersoopclosure-changepointersobjectclosure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#changepointersoopclosure-changepointersobjectclosure"}},[e._v("#")]),e._v(" ChangePointersOopClosure,ChangePointersObjectClosure")]),e._v(" "),a("p",[e._v("ChangePointersObjectClosure")]),e._v(" "),a("ul",[a("li",[e._v("如果旧类字段和新类兼容，只更新mark word里类的reference")]),e._v(" "),a("li",[e._v('否则如果新类的对象大小比旧的小，则重新shuffle字段，并把新旧类的大小gap填上"dead_space"')]),e._v(" "),a("li",[e._v("否则，设置_needs_instance_update标识，在full gc的时候，会整理对象。")])]),e._v(" "),a("h2",{attrs:{id:"vm-enhancedredefineclasses-doit-epilogue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vm-enhancedredefineclasses-doit-epilogue"}},[e._v("#")]),e._v(" VM_EnhancedRedefineClasses::doit_epilogue()")]),e._v(" "),a("h3",{attrs:{id:"vm-gc-operation-doit-epilogue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vm-gc-operation-doit-epilogue"}},[e._v("#")]),e._v(" VM_GC_Operation::doit_epilogue")]),e._v(" "),a("p",[e._v("清理OopMapCache")]),e._v(" "),a("h3",{attrs:{id:"reinitializejdkclasses"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reinitializejdkclasses"}},[e._v("#")]),e._v(" reinitializeJDKClasses")]),e._v(" "),a("p",[e._v("对于更新jdk类（package name以java/，jdk，sun/开头的类），调用jdk类的registerNative和initIds方法")]),e._v(" "),a("h2",{attrs:{id:"jdk中原有的redefine的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk中原有的redefine的实现"}},[e._v("#")]),e._v(" jdk中原有的Redefine的实现")]),e._v(" "),a("p",[e._v("prologue")]),e._v(" "),a("ul",[a("li",[e._v("检查修改类型")]),e._v(" "),a("li",[e._v("merge cp and rewrite")]),e._v(" "),a("li",[e._v("link methods")])]),e._v(" "),a("p",[e._v("doit")]),e._v(" "),a("ul",[a("li",[e._v("redefine_single_class\n"),a("ul",[a("li",[e._v("替换原有klass的methods、constantPool")]),e._v(" "),a("li",[e._v("vtable itable initialize")]),e._v(" "),a("li",[e._v("设置local variable table")]),e._v(" "),a("li",[e._v("increment class counter")])])]),e._v(" "),a("li",[e._v("flush dependent code")]),e._v(" "),a("li",[e._v("ClassLoaderDataGraph adjust and clean metadata")])]),e._v(" "),a("p",[e._v("safepoint机制")])])}),[],!1,null,null,null);s.default=n.exports}}]);