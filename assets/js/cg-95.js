(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{525:function(a,e,r){"use strict";r.r(e);var t=r(34),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"分布式系统设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统设计模式"}},[a._v("#")]),a._v(" 分布式系统设计模式")]),a._v(" "),r("p",[a._v("本文会分享分布式系统的常用设计模式")]),a._v(" "),r("h2",{attrs:{id:"分布式系统简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统简介"}},[a._v("#")]),a._v(" 分布式系统简介")]),a._v(" "),r("p",[a._v("什么是分布式服务？")]),a._v(" "),r("p",[a._v("我们平时解除比较多的分布式系统一般指分布式协调配置服务（zookeeper、etcd）、分布式消息队列（kafka、rocketmq）、分布式数据库（tidb）等。")]),a._v(" "),r("p",[a._v("分布式服务的特点是")]),a._v(" "),r("ol",[r("li",[a._v("运行在多个机器上。通过运行在多个机器上，通过多个机器来提高系统的处理能力和保证服务、数据可靠性。")]),a._v(" "),r("li",[a._v("有状态服务，保存处理数据")])]),a._v(" "),r("p",[a._v("为了解决分布式系统的常见问题，我们可以从这些系统中总结出分布式系统的设计模式，掌握了这些设计模式就能对分布式系统的本质有更深层次的理解，我们在学习相关的框架的时候，\n就会更加游刃有余。")]),a._v(" "),r("p",[a._v("优势")]),a._v(" "),r("ul",[r("li",[a._v("去中心化")]),a._v(" "),r("li",[a._v("低成本")]),a._v(" "),r("li",[a._v("弹性")]),a._v(" "),r("li",[a._v("资源共享")]),a._v(" "),r("li",[a._v("可靠性高")])]),a._v(" "),r("p",[a._v("挑战")]),a._v(" "),r("ul",[r("li",[a._v("节点故障")]),a._v(" "),r("li",[a._v("不可靠的网络")]),a._v(" "),r("li",[a._v("安全")])]),a._v(" "),r("p",[a._v("分布式数据库")]),a._v(" "),r("ul",[r("li",[a._v("Google Spanner")]),a._v(" "),r("li",[a._v("TiDB")]),a._v(" "),r("li",[a._v("HBase")]),a._v(" "),r("li",[a._v("MongoDB")])]),a._v(" "),r("h2",{attrs:{id:"理论基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理论基础"}},[a._v("#")]),a._v(" 理论基础")]),a._v(" "),r("h3",{attrs:{id:"cap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cap"}},[a._v("#")]),a._v(" CAP")]),a._v(" "),r("ul",[r("li",[a._v("C (Consistence): 一致性，数据在多个副本之间能够保持一致（严格一致性）")]),a._v(" "),r("li",[a._v("A (Available): 可用性，系统提供的服务必须一直处于可用，每次请求都能获取到非错的响应（但是不保证获取的数据为最新数据）")]),a._v(" "),r("li",[a._v("P (Network partition): 分区容错性，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。")])]),a._v(" "),r("p",[a._v("CAP理论指一个系统不可能同时实现CAP，最多选择其中两个。")]),a._v(" "),r("h2",{attrs:{id:"分布式系统可能出现的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统可能出现的问题"}},[a._v("#")]),a._v(" 分布式系统可能出现的问题")]),a._v(" "),r("h3",{attrs:{id:"进程crash崩溃"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程crash崩溃"}},[a._v("#")]),a._v(" 进程crash崩溃")]),a._v(" "),r("p",[a._v("进程可能因为各种各样的原因挂掉退出")]),a._v(" "),r("ul",[r("li",[a._v("机器故障（比如磁盘、内存等）、程序bug")]),a._v(" "),r("li",[a._v("人为重启机器、杀进程")]),a._v(" "),r("li",[a._v("oom")]),a._v(" "),r("li",[a._v("其他")])]),a._v(" "),r("p",[a._v("分布式系统需要保证的一点是，crash之前写入的数据，需要保证持久性，也就是在分布式系统中不丢失。")]),a._v(" "),r("p",[a._v("为此分布式系统一般使用Write-Ahead Log技术保证数据可靠性，Server会把状态修改作为命令消息写入append only file（只追加不修改的文件）写到磁盘中。\n在文件中追加数据通常是比较快的操作，在server重启时，重放这个Write-Ahead Log就能恢复之前的状态。\n同时为了避免一个机器永久性损坏，分布式系统一般采用多副本的方式，保证一个机器故障，其他机器还有相同的数据、能够提供服务。")]),a._v(" "),r("h3",{attrs:{id:"网络延迟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络延迟"}},[a._v("#")]),a._v(" 网络延迟")]),a._v(" "),r("p",[a._v("分布式系统间网络传输可能出现各种原因，比如网卡故障、交换机故障、机房间网络故障等，导致请求传输时间变长、超时甚至网络不通。\n这就导致可能出现一段时间内，一些机器和其他的机器，网络不通，导致分布式系统中的partition网络分区(CAP中的P)，网络分区是不可避免的。\n大多数的分布式系统都是由一个主节点leader（或者对于某个维度上的一个leader比如kafka partition的leader）负责数据的写操作，leader把Write-Ahead Log同步给其他从节点机器（成为follower）\n当leader挂了，需要从follower选择一个新的leader继续对外提供服务。\n这时需要一种机制来判断leader是否故障，方式一般为leader向其他机器定期发送心跳，当半数以上的节点在一段时间没有收到leader心跳后，就会认为leader故障，需要选举新的leader。")]),a._v(" "),r("h3",{attrs:{id:"进程暂停"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程暂停"}},[a._v("#")]),a._v(" 进程暂停")]),a._v(" "),r("p",[a._v("进程有可能因为各种各样的原因出现暂停，比如一些有垃圾回收的语言编写的程序，在回收时会暂停程序执行，如果时间过长，其他的follower会重新选举新的\nleader，当旧的leader唤醒过来时，如果它继续处理数据，则此时会出现两个leader同时在工作，分布式系统需要解决此类问题。")]),a._v(" "),r("p",[a._v("通常采用Generation Clock（代际时间）来检测来自旧的leader的请求。每一代leader都会有一个单调递增的clock数字标识。")]),a._v(" "),r("h3",{attrs:{id:"机器时间不同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#机器时间不同步"}},[a._v("#")]),a._v(" 机器时间不同步")]),a._v(" "),r("p",[a._v("不同机器之前的时间并不是完全一致的，因此不能依赖机器时间作为消息间的顺序，而应该使用逻辑顺序（比如Generation Clock)。")]),a._v(" "),r("h2",{attrs:{id:"patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#patterns"}},[a._v("#")]),a._v(" Patterns")]),a._v(" "),r("h3",{attrs:{id:"容错一致性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容错一致性"}},[a._v("#")]),a._v(" 容错一致性")]),a._v(" "),r("h3",{attrs:{id:"leader-and-follower"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#leader-and-follower"}},[a._v("#")]),a._v(" Leader And Follower")]),a._v(" "),r("h3",{attrs:{id:"high-water-mark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#high-water-mark"}},[a._v("#")]),a._v(" High-Water Mark")]),a._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://martinfowler.com/articles/patterns-of-distributed-systems/",target:"_blank",rel:"noopener noreferrer"}},[a._v("patterns-of-distributed-systems"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=v.exports}}]);