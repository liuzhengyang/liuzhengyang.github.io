(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{554:function(t,e,s){"use strict";s.r(e);var r=s(34),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"redis数据结构介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis数据结构介绍"}},[t._v("#")]),t._v(" redis数据结构介绍")]),t._v(" "),s("p",[t._v("redis内置了很多常用数据结构，了解这些数据结构的功能和应用场景能够让我们在需求开发时灵活运用解决实际问题。")]),t._v(" "),s("h2",{attrs:{id:"strings字符串、数字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#strings字符串、数字"}},[t._v("#")]),t._v(" Strings字符串、数字")]),t._v(" "),s("p",[t._v("String是redis中最基础的数据结构，你可以把它用作缓存最基础的kv（key-value）类型的缓存(value最大为512MB)，只需要把需要缓存的对象进行string的编解码即可。另外String也可以保存数值类型的数据，就可以来实现计数功能（redi提供了incr等原子操作）")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("计数器: 保存各种计数（比如视频播放数、点赞数、活动参与人数、剩余库存数、红包总金额）")]),t._v(" "),s("li",[t._v("kv: key value类型的缓存数据，比如保存一篇文章的内容、保存一个用户的信息等等")]),t._v(" "),s("li",[t._v("分布式限流: 通过带有过期时间的计数器，每次请求减一判断是否大于等于0，能够实现一些分布式限流的功能，比如限制一分钟内接口请求数不超过1000，还可以实现一个用户一分钟内发布评论不超过N个的功能。")]),t._v(" "),s("li",[t._v("分布式锁: 通过string的set以及set命令的选项参数nx和expire，可以实现简单的分布式锁，比如限制一个用户不要同时请求接口（避免接口处理过程中的用户维度并发操作导致数据错误）。(有人会提出质疑说网上的redis分布式锁有这样那样的问题，其实大部分需要分布式锁的场景都是比较简单的，要实现出一个完美的分布式解决方案，可能会比较重影响接口性能或者实现复杂)")])]),t._v(" "),s("h2",{attrs:{id:"list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[t._v("#")]),t._v(" List")]),t._v(" "),s("p",[t._v("List列表更多的时候是把它当成队列使用(最大2^32 - 1个元素)，使用入队出队功能，如果来使用它作为各种列表的话，很多时候不具备防重功能在使用的时候不是很方便。")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("抢红包: 发红包、拆红包入队，抢红包则是出队")])]),t._v(" "),s("h2",{attrs:{id:"set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" Set")]),t._v(" "),s("p",[t._v("Set是一种无序不重复的集合，添加删除检查是否存在都是O(1)的时间复杂度。")]),t._v(" "),s("h2",{attrs:{id:"sorted-set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sorted-set"}},[t._v("#")]),t._v(" Sorted Set")]),t._v(" "),s("p",[t._v("Sorted Set是结合了List和Set的一种数据结构，有序(按照元素score排序)的不重复(元素key不重复)的集合，Sorted Set是在业务开发中非常常用的数据结构（比List和Set应用面更广），因为在实际需求中，存在非常多的列表场景，比如视频列表、评论列表、关注列表、点赞列表、排行榜等等各种列表，每个列表都要按照一定规则排序，并且大部分都不能重复，所以使用Sorted Set就非常合适。")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("排行榜等榜单: 排行用的分数作为score")]),t._v(" "),s("li",[t._v("列表分页: member存储列表元素的id（视频id、用户id等），元素的id（具备递增且唯一）作为score（如果量级比较小QPS很低用时间戳也可以不会有多少重复时间戳），使用zrevrangebyscore进行分页查询，使用zscore判断是否关注等。")]),t._v(" "),s("li",[t._v("延迟队列: 任务执行的时间作为sorted set的score来保存，不断取出当前要执行的任务")])]),t._v(" "),s("h2",{attrs:{id:"hash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[t._v("#")]),t._v(" Hash")]),t._v(" "),s("p",[t._v("hash是一个map结构，可以像存储对象的多个字段一样存储一个key的多类数据。")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("保存一个对象的多个字段，比如一篇文章的作者、发布时间、标签等等信息作为一个hash上的多个字段保存。")])]),t._v(" "),s("h2",{attrs:{id:"pubsub"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pubsub"}},[t._v("#")]),t._v(" PubSub")]),t._v(" "),s("p",[t._v("redis中的pub/sub可以实现广播功能，类似rocketmq中的broadcast")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("websocket场景，server给client发送消息时，由于不知道client和那个server建立的链接，所以可以通过发送广播，让对应的server发送消息。")])]),t._v(" "),s("h2",{attrs:{id:"其他数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他数据结构"}},[t._v("#")]),t._v(" 其他数据结构")]),t._v(" "),s("p",[t._v("除了上述最基本的数据结构外，redis还提供了一些其他的数据结构，有的是需要安装相关redis stack来使用的。")]),t._v(" "),s("h3",{attrs:{id:"bitmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[t._v("#")]),t._v(" bitmap")]),t._v(" "),s("p",[t._v("bitmap本质上还是使用的string字符串，不过可以通过bit来进行操作，把这个key的value值想象成bit组成的数组。")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("记录多个是否的标记位: 比如记录一个用户是否是会员、是否是认证用户等等这类是否的标记，这些标记作为一个用户的一个bitmap上的不同index上的bit位，这样只需要请求一次就可以获取到一个用户的多种标记信息，并且存储上相对kv存储也比较节省资源。一个bitmap最多可以存储512MB的数据，一共有2^32个bit位，所以能够存储非常多的数据，比如签到场景可以存储一个用户某一天是否签到过。")])]),t._v(" "),s("h3",{attrs:{id:"bloomfilter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bloomfilter"}},[t._v("#")]),t._v(" bloomfilter")]),t._v(" "),s("p",[t._v("bloomfilter（也叫布隆过滤器）可以理解成一种特殊的set集合，它可以用来判断一个值是否在这个集合中，不过不同于普通的set，它的判断存在一定误判的可能（假阳性），如果bloomfilter判断一个值不在这个集合中，那么一定不在，但是如果判断在，那么有可能不在。")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("减少请求量、缓存穿透量: 比如为了防止大量请求查询缓存不存在穿透到数据库中查询，我们可以在缓存查询前加一层布隆过滤器的查询，如果不在布隆过滤器中，说明数据肯定不在数据库和缓存中，就不需要继续查询了。")])]),t._v(" "),s("h3",{attrs:{id:"hyperloglog"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog"}},[t._v("#")]),t._v(" hyperloglog")]),t._v(" "),s("p",[t._v("hyperloglog是一种概率性的去重计数数据结构，可以实现一定精度的去重计数")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("各类需要去重的计数，但是有不希望保存所有的记录数据: 文章阅读数、网站访客数等等")])]),t._v(" "),s("h3",{attrs:{id:"geohash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#geohash"}},[t._v("#")]),t._v(" geohash")]),t._v(" "),s("p",[t._v("geohash可以实现距离计算、距离查询等地理位置相关的功能")]),t._v(" "),s("p",[t._v("常见应用场景")]),t._v(" "),s("ul",[s("li",[t._v("距离判断、附近的人")])])])}),[],!1,null,null,null);e.default=v.exports}}]);