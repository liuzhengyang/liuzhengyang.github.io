(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{453:function(a,s,t){"use strict";t.r(s);var r=t(34),e=Object(r.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#id"}},[a._v("#")]),a._v(" ID")]),a._v(" "),t("h2",{attrs:{id:"有存储生成类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有存储生成类"}},[a._v("#")]),a._v(" 有存储生成类")]),a._v(" "),t("h3",{attrs:{id:"数据库表自增"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库表自增"}},[a._v("#")]),a._v(" 数据库表自增")]),a._v(" "),t("p",[a._v("业务表的primary key，配置auto increment")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"single-db-increment.png","data-src":"/assets/images/id/single-db-increment.png",loading:"lazy"}})]),a._v(" "),t("p",[a._v("问题: 分库分表时，id会重复")]),a._v(" "),t("p",[a._v("优化方案：单独创建一个表来生成id，从而解决分表各自自增的重复问题")]),a._v(" "),t("h3",{attrs:{id:"单独表自增"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单独表自增"}},[a._v("#")]),a._v(" 单独表自增")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"independent_id_table.png","data-src":"/assets/images/id/independent_id_table.png",loading:"lazy"}})]),a._v(" "),t("p",[a._v("优点：解决了分表重复问题\n缺点：")]),a._v(" "),t("ol",[t("li",[a._v("性能：写入瓶颈，10w tps左右；多一次db io交互")]),a._v(" "),t("li",[a._v("稳定性：数据库如果出现故障，则id完全不可用。如果出现网络抖动等原因，会引发超时、失败。")]),a._v(" "),t("li",[a._v("正确性：主从切换数据重复风险（主从延迟时发生主从切换s，会导致数据重复，可配置半同步缓解）")]),a._v(" "),t("li",[a._v("易用性：创建新id业务需要申请表、库")])]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/id/db-binlog-delay.png",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"表批量获取、独立server内存生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表批量获取、独立server内存生成"}},[a._v("#")]),a._v(" 表批量获取、独立server内存生成")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/id/id-server-batch.png",loading:"lazy"}})]),a._v(" "),t("ol",[t("li",[a._v("数据库设计改为每行表示一个业务的当前id水位，server从数据库获取一个范围放到内存消费堆外提供接口")]),a._v(" "),t("li",[a._v("server内部缓存设计，即减少了数据库压力，提升整体性能，也提高了稳定性。")]),a._v(" "),t("li",[a._v("主从延迟问题，可以通过一个强一致的存储来实现（比如zk、consul等），也可以开启半同步/全同步优化（因为数据库压力变小且有预取，耗时不敏感）。当前数据库切换为停写切换。")]),a._v(" "),t("li",[a._v("易用性：创建新id业务不再需要创建表，只需要在表中增加一行记录，方便做平台化")]),a._v(" "),t("li",[a._v("性能、稳定性：能够横向扩展Server，提高吞吐和稳定性。存储能够分片，进行业务隔离。")])]),a._v(" "),t("h3",{attrs:{id:"多级buffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多级buffer"}},[a._v("#")]),a._v(" 多级buffer")]),a._v(" "),t("p",[a._v("id sdk内部再采取一层预取，从而能够降低id sdk到id server的访问量，提升性能，提高可靠性。")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/id/id-sdk-buffer.png",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"严格-递增"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#严格-递增"}},[a._v("#")]),a._v(" ”严格“递增")]),a._v(" "),t("p",[a._v("从id sdk到id server的路由选择，可以按照biz进行一致性hash路由选择，保证一个”递增“。（缺点：单个server的性能容器成为瓶颈）\n或者采用biz+业务key，保证业务key维度的递增。")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/id/strict-increase.png",loading:"lazy"}})]),a._v(" "),t("p",[a._v("这种方式能够实现正常情况下的严格递增，但是如果在server升级容器、网络异常等情况，可能出现短暂时间的id乱序。\n这是在可用性和完全严格递增下选择更高可用性的方案。\n如果要求绝对的严格递增，可以采用raft选主的方法确定一个biz业务由哪个server生成，避免同一时刻有多个server生成，\n并且处理好旧server的缓存清除机制。")]),a._v(" "),t("h3",{attrs:{id:"机房容灾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#机房容灾"}},[a._v("#")]),a._v(" 机房容灾")]),a._v(" "),t("p",[a._v("如果需要机房级别的容灾，比如机房间网络故障等情形，可以通过在id后几位追加机房标识。这样两个机房之间可以完全不通信，并且不会重复。")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/id/idc-id.png",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"其他可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他可靠性"}},[a._v("#")]),a._v(" 其他可靠性")]),a._v(" "),t("ul",[t("li",[a._v("对存储访问的限流熔断(按业务维度)")]),a._v(" "),t("li",[a._v("自动调节batch")]),a._v(" "),t("li",[a._v("监控报警演练")])]),a._v(" "),t("h2",{attrs:{id:"时间戳生成类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间戳生成类"}},[a._v("#")]),a._v(" 时间戳生成类")]),a._v(" "),t("p",[a._v("使用snowflake算法")]),a._v(" "),t("h3",{attrs:{id:"workerid防重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workerid防重"}},[a._v("#")]),a._v(" workerId防重")]),a._v(" "),t("p",[a._v("一个重要问题是要解决workerId的防重。")]),a._v(" "),t("p",[a._v("采用的是在zk上注册一个path（持久化类型），表示抢占workerId成功。\n并且用另一个zk数据存储该workerId的进程信息（包含进程最近活跃时间）。")]),a._v(" "),t("p",[a._v("进程退出后删除该path和进程信息。")]),a._v(" "),t("p",[a._v("如果出现异常退出比如jvm崩溃等情况，则该path需要在合适时机进行删除（检测进程最近活跃时间距离当前的安全时间，防止进程因为其他原因）")]),a._v(" "),t("h3",{attrs:{id:"时间戳防回退"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间戳防回退"}},[a._v("#")]),a._v(" 时间戳防回退")]),a._v(" "),t("ol",[t("li",[a._v("进程内记录上一次毫秒值，如果下一次毫秒值比上一次小，则原地等待直到大于（并报警）")]),a._v(" "),t("li",[a._v("启动时，需要查询上次使用这个workerId的进程信息，确认活跃时间距离当前有一定安全buffer再启动。")])]),a._v(" "),t("h3",{attrs:{id:"可用性可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可用性可靠性"}},[a._v("#")]),a._v(" 可用性可靠性")]),a._v(" "),t("ol",[t("li",[a._v("天然支持机房容灾")]),a._v(" "),t("li",[a._v("id sdk也有批量预取设计")]),a._v(" "),t("li",[a._v("支持横向扩容（在workerId范围内），且不同业务可以访问不同的集群。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);