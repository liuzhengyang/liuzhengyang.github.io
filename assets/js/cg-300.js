(window.webpackJsonp=window.webpackJsonp||[]).push([[300],{730:function(a,t,r){"use strict";r.r(t);var e=r(34),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"launch-performance"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#launch-performance"}},[a._v("#")]),a._v(" launch-performance")]),a._v(" "),r("p",[a._v("服务刚启动阶段，如果处理用户请求，可能会出现请求很慢的情况。")]),a._v(" "),r("h2",{attrs:{id:"原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[a._v("#")]),a._v(" 原因")]),a._v(" "),r("ul",[r("li",[a._v("相关代码执行路径涉及类加载、bean加载、资源连接创建（比如到数据库的）")]),a._v(" "),r("li",[a._v("spring的bean创建会对beanName维度进行加锁，所有依赖该bean的其他getbean的调用都会阻塞")]),a._v(" "),r("li",[a._v("启动过程还会有比较多的JIT编译，JIT编译作为额外的CPU消耗（JIT编译线程）可能导致CPU使用率变高，在容器场景下还可能导致CPU throttling。")])]),a._v(" "),r("h2",{attrs:{id:"优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[a._v("#")]),a._v(" 优化")]),a._v(" "),r("h3",{attrs:{id:"启动过程预热"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#启动过程预热"}},[a._v("#")]),a._v(" 启动过程预热")]),a._v(" "),r("p",[a._v("正式接收外部流量之前，服务自身先完成好自己的关键代码、资源的预热。\n这里可以设计实现一个自动化资源预热框架，记录服务上次运行时使用到的资源（比如数据库或者某个类的某个方法），存放到一个存储中。\n下次启动时，拉取上次使用到的资源信息，进行主动初始化（比如数据库连接则调用建立连接、类方法通过反射调用）。\n另外如果有自动化用例，还可以通过外部的自动化测试用例预热接口。")]),a._v(" "),r("h3",{attrs:{id:"流量平滑增加"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流量平滑增加"}},[a._v("#")]),a._v(" 流量平滑增加")]),a._v(" "),r("p",[a._v("启动过程通过权重控制，刚启动的服务只接收少量请求，随着启动时间增加逐步提高权重比例。")])])}),[],!1,null,null,null);t.default=s.exports}}]);