(window.webpackJsonp=window.webpackJsonp||[]).push([[261],{692:function(r,a,e){"use strict";e.r(a);var o=e(34),n=Object(o.a)({},(function(){var r=this,a=r.$createElement,e=r._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"kafka-rebalance"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kafka-rebalance"}},[r._v("#")]),r._v(" kafka rebalance")]),r._v(" "),e("p",[r._v("首先我们回忆一下kafka的基本的架构，kafka分为producer、broker和consumer。\n为了能够横向扩展提升消息发送消费性能， 通过增加partition的方式，让消息能够保存到多个broker上。\n为了提升消费性能，增加了consumer group的概念，一个topic下同一个consumer group中的不同consumer实例可以共同消费提升消费能力")]),r._v(" "),e("p",[r._v("多个consumer消费同一个topic上的不同partition，就需要对consumer进行协调，控制哪个consumer消费哪个partition，并且要对异常情况进行处理，\n比如新增consumer、consumer重启、consumer机器宕机等情况。")]),r._v(" "),e("h2",{attrs:{id:"rebalance-protocol"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rebalance-protocol"}},[r._v("#")]),r._v(" rebalance protocol")]),r._v(" "),e("p",[r._v("rebalance protocol定义了一套资源分配协调的协议，consumer消费partition是协议的一种应用。")]),r._v(" "),e("p",[r._v("其中的概念有")]),r._v(" "),e("p",[r._v("members: 成员，比如同一个consumer group中的consumer\nresources: 资源，比如consumer要消费的partition")]),r._v(" "),e("h3",{attrs:{id:"findcoordinator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#findcoordinator"}},[r._v("#")]),r._v(" FindCoordinator")]),r._v(" "),e("p",[r._v("consumer启动后，会向broker发送FindCoordinator请求查找topic和consumer group的coordinator。\n之后consumer的请求都会和这个coordinator进行通信。")]),r._v(" "),e("h3",{attrs:{id:"joingroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#joingroup"}},[r._v("#")]),r._v(" JoinGroup")]),r._v(" "),e("p",[r._v("consumer获取到coordinator后，会向coordinator发送JoinGroup请求，表示希望加入到consumer group中，\n请求参数中会包含")]),r._v(" "),e("p",[r._v("groupId: consumer group, consumer参数配置里的group.id\nsessionTimeoutMs: consumer参数配置里的session.timeout.ms，默认45秒，如果超过这个时间consumer没有发送心跳给coordinator，coordinator就会将consumer从group中移除，发起新的rebalance。\nrebalanceTimeoutMs: 对于consumer场景，使用的是consumer的max.poll.interval.ms配置，具体的作用后面会介绍\nprotocolType: 表示具体的协议类型，consumer场景发送CONSUMER\nprotocols: 包含consumer subscribe的topic、支持的assignor等信息。")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/join-group.png",loading:"lazy"}})]),r._v(" "),e("p",[r._v("发送完JoinGroup请求后，如果当前的consumer group中没有member，coordinator会等待"),e("code",[r._v("group.initial.rebalance.delay.ms")]),r._v("默认3秒，再返回JoinGroup的结果。\n等待一段时间是为了等待一下其他的consumer，第一个加入到group中的member会被认定为group中的leader，leader会负责进行partition的assignment分配。")]),r._v(" "),e("h3",{attrs:{id:"partitionassignor-assign"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partitionassignor-assign"}},[r._v("#")]),r._v(" PartitionAssignor assign")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/join-group-assignment.png",loading:"lazy"}})]),r._v(" "),e("p",[r._v("consumer收到JoinGroup的response后，如果发现自己是leader，则会从response中拿到所有的partition和members信息以及protocolName（assignor的名称）\n然后使用assignor对partition进行分配绑定，绑定到各个consumer中。")]),r._v(" "),e("p",[r._v("默认的Assignor是RangeAssignor，会按照范围分配partition给各个consumer，如果不能平分，则前几个consumer会各自多分配一个partition。\n比如现在有3个consumer，8个partition。\n第一个consumer会获得3个partition，第二个consumer获得连续的3个partition,第三个consumer获得2个partition。")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/partition-assignment.png",loading:"lazy"}})]),r._v(" "),e("h3",{attrs:{id:"syncgroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#syncgroup"}},[r._v("#")]),r._v(" SyncGroup")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/sync-group.png",loading:"lazy"}})]),r._v(" "),e("p",[r._v("在接收到JoinGroup的结果后，leader会对partition进行assign分配，然后发起SyncGroup请求将assignment结果发送给coordinator。\n其他的consumer也会向coordinator发送SyncGroup请求，assignments参数是空的，目的是获取leader的分配结果。")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/sync-group-response.png",loading:"lazy"}})]),r._v(" "),e("p",[r._v("SyncGroup的返回结果中会包含partition的分配结果，收到分配结果后，consumer会保存到内存中，后面consumer通过poll拉取消息时就会向这些partition拉取。\n同时因为leader计算可能有一定延迟，所以其他的consumer的SyncGroup请求不一定能获取到assignment结果，没有结果时coordinator会返回一个可以重试的错误码，\nconsumer会进行重试（具有回避策略）。")]),r._v(" "),e("h3",{attrs:{id:"heartbeat心跳机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#heartbeat心跳机制"}},[r._v("#")]),r._v(" Heartbeat心跳机制")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/heartbeat.png",loading:"lazy"}})]),r._v(" "),e("p",[r._v("rebalance protocol需要考虑到consumer可能重启、故障、或新增减少consumer节点等情况。\n每个consumer会定时向coordinator发送心跳，发送心跳可以表明当前consumer的存活状态（间隔是heartbeat.interval.ms)，另外还可以从\ncoordinator获取信息，比如是否要进行rebalance。")]),r._v(" "),e("p",[r._v("当发生如下情况时，会触发rebalance")]),r._v(" "),e("ul",[e("li",[r._v("consumer重启，比如升级服务，consumer关闭前会向coordinator发送LeaveGroup请求，表示退出group")]),r._v(" "),e("li",[r._v("consumer长时间没有发送心跳，比如因为宕机或GC长时间没有发送心跳（间隔超过session.timeout.ms)")]),r._v(" "),e("li",[r._v("新增或减少consumer节点，扩缩容")]),r._v(" "),e("li",[r._v("partition数量变化")])]),r._v(" "),e("p",[r._v("也就是当coordinator发现members或partition出现变化，都会发起rebalance。")]),r._v(" "),e("p",[r._v("coordinator会为每个group维护一个GroupState，分为Empty, Stable, PreparingRebalance, CompletingRebalance, Dead。")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img_1.png","data-src":"/assets/images/kafka/group-state.png",loading:"lazy"}})]),r._v(" "),e("ul",[e("li",[r._v("Empty: group中没有member，比如所有的member都从group中离开。")]),r._v(" "),e("li",[r._v("Stable: 现在group状态稳定，消费者可以正常消费")]),r._v(" "),e("li",[r._v("PreparingRebalance: 当coordinator发现group的member或partition发生变化，会转入到PreparingRebalance阶段，consumer发送心跳会得知这一状态，然后重新在下次poll时发起JoinGroup请求。PreparingRebalance阶段会等待JoinGroup请求收集group中的member，直到所有已知的member（除去已知因为超时不在group中的member）已经加入或者等待时间超过了rebalanceTimeoutMs(这是第一次JoinGroup时发送的参数默认5分钟)。")]),r._v(" "),e("li",[r._v("CompletingRebalance: 当PreparingRebalance状态下，所有的已知的member已经发送了JoinGroup请求或者超过了等待时间，会转变状态为CompletingRebalance，然后给leader的JoinGroup请求返回结果，包含当前group中的member信息，leader收到JoinGroup的Response后计算assignment，然后通过SyncGroup发送给coordinator，收到leader的SyncGroup请求后，状态变为Stable。然后coordinator将assignment通过consumer的SyncGroup请求，返回给各个consumer，")])]),r._v(" "),e("p",[r._v("所以rebalance主要包含两个部分，一个是PreparingRebalance收集group的member信息，收集完成后进入到CompletingRebalance，等待leader计算assignment，leader通过SyncGroup发送assignment后进入到Stable状态。")]),r._v(" "),e("p",[r._v("客户端如何发现需要rebalance了呢？通过心跳时返回的异常或commit offset时返回的异常。")]),r._v(" "),e("p",[r._v("新节点加入触发rebalance的时序图如下")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/rebalance-sequence.png",loading:"lazy"}})]),r._v(" "),e("h3",{attrs:{id:"incremental-cooperative-rebalancing-protocol"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#incremental-cooperative-rebalancing-protocol"}},[r._v("#")]),r._v(" incremental cooperative rebalancing protocol")]),r._v(" "),e("p",[r._v("开始rebalance后，consumer发现现在在rebalance，需要放下手中的活，也就是本地清除消费的partition，然后调用JoinGroup，等待JoinGroup返回，再发送SyncGroup，等待SyncGrup的结果后，才能从中找到新的partition\n开始消费。所以在中间这段时间内，所有的consumer都是停顿的，没有消费消息，可能会有一段时间的中断。为了优化这个问题，kafka增加了一种COOPERATIVE模式的协议。")]),r._v(" "),e("p",[r._v("rebalance协议有两种模式，EAGER和COOPERATIVE。\n默认是EAGER，EAGER模式下在JoinGroup之后，重新SyncGroup之前，consumer会放弃(revoke)自己本地的所有partition，暂定从这些partition中消费。")]),r._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"/assets/images/kafka/cooperative-protocol.png",loading:"lazy"}})]),r._v(" "),e("p",[r._v("COOPERATIVE模式下，由EAGER模式的一次JoinGroup/SyncGroup交互变成了两次。\nconsumer发送JoinGroup请求时，会带上自己正在消费的partition，但是不撤销本地正在消费的partition。\nleader收到所有的消费信息后，为每个consumer计算partition diff，diff是新增的partition和要撤销的partition,不过第一次SyncGroup时，只给consumer\n返回要撤销的partition，consumer收到信息后撤销对应的partition消费。然后发起新一轮的JoinGroup/SyncGroup交互，第二轮leader会返回增量的partition消费，\n由此就完成了partition的消费转移，而且不会出现一个partition同一时间被两个consumer消费的情况。")]),r._v(" "),e("p",[r._v("相比之下，EAGER模式会有一段时间的消费中断，COOPERATIVE模式对consumer消费的影响更小。")]),r._v(" "),e("h2",{attrs:{id:"思考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[r._v("#")]),r._v(" 思考")]),r._v(" "),e("h3",{attrs:{id:"为什么rebalance-protocol要由consumer中的leader负责分配而不是由coordinator分配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么rebalance-protocol要由consumer中的leader负责分配而不是由coordinator分配"}},[r._v("#")]),r._v(" 为什么rebalance protocol要由consumer中的leader负责分配而不是由coordinator分配？")]),r._v(" "),e("p",[r._v("是为了增加扩展性，开发者可以在使用consumer时实现自定义的Assignor分配策略。")]),r._v(" "),e("h3",{attrs:{id:"可能出现重复消费、消息消费丢失吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可能出现重复消费、消息消费丢失吗"}},[r._v("#")]),r._v(" 可能出现重复消费、消息消费丢失吗")]),r._v(" "),e("p",[r._v("重复消费是有可能出现的，比如一个consumer因为GC停住导致rebalance，其他consumer消费它的partition，但是原来的consumer在GC恢复后继续处理之前拉取的那一批消息就会出现重复。\n当然还有很多其他的重复的场景，如果要求比较严格的程序，要注意做好幂等处理。")]),r._v(" "),e("p",[r._v("消息没有消费到也是有可能的，比如如果consumer拉取完任务后提交到另一个线程池处理任务，因为consumer默认会异步提交offset，如果这时\nconsumer异常挂掉（比如容器或机器重启），则没有消费完的消息就会丢失，因为其他的consumer拉取partition时会从提交的最新offset开始拉取。\n如果对消息可靠性要求比较严格，consumer最好通过程序手动控制offset的提交，结合幂等性保证可靠性。")]),r._v(" "),e("h2",{attrs:{id:"对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[r._v("#")]),r._v(" 对比")]),r._v(" "),e("p",[r._v("其他的mq是如何对partition进行rebalance的呢？")]),r._v(" "),e("p",[r._v("rocketmq")]),r._v(" "),e("p",[r._v("pulsar")]),r._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),e("p",[r._v("rebalance协议能够让consumer更加均衡的分配partition，能够对consumer、partition的变化进行响应。整体流程依赖JoinGroup, SyncGroup, Heartbeat请求通信，\ngroup中的leader通过assignor分配partition。")]),r._v(" "),e("h2",{attrs:{id:"更多参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更多参考"}},[r._v("#")]),r._v(" 更多参考")]),r._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://medium.com/streamthoughts/apache-kafka-rebalance-protocol-or-the-magic-behind-your-streams-applications-e94baf68e4f2",target:"_blank",rel:"noopener noreferrer"}},[r._v("Apache Kafka Rebalance Protocol, or the magic behind your streams applications"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://cwiki.apache.org/confluence/display/KAFKA/Incremental+Cooperative+Rebalancing%3A+Support+and+Policies",target:"_blank",rel:"noopener noreferrer"}},[r._v("Incremental Cooperative Rebalancing: Support and Policies"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://www.confluent.io/blog/cooperative-rebalancing-in-kafka-streams-consumer-ksqldb/",target:"_blank",rel:"noopener noreferrer"}},[r._v("From Eager to Smarter in Apache Kafka Consumer Rebalances"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://cwiki.apache.org/confluence/display/KAFKA/KIP-429%3A+Kafka+Consumer+Incremental+Rebalance+Protocol",target:"_blank",rel:"noopener noreferrer"}},[r._v("KIP-429: Kafka Consumer Incremental Rebalance Protocol"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://www.confluent.io/blog/cooperative-rebalancing-in-kafka-streams-consumer-ksqldb/",target:"_blank",rel:"noopener noreferrer"}},[r._v("From Eager to Smarter in Apache Kafka Consumer Rebalances"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);