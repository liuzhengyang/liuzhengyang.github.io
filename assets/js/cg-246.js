(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{677:function(t,a,e){"use strict";e.r(a);var r=e(34),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"efficient-coroutines-for-the-java-platform-pdf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#efficient-coroutines-for-the-java-platform-pdf"}},[t._v("#")]),t._v(" Efficient Coroutines for the Java Platform.pdf")]),t._v(" "),e("h2",{attrs:{id:"implementation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[t._v("#")]),t._v(" Implementation")]),t._v(" "),e("ul",[e("li",[t._v("Separate coroutine stacks: 为每个coroutine分配单独的stack空间。")]),t._v(" "),e("li",[t._v("Copying parts of the stack: 每个coroutine的stack数据需要从stack复制（协程让出调度）以及复制到stack（协程恢复）。缺点：复制成本让协程之间的转换开销更大。gc需要遍历stack data。")])]),t._v(" "),e("p",[t._v("separate coroutine stack切换性能更好，代价是内存占用更高，对于协程数量不多的应用，或者内存空间比较充分的应用，\nseparate coroutine stack更合适。")]),t._v(" "),e("h3",{attrs:{id:"additional-stacks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#additional-stacks"}},[t._v("#")]),t._v(" Additional Stacks")]),t._v(" "),e("p",[t._v("为了最佳性能考虑，JKU的协程实现使用的是独立栈。\n（不考虑caching影响），CPU切换coroutine只需要很廉价的常数时间的操作，因为只需要保存恢复少数的CPU寄存器数据。")]),t._v(" "),e("h2",{attrs:{id:"resource"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#resource"}},[t._v("#")]),t._v(" Resource")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://ssw.jku.at/Research/Papers/Stadler10/Stadler10a.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Efficient Coroutines for the Java Platform.pdf"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);