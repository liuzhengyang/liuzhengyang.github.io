(window.webpackJsonp=window.webpackJsonp||[]).push([[245],{676:function(n,s,e){"use strict";e.r(s);var a=e(34),r=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"wispscheduler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wispscheduler"}},[n._v("#")]),n._v(" WispScheduler")]),n._v(" "),e("p",[n._v("WispScheduler负责管理所有的worker，worker能够work-stealing，即发现自己没有工作时，会主动查看其他worker有没有没做的工作，尝试抢过来运行。\n每个worker线程关联一个ConcurrentLinkedQueue来接收任务。")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    WispScheduler(int parallelism, int stealRetry, int pushRetry, int helpStealRetry,\n                  ThreadFactory threadFactory, WispEngine engine, boolean isRootCarrier) {\n        assert parallelism > 0;\n        PARALLEL = parallelism;\n        STEAL_RETRY = stealRetry;\n        PUSH_RETRY = pushRetry;\n        HELP_STEAL_RETRY = helpStealRetry;\n        IS_ROOT_CARRIER = isRootCarrier;\n        this.engine = engine;\n        this.threadFactory = threadFactory;\n        workers = new Worker[PARALLEL];\n        for (int i = parallelism - 1; i >= 0; i--) {\n            workers[i] = new Worker(i);\n            workers[i].next = i == PARALLEL - 1 ? null : workers[i + 1];\n        }\n        workers[PARALLEL - 1].next = workers[0];\n        if (!isRootCarrier) {\n            // root worker threads are started in startWispDaemons()\n            startWorkerThreads();\n        }\n    }\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br")])]),e("h2",{attrs:{id:"worker定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#worker定义"}},[n._v("#")]),n._v(" Worker定义")]),n._v(" "),e("ul",[e("li",[n._v("Worker包含一个taskQueue。taskQueue的类型是ConcurrentLinkedQueue，是juc提供的无锁的并发队列，这是因为队列没有长度上限，不需要阻塞等待，任务获取可以由worker自行决定是否阻塞挂起。")]),n._v(" "),e("li",[n._v("每个Worker中还包含了一个WispEventPump的引用，pump与Worker是一对多的关系。这里有配置控制pump是否为null。\n"),e("ul",[e("li",[n._v("默认情况下，wisp2采用的是全转线程为协程模式，pump不为null，会由Worker负责调用pump的pollAndDispatchEvents方法")])])]),n._v(" "),e("li",[n._v("每个Worker还包含一个next，形成一个链表结构。")]),n._v(" "),e("li",[n._v("timerManager是时间管理器，用来实现定时阻塞功能，比如juc中同步器的有超时时间的条件等待。")]),n._v(" "),e("li",[n._v("每个Worker对应一个线程，通过threadFactory创建，这个线程就是jvm的普通线程，会运行WispTask")]),n._v(" "),e("li",[n._v("hasBeenHandoff: TODO FIXME 已经被转移，是什么作用？")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Worker implements Runnable {\n    ConcurrentLinkedQueue&lt;StealAwareRunnable> taskQueue;\n    private final TimeOut.TimerManager timerManager;\n    private final Thread thread;\n    private final WispEventPump pump; // ONE pump verse N worker relationship\n    volatile boolean hasBeenHandoff = false;\n    private Worker next;\n\n    private final static int QL_PROCESSING_TIMER = -1; // idle than ql=0, but not really idle\n    private final static int QL_POLLING = -1000002;\n    private final static int QL_IDLE = -2000002;\n\n    volatile int queueLength;\n\n    Worker(int index) {\n        thread = threadFactory.newThread(this);\n        WispEngine.carrierThreads.add(thread);\n        taskQueue = new ConcurrentLinkedQueue&lt;>();\n        timerManager = new TimeOut.TimerManager();\n        queueLength = 0;\n        pump = WispConfiguration.CARRIER_AS_POLLER &amp;&amp; IS_ROOT_CARRIER ? WispEventPump.Pool.INSTANCE.getPump(index) : null;\n    }\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br")])]),e("p",[n._v("run方法是Worker执行的代码逻辑。")]),n._v(" "),e("ul",[e("li",[n._v("WispCarrier.current() 获取当前的Worker对应的WispCarrier")]),n._v(" "),e("li",[n._v("WispSysmon.INSTANCE.register(carrier)： 向WispSysmon中注册")]),n._v(" "),e("li",[n._v("runCarrier: while(true)运行，不断从taskQueue中获取StealAwareRunnable任务执行任务，如果没有任务，会park或继续轮询polling")]),n._v(" "),e("li",[n._v("doExec: 直接调用task.run(StealAwareRunnable)")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('    void processTimer() {\n        timerManager.processTimeoutEventsAndGetWaitDeadline(System.nanoTime());\n    }\n\n    @Override\n    public void run() {\n        try {\n            WispCarrier carrier = WispCarrier.current();\n            carrier.engine = WispScheduler.this.engine;\n            carrier.worker = this;\n            WispScheduler.this.engine.carrierEngines.add(carrier);\n            WispEngine.registerPerfCounter(carrier);\n            WispSysmon.INSTANCE.register(carrier);\n            runCarrier(carrier);\n        } finally {\n            WispEngine.carrierThreads.remove(thread);\n            try {\n                engine.shutdownBarrier.await();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                e.printStackTrace(new PrintWriter(sw));\n                System.out.println("[Wisp-ERROR] unexpected error "\n                        + "on current" + Thread.currentThread() + "has exception"\n                        + sw.toString());\n            }\n        }\n    }\n\n    private void runCarrier(final WispCarrier carrier) {\n        int r = randomSeed();\n        Runnable task;\n        while (true) {\n            while ((task = pollTask(false)) != null) {\n                doExec(task);\n            }\n\n            if (carrier.engine.terminated) {\n                return;\n            } else if ((task = SCHEDULING_POLICY.steal(this, r = nextRandom(r))) != null) {\n                doExec(task);\n                continue; // process local queue\n            }\n            doParkOrPolling();\n        }\n    }\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br")])]),e("p",[n._v("每次while遍历，发现队列中没有可执行任务时，会调用doParkOrPolling。")]),n._v(" "),e("ul",[e("li",[n._v("st是state表示状态，QL_PROCESSING_TIMER为-1。")]),n._v(" "),e("li",[n._v("timerManager.processTimeoutEventsAndGetWaitDeadline: 处理timeOutManager中的达到超时时间的任务，如果没有会返回最近要超时的时间点。")]),n._v(" "),e("li",[n._v("返回这个时间点后，worker如果真的没有任务，就可以sleep到这个时间再醒过来")]),n._v(" "),e("li",[n._v("判断当前的队列长度，如果不为零返回，说明有其他人向队列里添加了任务。")]),n._v(" "),e("li",[n._v("如果为0，会调用LENGTH_UPDATE通过cas的方式，cas从0到-1。LENGTH_UPDATE是AtomicIntegerFieldUpdate，指向WispScheduler的queueLength字段。")]),n._v(" "),e("li",[n._v("cas没成功，说明其他线程修改了队列长度，或者其他线程执行了cas。")]),n._v(" "),e("li",[n._v("再判断一下queueLength==st也就是为-1，然后通过pump.tryAcquire，tryAcquire成功，update为QL_POLLING，否则为QL_IDLE；tryAcquire会把worker通过cas设置到WispEventPump的owner字段中。")]),n._v(" "),e("li",[n._v("tryAcquire只是cas设置owner，但是pump中没有使用owner这个字段，有何意义？owner会负责执行doPolling，因为一个pump对应N个worker。")]),n._v(" "),e("li",[n._v("通过LENGTH_UPDATE cas queueLength为update的值，cas成功，会再判断taskQueue是否为空，然后根据pump的tryAcquire结果，如果成功，则负责进行doPolling")]),n._v(" "),e("li",[n._v("doPolling负责不断调用pump的pollAndDispatchEvents方法，直到达到deadline也就是有定时任务要处理了。")]),n._v(" "),e("li",[n._v("doPolling结束后，会判断update是否等于QL_POLLING，如果等于说明是pump的owner，则会调用pump.release释放owner角色，说明当前的carrier暂时停止进行pollAndDispatch")]),n._v(" "),e("li",[n._v("LENGTH_UPDATE.addAndGet(this, -st)，会给queueLength加1，以为length是-1,加完后变成0")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    private void doParkOrPolling() {\n        int st = QL_PROCESSING_TIMER;\n        if (queueLength != 0 || !LENGTH_UPDATER.compareAndSet(this, 0, st)) {\n            return;\n        }\n        final long now = System.nanoTime();\n        final long deadline = timerManager.processTimeoutEventsAndGetWaitDeadline(now);\n        assert deadline != 0;\n        if (queueLength == st) {\n            int update = pump != null &amp;&amp; pump.tryAcquire(this) ? QL_POLLING : QL_IDLE;\n            if (LENGTH_UPDATER.compareAndSet(this, st, update)) {\n                st = update;\n                if (taskQueue.peek() == null) {\n                    if (st == QL_IDLE) {\n                        UA.park0(false, deadline &lt; 0 ? 0 : deadline - now);\n                    } else { // st == QL_POLLING\n                        doPolling(deadline, now);\n                    }\n                }\n            }\n            if (update == QL_POLLING) {\n                pump.release(this);\n            }\n        }\n        LENGTH_UPDATER.addAndGet(this, -st);\n    }\n\n    private void doPolling(final long deadline, long now) {\n        while ((deadline &lt; 0 || deadline > now) &amp;&amp;\n                !pump.pollAndDispatchEvents(\n                        deadline &lt; 0 ? -1 : TimeOut.nanos2Millis(deadline - now)) &amp;&amp;\n                queueLength == QL_POLLING) { // if wakened by event, we can still waiting..\n            now = deadline &lt; 0 ? now : System.nanoTime();\n        }\n    }\n\n    /**\n     * @return if it is idle\n     */\n    private boolean doSignalIfNecessary(int len) {\n        Thread current = JLA.currentThread0();\n        if (thread != current) {\n            if (len == QL_IDLE) {\n                UA.unpark0(this.thread);\n            } else if (len == QL_POLLING) {\n                pump.wakeup();\n            }\n        }\n        return len &lt; 0;\n    }\n\n    boolean idleOrPolling() {\n        return queueLength == QL_IDLE || queueLength == QL_POLLING;\n    }\n\n    boolean isProcessingTimer() {\n        return queueLength == QL_PROCESSING_TIMER;\n    }\n\n    Runnable pollTask(boolean isSteal) {\n        StealAwareRunnable task = taskQueue.poll();\n        if (task != null) {\n            LENGTH_UPDATER.decrementAndGet(this);\n            if (isSteal &amp;&amp; !task.isStealEnable()) {\n                // disable steal is a very uncommon case,\n                // The overhead of re-enqueue is acceptable\n                // use pushAndSignal rather than offer,\n                // let the worker execute the task as soon as possible.\n                pushAndSignal(task);\n                return null;\n            }\n        }\n        return task;\n    }\n\n    /**\n     * @return if it is idle\n     */\n    boolean pushAndSignal(StealAwareRunnable task) {\n        taskQueue.offer(task);\n        return doSignalIfNecessary(LENGTH_UPDATER.getAndIncrement(this));\n    }\n\n    void signal() {\n        doSignalIfNecessary(queueLength);\n    }\n\n    void copyContextFromDetachedCarrier(Worker detachedWorker) {\n        // copy timers\n        timerManager.copyTimer(detachedWorker.timerManager.queue);\n        // drain wispTasks\n        StealAwareRunnable task;\n        while ((task = detachedWorker.taskQueue.poll()) != null) {\n            pushAndSignal(task);\n        }\n    }\n\n    WispScheduler theScheduler() {\n        return WispScheduler.this;\n    }\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br"),e("span",{staticClass:"line-number"},[n._v("90")]),e("br"),e("span",{staticClass:"line-number"},[n._v("91")]),e("br"),e("span",{staticClass:"line-number"},[n._v("92")]),e("br"),e("span",{staticClass:"line-number"},[n._v("93")]),e("br"),e("span",{staticClass:"line-number"},[n._v("94")]),e("br"),e("span",{staticClass:"line-number"},[n._v("95")]),e("br"),e("span",{staticClass:"line-number"},[n._v("96")]),e("br"),e("span",{staticClass:"line-number"},[n._v("97")]),e("br"),e("span",{staticClass:"line-number"},[n._v("98")]),e("br"),e("span",{staticClass:"line-number"},[n._v("99")]),e("br"),e("span",{staticClass:"line-number"},[n._v("100")]),e("br"),e("span",{staticClass:"line-number"},[n._v("101")]),e("br")])]),e("h2",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[n._v("#")]),n._v(" 问题")]),n._v(" "),e("p",[n._v("WispScheduler当前的问题在于，对于Worker的park和unpark没有谨慎调用，容易导致一个Worker频繁的进行park、unpark切换，\n导致大量CPU消耗在阻塞唤醒线程上下文切换上。")]),n._v(" "),e("p",[n._v("WispScheduler的push调度策略是，如果WispTask的原始Worker当前繁忙（不是idle状态），则会随机找另一个最空闲Worker来入队（如果阻塞会先唤醒）\n并且在没有任务后（且steal不成功、没抢到event pump任务）会立刻park。")]),n._v(" "),e("h2",{attrs:{id:"和forkjoinpool的差异"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和forkjoinpool的差异"}},[n._v("#")]),n._v(" 和ForkJoinPool的差异")]),n._v(" "),e("p",[n._v("ForkJoinPool的设计有如下特点")]),n._v(" "),e("ul",[e("li",[n._v("Worker生产了任务时，会放到自己的WorkQueue中，从而减少了唤醒次数")]),n._v(" "),e("li",[n._v("唤醒Worker使用的最近（将要）park的Worker（通过栈结构），在一定程度上又能减少唤醒和park次数。")]),n._v(" "),e("li",[n._v("Worker的steal使用的随机scan steal，Wisp在16核以上时使用的随机选择最空闲Worker唤醒。")]),n._v(" "),e("li",[n._v("具有submission queue和local queue，能够减少冲突、减少唤醒。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);