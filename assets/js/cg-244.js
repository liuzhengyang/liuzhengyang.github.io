(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{675:function(e,t,r){"use strict";r.r(t);var l=r(34),a=Object(l.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"wispeventpump"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wispeventpump"}},[e._v("#")]),e._v(" WispEventPump")]),e._v(" "),r("p",[e._v("IO等待是上下文切换的重要原因。\nIO分为两类，一类是作为服务端(server，比如tomcat、grpc server)，接收外部请求，\n处理请求，返回响应。\nio server的线程模型一般为，\n1个线程负责accept，负责处理客户端建连请求，完成channel建立。\nN个io线程负责channel的读写。\nM个worker线程负责对请求进行处理生成返回结果。")]),e._v(" "),r("p",[e._v("交互流程为，accept线程接收请求建连，创建channel并绑定到io线程，\nio线程监听有请求数据（有数据可读），读取数据(read)，读取完后把byte数据\n解码成请求模型，交给worker线程处理，worker线程处理完成得到结果，\n编码成byte数据，交给io线程，io线程在channel可写的时候，写回(write)数据给远程。")]),e._v(" "),r("p",[e._v("当前Java的io普遍使用NIO，NIO中分为多个角色。")]),e._v(" "),r("p",[e._v("server端NIO的使用流程为，创建ServerSocketChannel，创建Selector\n调用register把selector和ops（关心的操作事件）注册上。")]),e._v(" "),r("p",[e._v("然后不断调用select，select在有关心的事件发生后（或超过select传入的超时时间）会返回，\n返回SelectionKey集合，通过SelectionKey可以得到对应的事件的Channel，并且能够判断具体的事件类型（一个SelectionKey可以包含多个）。\n事件分为accept、read、write几种。\naccept，对客户端建立连接。\nread事件调用read接收请求数据。\nwrite事件把返回结果返回。")]),e._v(" "),r("h2",{attrs:{id:"epoll"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[e._v("#")]),e._v(" Epoll")]),e._v(" "),r("p",[e._v("epoll: 我们可以把NIO看做是Java对于非阻塞IO的接口抽象，epoll是linux时的非阻塞IO实现，Java在linux时底层会使用epoll作为NIO的接口实现。")]),e._v(" "),r("h2",{attrs:{id:"wisp的epollselectorimpl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wisp的epollselectorimpl"}},[e._v("#")]),e._v(" Wisp的EPollSelectorImpl")]),e._v(" "),r("p",[e._v("EPollSelector继承实现了SelectorImpl类。\n创建一个epfd, "),r("code",[e._v("EPoll.create()")]),e._v("\n创建pollArrayAddress, "),r("code",[e._v("EPoll.allocatePollArray")]),e._v("\n创建pipe, fd0, fd1: 分别做什么的？interrupt中断使用的。\n"),r("code",[e._v("EPoll.ctl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);")])]),e._v(" "),r("h3",{attrs:{id:"select"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[e._v("#")]),e._v(" select")]),e._v(" "),r("p",[e._v("协程调用select时，")]),e._v(" "),r("ul",[r("li",[e._v("processUpdateQueue")]),e._v(" "),r("li",[e._v("processDeregisterQueue")])]),e._v(" "),r("p",[e._v("epollWait调用到WispEventPump的eventWaitForWisp")]),e._v(" "),r("p",[e._v("如果是MONOLITHIC_POLL(默认是true)，则把epollArray记录到当前WispTask中.\n如果timeout等待事件不为0，调用registerEvent把当前的WispTask和监听的fd的对应关系记录。\n然后调用IOEA.eventCtl把要关心的fd和event通过ctl修改到epfd的epoll instance。\n然后调用WispTask.jdkPark阻塞协程timeout时间。\n协程从阻塞态恢复后（可能超时、可能等待的epoll事件已经发生返回），调用me.getEpollEventNum返回。\nepollEventNum是由pollAndDispatchEvents过程设置的。")]),e._v(" "),r("h3",{attrs:{id:"poll"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[e._v("#")]),e._v(" Poll")]),e._v(" "),r("p",[e._v("pollAndDispatchEvents")]),e._v(" "),r("h2",{attrs:{id:"netty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[e._v("#")]),e._v(" netty")]),e._v(" "),r("p",[e._v("epollEventLoop")]),e._v(" "),r("p",[e._v("eventExecutorLoop")]),e._v(" "),r("h3",{attrs:{id:"netty-native"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty-native"}},[e._v("#")]),e._v(" netty native")]),e._v(" "),r("p",[e._v("不关闭native netty线程不转wisp测试")]),e._v(" "),r("h2",{attrs:{id:"registerevent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#registerevent"}},[e._v("#")]),e._v(" registerEvent")]),e._v(" "),r("p",[e._v("epoll_ctl 注册事件")]),e._v(" "),r("h2",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])])])}),[],!1,null,null,null);t.default=a.exports}}]);