(window.webpackJsonp=window.webpackJsonp||[]).push([[209],{639:function(n,s,e){"use strict";e.r(s);var a=e(34),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"synchronized、monitor-lock加锁流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#synchronized、monitor-lock加锁流程"}},[n._v("#")]),n._v(" synchronized、monitor lock加锁流程")]),n._v(" "),e("p",[n._v("synchronized关键字是Java提供的内置的锁，也可以成为monitor lock。\n通过synchronzied加锁，实现可见性、原子性、防止重排序等并发场景下的线程间同步协调机制。")]),n._v(" "),e("p",[n._v("在Java语言层面，通过对一个对象加synchronized形成加锁代码块或给一个方法增加synchronized标识，都能使得对应的代码块\n或方法在执行前后进行加锁、释放锁的操作。")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("synchronized(lock) {\n    // \n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br")])]),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public synchronized void doSomething() {\n    //\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br")])]),e("h2",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[n._v("#")]),n._v(" 实现")]),n._v(" "),e("p",[n._v("从字节码层面来看，"),e("code",[n._v("synchornized(lock)")]),n._v("这样的代码块，在前后会有一个"),e("code",[n._v("monitorenter")]),n._v("和"),e("code",[n._v("monitorexit")]),n._v("指令")]),n._v(" "),e("p",[n._v("比如如下Java代码")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('private Object lock = new Object();\npublic void test() {\n    synchronized (lock) {\n        System.out.println("test");\n    }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("p",[n._v("编译后字节码中包含两个monitorexit，一个是代码块正常执行完，另一个用于exception table实现异常情况也能执行monitorexit保证锁释放。")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" 0 aload_0\n 1 getfield #3 &lt;com/lzy/SynchronizedTest.lock : Ljava/lang/Object;>\n 4 dup\n 5 astore_1\n 6 monitorenter\n 7 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;>\n10 ldc #5 &lt;test>\n12 invokevirtual #6 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V>\n15 aload_1\n16 monitorexit\n17 goto 25 (+8)\n20 astore_2\n21 aload_1\n22 monitorexit\n23 aload_2\n24 athrow\n25 return\n\nException table:\nfrom    to  target type\n 7    17    20   any\n20    23    20   any\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br")])]),e("p",[n._v("而synchronized方法，该方法的access flag中的ACC_SYNCHRONIZED标记位会被设置为1。")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("public synchronized void testSync();\n    descriptor: ()V\n    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br")])]),e("h3",{attrs:{id:"monitorenter的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#monitorenter的实现"}},[n._v("#")]),n._v(" monitorenter的实现")]),n._v(" "),e("p",[n._v("从模版解释器开始看monitor的处理。在遇到monitorenter指令时，jvm会在当前的线程栈上创建一个monitor block的内存区域，这块\n内存用于存放BasicObjectLock对象，该对象会用于后续的轻量级锁加锁。")]),n._v(" "),e("p",[n._v("下面以templateInterpreter字节码解释执行时的实现进行分析。")]),n._v(" "),e("ul",[e("li",[n._v("rax寄存器是加锁的对象（即synchronized(obj)中的obj）")]),n._v(" "),e("li",[e("code",[n._v("__ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);")]),n._v("将被锁对象地址设置到BasicObjectLock中的obj字段。")]),n._v(" "),e("li",[e("code",[n._v("__ lock_object(rmon);")]),n._v("：具体的加锁过程。")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//-----------------------------------------------------------------------------\n// Synchronization\n//\n// Note: monitorenter &amp; exit are symmetric routines; which is reflected\n//       in the assembly code structure as well\n//\n// Stack layout:\n//\n// [expressions  ] &lt;--- rsp               = expression stack top\n// ..\n// [expressions  ]\n// [monitor entry] &lt;--- monitor block top = expression stack bot\n// ..\n// [monitor entry]\n// [frame data   ] &lt;--- monitor block bot\n// ...\n// [saved rbp    ] &lt;--- rbp\nvoid TemplateTable::monitorenter() {\n  transition(atos, vtos);\n\n  // check for NULL object\n  __ null_check(rax);\n\n  const Address monitor_block_top(\n        rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);\n  const Address monitor_block_bot(\n        rbp, frame::interpreter_frame_initial_sp_offset * wordSize);\n  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n\n  Label allocated;\n\n  Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n  Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);\n  Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n\n  // initialize entry pointer\n  __ xorl(rmon, rmon); // points to free slot or NULL\n\n  // find a free slot in the monitor block (result in rmon)\n  {\n    Label entry, loop, exit;\n    __ movptr(rtop, monitor_block_top); // points to current entry,\n                                        // starting with top-most entry\n    __ lea(rbot, monitor_block_bot);    // points to word before bottom\n                                        // of monitor block\n    __ jmpb(entry);\n\n    __ bind(loop);\n    // check if current entry is used\n    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);\n    // if not used then remember entry in rmon\n    __ cmovptr(Assembler::equal, rmon, rtop);   // cmov => cmovptr\n    // check if current entry is for same object\n    __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));\n    // if same object then stop searching\n    __ jccb(Assembler::equal, exit);\n    // otherwise advance to next entry\n    __ addptr(rtop, entry_size);\n    __ bind(entry);\n    // check if bottom reached\n    __ cmpptr(rtop, rbot);\n    // if not at bottom then check this entry\n    __ jcc(Assembler::notEqual, loop);\n    __ bind(exit);\n  }\n\n  __ testptr(rmon, rmon); // check if a slot has been found\n  __ jcc(Assembler::notZero, allocated); // if found, continue with that one\n\n  // allocate one if there's no free slot\n  {\n    Label entry, loop;\n    // 1. compute new pointers          // rsp: old expression stack top\n    __ movptr(rmon, monitor_block_bot); // rmon: old expression stack bottom\n    __ subptr(rsp, entry_size);         // move expression stack top\n    __ subptr(rmon, entry_size);        // move expression stack bottom\n    __ mov(rtop, rsp);                  // set start value for copy loop\n    __ movptr(monitor_block_bot, rmon); // set new monitor block bottom\n    __ jmp(entry);\n    // 2. move expression stack contents\n    __ bind(loop);\n    __ movptr(rbot, Address(rtop, entry_size)); // load expression stack\n                                                // word from old location\n    __ movptr(Address(rtop, 0), rbot);          // and store it at new location\n    __ addptr(rtop, wordSize);                  // advance to next word\n    __ bind(entry);\n    __ cmpptr(rtop, rmon);                      // check if bottom reached\n    __ jcc(Assembler::notEqual, loop);          // if not at bottom then\n                                                // copy next word\n  }\n\n  // call run-time routine\n  // rmon: points to monitor entry\n  __ bind(allocated);\n\n  // Increment bcp to point to the next bytecode, so exception\n  // handling for async. exceptions work correctly.\n  // The object has already been poped from the stack, so the\n  // expression stack looks correct.\n  __ increment(rbcp);\n\n  // store object\n  __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);\n  __ lock_object(rmon);\n\n  // check to make sure this monitor doesn't cause stack overflow after locking\n  __ save_bcp();  // in case of exception\n  __ generate_stack_overflow_check(0);\n\n  // The bcp has already been incremented. Just need to dispatch to\n  // next instruction.\n  __ dispatch_next(vtos);\n}\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br"),e("span",{staticClass:"line-number"},[n._v("90")]),e("br"),e("span",{staticClass:"line-number"},[n._v("91")]),e("br"),e("span",{staticClass:"line-number"},[n._v("92")]),e("br"),e("span",{staticClass:"line-number"},[n._v("93")]),e("br"),e("span",{staticClass:"line-number"},[n._v("94")]),e("br"),e("span",{staticClass:"line-number"},[n._v("95")]),e("br"),e("span",{staticClass:"line-number"},[n._v("96")]),e("br"),e("span",{staticClass:"line-number"},[n._v("97")]),e("br"),e("span",{staticClass:"line-number"},[n._v("98")]),e("br"),e("span",{staticClass:"line-number"},[n._v("99")]),e("br"),e("span",{staticClass:"line-number"},[n._v("100")]),e("br"),e("span",{staticClass:"line-number"},[n._v("101")]),e("br"),e("span",{staticClass:"line-number"},[n._v("102")]),e("br"),e("span",{staticClass:"line-number"},[n._v("103")]),e("br"),e("span",{staticClass:"line-number"},[n._v("104")]),e("br"),e("span",{staticClass:"line-number"},[n._v("105")]),e("br"),e("span",{staticClass:"line-number"},[n._v("106")]),e("br"),e("span",{staticClass:"line-number"},[n._v("107")]),e("br"),e("span",{staticClass:"line-number"},[n._v("108")]),e("br"),e("span",{staticClass:"line-number"},[n._v("109")]),e("br"),e("span",{staticClass:"line-number"},[n._v("110")]),e("br"),e("span",{staticClass:"line-number"},[n._v("111")]),e("br"),e("span",{staticClass:"line-number"},[n._v("112")]),e("br"),e("span",{staticClass:"line-number"},[n._v("113")]),e("br")])]),e("h3",{attrs:{id:"lock-object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lock-object"}},[n._v("#")]),n._v(" lock_object")]),n._v(" "),e("p",[n._v("BasicObjectLock包含两个字段，一个"),e("code",[n._v("BasicLock _lock")]),n._v("，一个"),e("code",[n._v("oop _obj")]),n._v("。\n_lock对象是内嵌到BasicObjectLock对象内存中的，BasicLock中目前只有一个markWord类型的_displaced_header字段。")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class BasicObjectLock {\n  friend class VMStructs;\n private:\n  BasicLock _lock;                                    // the lock, must be double word aligned\n  oop       _obj;                                     // object holds the lock;\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("p",[n._v("BasicLock类中有一个volatile生命的markWork类型的_displaced_header用于保存"),e("code",[n._v("_obj")]),n._v("之前的对象头（因为加锁会涉及到cas替换被加锁对象的对象头，加锁完成后需要恢复）")]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class BasicLock {\n  friend class VMStructs;\n  friend class JVMCIVMStructs;\n private:\n  volatile markWord _displaced_header;\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("ul",[e("li",[n._v("参数传过来的是BasicObjectLock的地址（在线程栈中）")]),n._v(" "),e("li",[n._v("UseHeavyMonitors是全局配置，默认false，会使用轻量级锁。")]),n._v(" "),e("li",[e("code",[n._v("orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));")]),n._v(": Load (object->mark() | 1) into swap_reg %rax，设置要cas的目标值，markWord的标记为设置为01，即")]),n._v(" "),e("li",[e("code",[n._v("movptr(Address(lock_reg, mark_offset), swap_reg);")]),n._v("：将锁对象的markWord保存到BasicLock的displaced header。")]),n._v(" "),e("li",[e("code",[n._v("cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()))")]),n._v(": cas替换锁对象的对象头为BasicLock地址。如果cas成功，则markWord的标记为会替换为00，表示轻量级加锁状态，因为BasicObjectLock的地址是以一个byte为单位的，后三位是000。")]),n._v(" "),e("li",[e("code",[n._v("jcc(Assembler::zero, done)")]),n._v("：如果cmpxchgptr成功，会设置结果为0，则直接走到done label完成了加锁。")]),n._v(" "),e("li",[e("code",[n._v("call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), lock_reg);")]),n._v("：否则调用"),e("code",[n._v("InterpreterRuntime::monitorenter")])])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// Lock object\n//\n// Args:\n//      rdx, c_rarg1: BasicObjectLock to be used for locking\n//\n// Kills:\n//      rax, rbx\nvoid InterpreterMacroAssembler::lock_object(Register lock_reg) {\n  assert(lock_reg == LP64_ONLY(c_rarg1) NOT_LP64(rdx),\n         "The argument is only for looks. It must be c_rarg1");\n\n  if (UseHeavyMonitors) {\n    call_VM(noreg,\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n            lock_reg);\n  } else {\n    Label done;\n\n    const Register swap_reg = rax; // Must use rax for cmpxchg instruction\n    const Register tmp_reg = rbx; // Will be passed to biased_locking_enter to avoid a\n                                  // problematic case where tmp_reg = no_reg.\n    const Register obj_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // Will contain the oop\n    const Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n\n    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n    const int mark_offset = lock_offset +\n                            BasicLock::displaced_header_offset_in_bytes();\n\n    Label slow_case;\n\n    // Load object pointer into obj_reg\n    movptr(obj_reg, Address(lock_reg, obj_offset));\n\n    if (DiagnoseSyncOnValueBasedClasses != 0) {\n      load_klass(tmp_reg, obj_reg, rklass_decode_tmp);\n      movl(tmp_reg, Address(tmp_reg, Klass::access_flags_offset()));\n      testl(tmp_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n      jcc(Assembler::notZero, slow_case);\n    }\n\n    if (UseBiasedLocking) {\n      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &amp;slow_case);\n    }\n\n    // Load immediate 1 into swap_reg %rax\n    movl(swap_reg, (int32_t)1);\n\n    // Load (object->mark() | 1) into swap_reg %rax\n    orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n\n    // Save (object->mark() | 1) into BasicLock\'s displaced header\n    movptr(Address(lock_reg, mark_offset), swap_reg);\n\n    assert(lock_offset == 0,\n           "displaced header must be first word in BasicObjectLock");\n\n    lock();\n    cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n    if (PrintBiasedLockingStatistics) {\n      cond_inc32(Assembler::zero,\n                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n    }\n    jcc(Assembler::zero, done);\n\n    const int zero_bits = LP64_ONLY(7) NOT_LP64(3);\n\n    subptr(swap_reg, rsp);\n    andptr(swap_reg, zero_bits - os::vm_page_size());\n\n    // Save the test result, for recursive case, the result is zero\n    movptr(Address(lock_reg, mark_offset), swap_reg);\n\n    if (PrintBiasedLockingStatistics) {\n      cond_inc32(Assembler::zero,\n                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n    }\n    jcc(Assembler::zero, done);\n\n    bind(slow_case);\n\n    // Call the runtime routine for slow case\n    call_VM(noreg,\n            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n            lock_reg);\n\n    bind(done);\n  }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br")])]),e("h3",{attrs:{id:"interpreter-runtime中的monitor-enter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#interpreter-runtime中的monitor-enter"}},[n._v("#")]),n._v(" interpreter runtime中的monitor enter")]),n._v(" "),e("p",[n._v("前面模版解释器中通过cas加轻量级锁失败后，说明加锁存在冲突，会回退到slow path。")]),n._v(" "),e("p",[n._v("主要是调用\n"),e("code",[n._v("ObjectSynchronizer::enter(h_obj, elem->lock(), current);")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//------------------------------------------------------------------------------------------------------------------------\n// Synchronization\n//\n// The interpreter\'s synchronization code is factored out so that it can\n// be shared by method invocation and synchronized blocks.\n//%note synchronization_3\n\n//%note monitor_1\nJRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, BasicObjectLock* elem))\n#ifdef ASSERT\n  current->last_frame().interpreter_frame_verify_monitor(elem);\n#endif\n  if (PrintBiasedLockingStatistics) {\n    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n  }\n  Handle h_obj(current, elem->obj());\n  assert(Universe::heap()->is_in_or_null(h_obj()),\n         "must be NULL or an object");\n  ObjectSynchronizer::enter(h_obj, elem->lock(), current);\n  assert(Universe::heap()->is_in_or_null(elem->obj()),\n         "must be NULL or an object");\n#ifdef ASSERT\n  current->last_frame().interpreter_frame_verify_monitor(elem);\n#endif\nJRT_END\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br")])]),e("p",[n._v("enter方法")]),n._v(" "),e("ul",[e("li",[n._v("先通过"),e("code",[n._v("markWord mark = obj->mark()")]),n._v("拿到markWord")]),n._v(" "),e("li",[n._v("先判断"),e("code",[n._v("mark.is_neutral()")]),n._v("：is_neutral判断markWord标记为是否是01即未加锁状态，则再通过cas尝试轻量级加锁，如果成功返回。不成功则走到后面的锁膨胀流程。")]),n._v(" "),e("li",[n._v("如果不是is_neutral，则判断"),e("code",[n._v("mark.has_locker()&& current->is_lock_owned((address)mark.locker())")]),n._v("：说明当前线程在前面已经加了这个对象的锁，直接返回。")]),n._v(" "),e("li",[n._v("进入锁膨胀再重量级加锁流程，在"),e("code",[n._v("while(true)")]),n._v("循环中不断尝试inflate进行锁膨胀，然后用膨胀后的重量级锁ObjectMonitor调用enter方法进行加锁。")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// -----------------------------------------------------------------------------\n// Monitor Enter/Exit\n// The interpreter and compiler assembly code tries to lock using the fast path\n// of this algorithm. Make sure to update that code if the following function is\n// changed. The implementation is extremely sensitive to race condition. Be careful.\n\nvoid ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n  if (obj->klass()->is_value_based()) {\n    handle_sync_on_value_based_class(obj, current);\n  }\n\n  if (UseBiasedLocking) {\n    BiasedLocking::revoke(current, obj);\n  }\n\n  markWord mark = obj->mark();\n  assert(!mark.has_bias_pattern(), "should not see bias pattern here");\n\n  if (mark.is_neutral()) {\n    // Anticipate successful CAS -- the ST of the displaced mark must\n    // be visible &lt;= the ST performed by the CAS.\n    lock->set_displaced_header(mark);\n    if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n      return;\n    }\n    // Fall through to inflate() ...\n  } else if (mark.has_locker() &amp;&amp;\n             current->is_lock_owned((address)mark.locker())) {\n    assert(lock != mark.locker(), "must not re-lock the same lock");\n    assert(lock != (BasicLock*)obj->mark().value(), "don\'t relock with same BasicLock");\n    lock->set_displaced_header(markWord::from_pointer(NULL));\n    return;\n  }\n\n  // The object header will never be displaced to this lock,\n  // so it does not matter what the value is, except that it\n  // must be non-zero to avoid looking like a re-entrant lock,\n  // and must not look locked either.\n  lock->set_displaced_header(markWord::unused_mark());\n  // An async deflation can race after the inflate() call and before\n  // enter() can make the ObjectMonitor busy. enter() returns false if\n  // we have lost the race to async deflation and we simply try again.\n  while (true) {\n    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n    if (monitor->enter(current)) {\n      return;\n    }\n  }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br")])]),e("h3",{attrs:{id:"锁膨胀inflation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁膨胀inflation"}},[n._v("#")]),n._v(" 锁膨胀inflation")]),n._v(" "),e("ul",[e("li",[n._v("判断mark如果已经是has_monitor说明有其他线程完成了所膨胀，直接从mark中获取monitor指针返回。")]),n._v(" "),e("li",[n._v("如果mark状态是INFLATING膨胀中（全是0），说明有其他线程在进行锁膨胀，则continue继续下一轮循环判断")]),n._v(" "),e("li",[n._v("如果mark状态是has_locker，说明有其他线程加了轻量级锁，则通过"),e("code",[n._v("object->cas_set_mark(markWord::INFLATING(), mark)")]),n._v("cas修改锁对象头设置状态为膨胀中\n"),e("ul",[e("li",[n._v("如果cas失败则continue继续循环")]),n._v(" "),e("li",[n._v("通过displaced_mark_helper方法获取锁对象原本的markWord，设置到ObjectMonitor中（ObjectMonitor对象在膨胀锁之前创建）。")]),n._v(" "),e("li",[n._v("设置ObjectMonitor的_owner、mark，然后返回")])])]),n._v(" "),e("li",[n._v("如果mark处于neutral状态，说明没有其他线程在加轻量级锁，则创建ObjectMonitor对象，然后cas修改锁对象头，成功返回。")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n                                           const InflateCause cause) {\n  EventJavaMonitorInflate event;\n\n  for (;;) {\n    const markWord mark = object->mark();\n    assert(!mark.has_bias_pattern(), "invariant");\n\n    // The mark can be in one of the following states:\n    // *  Inflated     - just return\n    // *  Stack-locked - coerce it to inflated\n    // *  INFLATING    - busy wait for conversion to complete\n    // *  Neutral      - aggressively inflate the object.\n    // *  BIASED       - Illegal.  We should never see this\n\n    // CASE: inflated\n    if (mark.has_monitor()) {\n      ObjectMonitor* inf = mark.monitor();\n      markWord dmw = inf->header();\n      assert(dmw.is_neutral(), "invariant: header=" INTPTR_FORMAT, dmw.value());\n      return inf;\n    }\n\n    // CASE: inflation in progress - inflating over a stack-lock.\n    // Some other thread is converting from stack-locked to inflated.\n    // Only that thread can complete inflation -- other threads must wait.\n    // The INFLATING value is transient.\n    // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.\n    // We could always eliminate polling by parking the thread on some auxiliary list.\n    if (mark == markWord::INFLATING()) {\n      read_stable_mark(object);\n      continue;\n    }\n\n    // CASE: stack-locked\n    // Could be stack-locked either by this thread or by some other thread.\n    //\n    // Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n    // to install INFLATING into the mark word.  We originally installed INFLATING,\n    // allocated the ObjectMonitor, and then finally STed the address of the\n    // ObjectMonitor into the mark.  This was correct, but artificially lengthened\n    // the interval in which INFLATING appeared in the mark, thus increasing\n    // the odds of inflation contention.\n\n    LogStreamHandle(Trace, monitorinflation) lsh;\n\n    if (mark.has_locker()) {\n      ObjectMonitor* m = new ObjectMonitor(object);\n      // Optimistically prepare the ObjectMonitor - anticipate successful CAS\n      // We do this before the CAS in order to minimize the length of time\n      // in which INFLATING appears in the mark.\n\n      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n      if (cmp != mark) {\n        delete m;\n        continue;       // Interference -- just retry\n      }\n\n      // We\'ve successfully installed INFLATING (0) into the mark-word.\n      // This is the only case where 0 will appear in a mark-word.\n      // Only the singular thread that successfully swings the mark-word\n      // to 0 can perform (or more precisely, complete) inflation.\n      //\n      // Why do we CAS a 0 into the mark-word instead of just CASing the\n      // mark-word from the stack-locked value directly to the new inflated state?\n      // Consider what happens when a thread unlocks a stack-locked object.\n      // It attempts to use CAS to swing the displaced header value from the\n      // on-stack BasicLock back into the object header.  Recall also that the\n      // header value (hash code, etc) can reside in (a) the object header, or\n      // (b) a displaced header associated with the stack-lock, or (c) a displaced\n      // header in an ObjectMonitor.  The inflate() routine must copy the header\n      // value from the BasicLock on the owner\'s stack to the ObjectMonitor, all\n      // the while preserving the hashCode stability invariants.  If the owner\n      // decides to release the lock while the value is 0, the unlock will fail\n      // and control will eventually pass from slow_exit() to inflate.  The owner\n      // will then spin, waiting for the 0 value to disappear.   Put another way,\n      // the 0 causes the owner to stall if the owner happens to try to\n      // drop the lock (restoring the header from the BasicLock to the object)\n      // while inflation is in-progress.  This protocol avoids races that might\n      // would otherwise permit hashCode values to change or "flicker" for an object.\n      // Critically, while object->mark is 0 mark.displaced_mark_helper() is stable.\n      // 0 serves as a "BUSY" inflate-in-progress indicator.\n\n\n      // fetch the displaced mark from the owner\'s stack.\n      // The owner can\'t die or unwind past the lock while our INFLATING\n      // object is in the mark.  Furthermore the owner can\'t complete\n      // an unlock on the object, either.\n      markWord dmw = mark.displaced_mark_helper();\n      // Catch if the object\'s header is not neutral (not locked and\n      // not marked is what we care about here).\n      assert(dmw.is_neutral(), "invariant: header=" INTPTR_FORMAT, dmw.value());\n\n      // Setup monitor fields to proper values -- prepare the monitor\n      m->set_header(dmw);\n\n      // Optimization: if the mark.locker stack address is associated\n      // with this thread we could simply set m->_owner = current.\n      // Note that a thread can inflate an object\n      // that it has stack-locked -- as might happen in wait() -- directly\n      // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.\n      m->set_owner_from(NULL, mark.locker());\n      // TODO-FIXME: assert BasicLock->dhw != 0.\n\n      // Must preserve store ordering. The monitor state must\n      // be stable at the time of publishing the monitor address.\n      guarantee(object->mark() == markWord::INFLATING(), "invariant");\n      // Release semantics so that above set_object() is seen first.\n      object->release_set_mark(markWord::encode(m));\n\n      // Once ObjectMonitor is configured and the object is associated\n      // with the ObjectMonitor, it is safe to allow async deflation:\n      _in_use_list.add(m);\n\n      // Hopefully the performance counters are allocated on distinct cache lines\n      // to avoid false sharing on MP systems ...\n      OM_PERFDATA_OP(Inflations, inc());\n      if (log_is_enabled(Trace, monitorinflation)) {\n        ResourceMark rm(current);\n        lsh.print_cr("inflate(has_locker): object=" INTPTR_FORMAT ", mark="\n                     INTPTR_FORMAT ", type=\'%s\'", p2i(object),\n                     object->mark().value(), object->klass()->external_name());\n      }\n      if (event.should_commit()) {\n        post_monitor_inflate_event(&amp;event, object, cause);\n      }\n      return m;\n    }\n\n    // CASE: neutral\n    // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n    // If we know we\'re inflating for entry it\'s better to inflate by swinging a\n    // pre-locked ObjectMonitor pointer into the object header.   A successful\n    // CAS inflates the object *and* confers ownership to the inflating thread.\n    // In the current implementation we use a 2-step mechanism where we CAS()\n    // to inflate and then CAS() again to try to swing _owner from NULL to current.\n    // An inflateTry() method that we could call from enter() would be useful.\n\n    // Catch if the object\'s header is not neutral (not locked and\n    // not marked is what we care about here).\n    assert(mark.is_neutral(), "invariant: header=" INTPTR_FORMAT, mark.value());\n    ObjectMonitor* m = new ObjectMonitor(object);\n    // prepare m for installation - set monitor to initial state\n    m->set_header(mark);\n\n    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n      delete m;\n      m = NULL;\n      continue;\n      // interference - the markword changed - just retry.\n      // The state-transitions are one-way, so there\'s no chance of\n      // live-lock -- "Inflated" is an absorbing state.\n    }\n\n    // Once the ObjectMonitor is configured and object is associated\n    // with the ObjectMonitor, it is safe to allow async deflation:\n    _in_use_list.add(m);\n\n    // Hopefully the performance counters are allocated on distinct\n    // cache lines to avoid false sharing on MP systems ...\n    OM_PERFDATA_OP(Inflations, inc());\n    if (log_is_enabled(Trace, monitorinflation)) {\n      ResourceMark rm(current);\n      lsh.print_cr("inflate(neutral): object=" INTPTR_FORMAT ", mark="\n                   INTPTR_FORMAT ", type=\'%s\'", p2i(object),\n                   object->mark().value(), object->klass()->external_name());\n    }\n    if (event.should_commit()) {\n      post_monitor_inflate_event(&amp;event, object, cause);\n    }\n    return m;\n  }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br"),e("span",{staticClass:"line-number"},[n._v("90")]),e("br"),e("span",{staticClass:"line-number"},[n._v("91")]),e("br"),e("span",{staticClass:"line-number"},[n._v("92")]),e("br"),e("span",{staticClass:"line-number"},[n._v("93")]),e("br"),e("span",{staticClass:"line-number"},[n._v("94")]),e("br"),e("span",{staticClass:"line-number"},[n._v("95")]),e("br"),e("span",{staticClass:"line-number"},[n._v("96")]),e("br"),e("span",{staticClass:"line-number"},[n._v("97")]),e("br"),e("span",{staticClass:"line-number"},[n._v("98")]),e("br"),e("span",{staticClass:"line-number"},[n._v("99")]),e("br"),e("span",{staticClass:"line-number"},[n._v("100")]),e("br"),e("span",{staticClass:"line-number"},[n._v("101")]),e("br"),e("span",{staticClass:"line-number"},[n._v("102")]),e("br"),e("span",{staticClass:"line-number"},[n._v("103")]),e("br"),e("span",{staticClass:"line-number"},[n._v("104")]),e("br"),e("span",{staticClass:"line-number"},[n._v("105")]),e("br"),e("span",{staticClass:"line-number"},[n._v("106")]),e("br"),e("span",{staticClass:"line-number"},[n._v("107")]),e("br"),e("span",{staticClass:"line-number"},[n._v("108")]),e("br"),e("span",{staticClass:"line-number"},[n._v("109")]),e("br"),e("span",{staticClass:"line-number"},[n._v("110")]),e("br"),e("span",{staticClass:"line-number"},[n._v("111")]),e("br"),e("span",{staticClass:"line-number"},[n._v("112")]),e("br"),e("span",{staticClass:"line-number"},[n._v("113")]),e("br"),e("span",{staticClass:"line-number"},[n._v("114")]),e("br"),e("span",{staticClass:"line-number"},[n._v("115")]),e("br"),e("span",{staticClass:"line-number"},[n._v("116")]),e("br"),e("span",{staticClass:"line-number"},[n._v("117")]),e("br"),e("span",{staticClass:"line-number"},[n._v("118")]),e("br"),e("span",{staticClass:"line-number"},[n._v("119")]),e("br"),e("span",{staticClass:"line-number"},[n._v("120")]),e("br"),e("span",{staticClass:"line-number"},[n._v("121")]),e("br"),e("span",{staticClass:"line-number"},[n._v("122")]),e("br"),e("span",{staticClass:"line-number"},[n._v("123")]),e("br"),e("span",{staticClass:"line-number"},[n._v("124")]),e("br"),e("span",{staticClass:"line-number"},[n._v("125")]),e("br"),e("span",{staticClass:"line-number"},[n._v("126")]),e("br"),e("span",{staticClass:"line-number"},[n._v("127")]),e("br"),e("span",{staticClass:"line-number"},[n._v("128")]),e("br"),e("span",{staticClass:"line-number"},[n._v("129")]),e("br"),e("span",{staticClass:"line-number"},[n._v("130")]),e("br"),e("span",{staticClass:"line-number"},[n._v("131")]),e("br"),e("span",{staticClass:"line-number"},[n._v("132")]),e("br"),e("span",{staticClass:"line-number"},[n._v("133")]),e("br"),e("span",{staticClass:"line-number"},[n._v("134")]),e("br"),e("span",{staticClass:"line-number"},[n._v("135")]),e("br"),e("span",{staticClass:"line-number"},[n._v("136")]),e("br"),e("span",{staticClass:"line-number"},[n._v("137")]),e("br"),e("span",{staticClass:"line-number"},[n._v("138")]),e("br"),e("span",{staticClass:"line-number"},[n._v("139")]),e("br"),e("span",{staticClass:"line-number"},[n._v("140")]),e("br"),e("span",{staticClass:"line-number"},[n._v("141")]),e("br"),e("span",{staticClass:"line-number"},[n._v("142")]),e("br"),e("span",{staticClass:"line-number"},[n._v("143")]),e("br"),e("span",{staticClass:"line-number"},[n._v("144")]),e("br"),e("span",{staticClass:"line-number"},[n._v("145")]),e("br"),e("span",{staticClass:"line-number"},[n._v("146")]),e("br"),e("span",{staticClass:"line-number"},[n._v("147")]),e("br"),e("span",{staticClass:"line-number"},[n._v("148")]),e("br"),e("span",{staticClass:"line-number"},[n._v("149")]),e("br"),e("span",{staticClass:"line-number"},[n._v("150")]),e("br"),e("span",{staticClass:"line-number"},[n._v("151")]),e("br"),e("span",{staticClass:"line-number"},[n._v("152")]),e("br"),e("span",{staticClass:"line-number"},[n._v("153")]),e("br"),e("span",{staticClass:"line-number"},[n._v("154")]),e("br"),e("span",{staticClass:"line-number"},[n._v("155")]),e("br"),e("span",{staticClass:"line-number"},[n._v("156")]),e("br"),e("span",{staticClass:"line-number"},[n._v("157")]),e("br"),e("span",{staticClass:"line-number"},[n._v("158")]),e("br"),e("span",{staticClass:"line-number"},[n._v("159")]),e("br"),e("span",{staticClass:"line-number"},[n._v("160")]),e("br"),e("span",{staticClass:"line-number"},[n._v("161")]),e("br"),e("span",{staticClass:"line-number"},[n._v("162")]),e("br"),e("span",{staticClass:"line-number"},[n._v("163")]),e("br"),e("span",{staticClass:"line-number"},[n._v("164")]),e("br"),e("span",{staticClass:"line-number"},[n._v("165")]),e("br"),e("span",{staticClass:"line-number"},[n._v("166")]),e("br"),e("span",{staticClass:"line-number"},[n._v("167")]),e("br"),e("span",{staticClass:"line-number"},[n._v("168")]),e("br"),e("span",{staticClass:"line-number"},[n._v("169")]),e("br"),e("span",{staticClass:"line-number"},[n._v("170")]),e("br"),e("span",{staticClass:"line-number"},[n._v("171")]),e("br"),e("span",{staticClass:"line-number"},[n._v("172")]),e("br"),e("span",{staticClass:"line-number"},[n._v("173")]),e("br")])]),e("h3",{attrs:{id:"重量级锁的enter加锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁的enter加锁"}},[n._v("#")]),n._v(" 重量级锁的enter加锁")]),n._v(" "),e("ul",[e("li",[n._v("通过cas修改ObjectMonitor的_owner，从null cas到当前线程，如果cas成功说明重量级锁加锁成功，返回。")]),n._v(" "),e("li",[n._v("判断锁重入情况，如果重入（锁的owner和当前线程想通）则增加_recursions并返回成功")]),n._v(" "),e("li",[n._v("如果当前线程已经轻量级加锁，说明当前线程在轻量级锁加锁完成后再对相同锁对象加锁，此时被其他线程完成了锁膨胀，所以会将owner从BasicLock设置为当前线程，并设置recursion为1表示第一次重入，并返回")]),n._v(" "),e("li",[n._v("TrySpin，TrySpin是cas设置owner，会经过多次自适应自旋，如果TrySpin成功说明加锁成功也会返回")]),n._v(" "),e("li",[e("code",[n._v("for(;;)")]),n._v("中不断尝试加锁\n"),e("ul",[e("li",[e("code",[n._v("ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos)")]),n._v(": 创建一个ThreadBlockInVMPreprocess对象，在方法块结束前析构方法会检查是否处于safepoint过程中，如果是则会等待safepoint完成再返回。")]),n._v(" "),e("li",[e("code",[n._v("EnterI")]),n._v("：是重量级锁的入队、park阻塞实现")])])])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// -----------------------------------------------------------------------------\n// Enter support\n\nbool ObjectMonitor::enter(JavaThread* current) {\n  // The following code is ordered to check the most common cases first\n  // and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n\n  void* cur = try_set_owner_from(NULL, current);\n  if (cur == NULL) {\n    assert(_recursions == 0, "invariant");\n    return true;\n  }\n\n  if (cur == current) {\n    // TODO-FIXME: check for integer overflow!  BUGID 6557169.\n    _recursions++;\n    return true;\n  }\n\n  if (current->is_lock_owned((address)cur)) {\n    assert(_recursions == 0, "internal state error");\n    _recursions = 1;\n    set_owner_from_BasicLock(cur, current);  // Convert from BasicLock* to Thread*.\n    return true;\n  }\n\n  // We\'ve encountered genuine contention.\n  assert(current->_Stalled == 0, "invariant");\n  current->_Stalled = intptr_t(this);\n\n  // Try one round of spinning *before* enqueueing current\n  // and before going through the awkward and expensive state\n  // transitions.  The following spin is strictly optional ...\n  // Note that if we acquire the monitor from an initial spin\n  // we forgo posting JVMTI events and firing DTRACE probes.\n  if (TrySpin(current) > 0) {\n    assert(owner_raw() == current, "must be current: owner=" INTPTR_FORMAT, p2i(owner_raw()));\n    assert(_recursions == 0, "must be 0: recursions=" INTX_FORMAT, _recursions);\n    assert(object()->mark() == markWord::encode(this),\n           "object mark must match encoded this: mark=" INTPTR_FORMAT\n           ", encoded this=" INTPTR_FORMAT, object()->mark().value(),\n           markWord::encode(this).value());\n    current->_Stalled = 0;\n    return true;\n  }\n\n  assert(owner_raw() != current, "invariant");\n  assert(_succ != current, "invariant");\n  assert(!SafepointSynchronize::is_at_safepoint(), "invariant");\n  assert(current->thread_state() != _thread_blocked, "invariant");\n\n  // Keep track of contention for JVM/TI and M&amp;M queries.\n  add_to_contentions(1);\n  if (is_being_async_deflated()) {\n    // Async deflation is in progress and our contentions increment\n    // above lost the race to async deflation. Undo the work and\n    // force the caller to retry.\n    const oop l_object = object();\n    if (l_object != NULL) {\n      // Attempt to restore the header/dmw to the object\'s header so that\n      // we only retry once if the deflater thread happens to be slow.\n      install_displaced_markword_in_object(l_object);\n    }\n    current->_Stalled = 0;\n    add_to_contentions(-1);\n    return false;\n  }\n\n  { // Change java thread status to indicate blocked on monitor enter.\n    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n\n    assert(current->current_pending_monitor() == NULL, "invariant");\n    current->set_current_pending_monitor(this);\n\n    DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n    if (JvmtiExport::should_post_monitor_contended_enter()) {\n      JvmtiExport::post_monitor_contended_enter(current, this);\n\n      // The current thread does not yet own the monitor and does not\n      // yet appear on any queues that would get it made the successor.\n      // This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event\n      // handler cannot accidentally consume an unpark() meant for the\n      // ParkEvent associated with this ObjectMonitor.\n    }\n\n    OSThreadContendState osts(current->osthread());\n\n    assert(current->thread_state() == _thread_in_vm, "invariant");\n\n    for (;;) {\n      ExitOnSuspend eos(this);\n      {\n        ThreadBlockInVMPreprocess&lt;ExitOnSuspend> tbivs(current, eos);\n        EnterI(current);\n        current->set_current_pending_monitor(NULL);\n        // We can go to a safepoint at the end of this block. If we\n        // do a thread dump during that safepoint, then this thread will show\n        // as having "-locked" the monitor, but the OS and java.lang.Thread\n        // states will still report that the thread is blocked trying to\n        // acquire it.\n        // If there is a suspend request, ExitOnSuspend will exit the OM\n        // and set the OM as pending.\n      }\n      if (!eos.exited()) {\n        // ExitOnSuspend did not exit the OM\n        assert(owner_raw() == current, "invariant");\n        break;\n      }\n    }\n\n    // We\'ve just gotten past the enter-check-for-suspend dance and we now own\n    // the monitor free and clear.\n  }\n\n  add_to_contentions(-1);\n  assert(contentions() >= 0, "must not be negative: contentions=%d", contentions());\n  current->_Stalled = 0;\n\n  // Must either set _recursions = 0 or ASSERT _recursions == 0.\n  assert(_recursions == 0, "invariant");\n  assert(owner_raw() == current, "invariant");\n  assert(_succ != current, "invariant");\n  assert(object()->mark() == markWord::encode(this), "invariant");\n\n  return true;\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br"),e("span",{staticClass:"line-number"},[n._v("90")]),e("br"),e("span",{staticClass:"line-number"},[n._v("91")]),e("br"),e("span",{staticClass:"line-number"},[n._v("92")]),e("br"),e("span",{staticClass:"line-number"},[n._v("93")]),e("br"),e("span",{staticClass:"line-number"},[n._v("94")]),e("br"),e("span",{staticClass:"line-number"},[n._v("95")]),e("br"),e("span",{staticClass:"line-number"},[n._v("96")]),e("br"),e("span",{staticClass:"line-number"},[n._v("97")]),e("br"),e("span",{staticClass:"line-number"},[n._v("98")]),e("br"),e("span",{staticClass:"line-number"},[n._v("99")]),e("br"),e("span",{staticClass:"line-number"},[n._v("100")]),e("br"),e("span",{staticClass:"line-number"},[n._v("101")]),e("br"),e("span",{staticClass:"line-number"},[n._v("102")]),e("br"),e("span",{staticClass:"line-number"},[n._v("103")]),e("br"),e("span",{staticClass:"line-number"},[n._v("104")]),e("br"),e("span",{staticClass:"line-number"},[n._v("105")]),e("br"),e("span",{staticClass:"line-number"},[n._v("106")]),e("br"),e("span",{staticClass:"line-number"},[n._v("107")]),e("br"),e("span",{staticClass:"line-number"},[n._v("108")]),e("br"),e("span",{staticClass:"line-number"},[n._v("109")]),e("br"),e("span",{staticClass:"line-number"},[n._v("110")]),e("br"),e("span",{staticClass:"line-number"},[n._v("111")]),e("br"),e("span",{staticClass:"line-number"},[n._v("112")]),e("br"),e("span",{staticClass:"line-number"},[n._v("113")]),e("br"),e("span",{staticClass:"line-number"},[n._v("114")]),e("br"),e("span",{staticClass:"line-number"},[n._v("115")]),e("br"),e("span",{staticClass:"line-number"},[n._v("116")]),e("br"),e("span",{staticClass:"line-number"},[n._v("117")]),e("br"),e("span",{staticClass:"line-number"},[n._v("118")]),e("br"),e("span",{staticClass:"line-number"},[n._v("119")]),e("br"),e("span",{staticClass:"line-number"},[n._v("120")]),e("br"),e("span",{staticClass:"line-number"},[n._v("121")]),e("br"),e("span",{staticClass:"line-number"},[n._v("122")]),e("br"),e("span",{staticClass:"line-number"},[n._v("123")]),e("br"),e("span",{staticClass:"line-number"},[n._v("124")]),e("br"),e("span",{staticClass:"line-number"},[n._v("125")]),e("br"),e("span",{staticClass:"line-number"},[n._v("126")]),e("br")])]),e("h4",{attrs:{id:"enteri"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#enteri"}},[n._v("#")]),n._v(" EnterI")]),n._v(" "),e("ul",[e("li",[n._v("再尝试TryLock，包含在后面的步骤中还会穿插尝试TryLock")]),n._v(" "),e("li",[n._v("创建ObjectWaiter等待节点，然后通过cas设置为新的_cxq头节点，cas成功完成入队。")]),n._v(" "),e("li",[n._v("如果ObjectWaiter的next为NULL并且_EntryList也是NULL，需要将自己设置成_Responsible，当前这种情况，已经持有锁的线程在释放锁时可能走快速锁释放流程导致等待锁的线程不能被唤醒，所以_Responsible会定期检查锁状态，即park阻塞会设置超时时间不断检查。")]),n._v(" "),e("li",[n._v("入队完成后，for循环内不断\n"),e("ul",[e("li",[n._v("TryLock尝试加锁")]),n._v(" "),e("li",[n._v("加锁不成功"),e("code",[n._v("current->_ParkEvent->park()")]),n._v("，阻塞即挂起当前线程，内核可以调度运行其他线程。park恢复后（可能是锁释放了），会继续尝试加锁。")])])])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('void ObjectMonitor::EnterI(JavaThread* current) {\n  assert(current->thread_state() == _thread_blocked, "invariant");\n\n  // Try the lock - TATAS\n  if (TryLock (current) > 0) {\n    assert(_succ != current, "invariant");\n    assert(owner_raw() == current, "invariant");\n    assert(_Responsible != current, "invariant");\n    return;\n  }\n\n  if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n    // Cancelled the in-progress async deflation by changing owner from\n    // DEFLATER_MARKER to current. As part of the contended enter protocol,\n    // contentions was incremented to a positive value before EnterI()\n    // was called and that prevents the deflater thread from winning the\n    // last part of the 2-part async deflation protocol. After EnterI()\n    // returns to enter(), contentions is decremented because the caller\n    // now owns the monitor. We bump contentions an extra time here to\n    // prevent the deflater thread from winning the last part of the\n    // 2-part async deflation protocol after the regular decrement\n    // occurs in enter(). The deflater thread will decrement contentions\n    // after it recognizes that the async deflation was cancelled.\n    add_to_contentions(1);\n    assert(_succ != current, "invariant");\n    assert(_Responsible != current, "invariant");\n    return;\n  }\n\n  assert(InitDone, "Unexpectedly not initialized");\n\n  // We try one round of spinning *before* enqueueing current.\n  //\n  // If the _owner is ready but OFFPROC we could use a YieldTo()\n  // operation to donate the remainder of this thread\'s quantum\n  // to the owner.  This has subtle but beneficial affinity\n  // effects.\n\n  if (TrySpin(current) > 0) {\n    assert(owner_raw() == current, "invariant");\n    assert(_succ != current, "invariant");\n    assert(_Responsible != current, "invariant");\n    return;\n  }\n\n  // The Spin failed -- Enqueue and park the thread ...\n  assert(_succ != current, "invariant");\n  assert(owner_raw() != current, "invariant");\n  assert(_Responsible != current, "invariant");\n\n  // Enqueue "current" on ObjectMonitor\'s _cxq.\n  //\n  // Node acts as a proxy for current.\n  // As an aside, if were to ever rewrite the synchronization code mostly\n  // in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class\n  // Java objects.  This would avoid awkward lifecycle and liveness issues,\n  // as well as eliminate a subset of ABA issues.\n  // TODO: eliminate ObjectWaiter and enqueue either Threads or Events.\n\n  ObjectWaiter node(current);\n  current->_ParkEvent->reset();\n  node._prev   = (ObjectWaiter*) 0xBAD;\n  node.TState  = ObjectWaiter::TS_CXQ;\n\n  // Push "current" onto the front of the _cxq.\n  // Once on cxq/EntryList, current stays on-queue until it acquires the lock.\n  // Note that spinning tends to reduce the rate at which threads\n  // enqueue and dequeue on EntryList|cxq.\n  ObjectWaiter* nxt;\n  for (;;) {\n    node._next = nxt = _cxq;\n    if (Atomic::cmpxchg(&amp;_cxq, nxt, &amp;node) == nxt) break;\n\n    // Interference - the CAS failed because _cxq changed.  Just retry.\n    // As an optional optimization we retry the lock.\n    if (TryLock (current) > 0) {\n      assert(_succ != current, "invariant");\n      assert(owner_raw() == current, "invariant");\n      assert(_Responsible != current, "invariant");\n      return;\n    }\n  }\n\n  // Check for cxq|EntryList edge transition to non-null.  This indicates\n  // the onset of contention.  While contention persists exiting threads\n  // will use a ST:MEMBAR:LD 1-1 exit protocol.  When contention abates exit\n  // operations revert to the faster 1-0 mode.  This enter operation may interleave\n  // (race) a concurrent 1-0 exit operation, resulting in stranding, so we\n  // arrange for one of the contending thread to use a timed park() operations\n  // to detect and recover from the race.  (Stranding is form of progress failure\n  // where the monitor is unlocked but all the contending threads remain parked).\n  // That is, at least one of the contended threads will periodically poll _owner.\n  // One of the contending threads will become the designated "Responsible" thread.\n  // The Responsible thread uses a timed park instead of a normal indefinite park\n  // operation -- it periodically wakes and checks for and recovers from potential\n  // strandings admitted by 1-0 exit operations.   We need at most one Responsible\n  // thread per-monitor at any given moment.  Only threads on cxq|EntryList may\n  // be responsible for a monitor.\n  //\n  // Currently, one of the contended threads takes on the added role of "Responsible".\n  // A viable alternative would be to use a dedicated "stranding checker" thread\n  // that periodically iterated over all the threads (or active monitors) and unparked\n  // successors where there was risk of stranding.  This would help eliminate the\n  // timer scalability issues we see on some platforms as we\'d only have one thread\n  // -- the checker -- parked on a timer.\n\n  if (nxt == NULL &amp;&amp; _EntryList == NULL) {\n    // Try to assume the role of responsible thread for the monitor.\n    // CONSIDER:  ST vs CAS vs { if (Responsible==null) Responsible=current }\n    Atomic::replace_if_null(&amp;_Responsible, current);\n  }\n\n  // The lock might have been released while this thread was occupied queueing\n  // itself onto _cxq.  To close the race and avoid "stranding" and\n  // progress-liveness failure we must resample-retry _owner before parking.\n  // Note the Dekker/Lamport duality: ST cxq; MEMBAR; LD Owner.\n  // In this case the ST-MEMBAR is accomplished with CAS().\n  //\n  // TODO: Defer all thread state transitions until park-time.\n  // Since state transitions are heavy and inefficient we\'d like\n  // to defer the state transitions until absolutely necessary,\n  // and in doing so avoid some transitions ...\n\n  int nWakeups = 0;\n  int recheckInterval = 1;\n\n  for (;;) {\n\n    if (TryLock(current) > 0) break;\n    assert(owner_raw() != current, "invariant");\n\n    // park self\n    if (_Responsible == current) {\n      current->_ParkEvent->park((jlong) recheckInterval);\n      // Increase the recheckInterval, but clamp the value.\n      recheckInterval *= 8;\n      if (recheckInterval > MAX_RECHECK_INTERVAL) {\n        recheckInterval = MAX_RECHECK_INTERVAL;\n      }\n    } else {\n      current->_ParkEvent->park();\n    }\n\n    if (TryLock(current) > 0) break;\n\n    if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n      // Cancelled the in-progress async deflation by changing owner from\n      // DEFLATER_MARKER to current. As part of the contended enter protocol,\n      // contentions was incremented to a positive value before EnterI()\n      // was called and that prevents the deflater thread from winning the\n      // last part of the 2-part async deflation protocol. After EnterI()\n      // returns to enter(), contentions is decremented because the caller\n      // now owns the monitor. We bump contentions an extra time here to\n      // prevent the deflater thread from winning the last part of the\n      // 2-part async deflation protocol after the regular decrement\n      // occurs in enter(). The deflater thread will decrement contentions\n      // after it recognizes that the async deflation was cancelled.\n      add_to_contentions(1);\n      break;\n    }\n\n    // The lock is still contested.\n    // Keep a tally of the # of futile wakeups.\n    // Note that the counter is not protected by a lock or updated by atomics.\n    // That is by design - we trade "lossy" counters which are exposed to\n    // races during updates for a lower probe effect.\n\n    // This PerfData object can be used in parallel with a safepoint.\n    // See the work around in PerfDataManager::destroy().\n    OM_PERFDATA_OP(FutileWakeups, inc());\n    ++nWakeups;\n\n    // Assuming this is not a spurious wakeup we\'ll normally find _succ == current.\n    // We can defer clearing _succ until after the spin completes\n    // TrySpin() must tolerate being called with _succ == current.\n    // Try yet another round of adaptive spinning.\n    if (TrySpin(current) > 0) break;\n\n    // We can find that we were unpark()ed and redesignated _succ while\n    // we were spinning.  That\'s harmless.  If we iterate and call park(),\n    // park() will consume the event and return immediately and we\'ll\n    // just spin again.  This pattern can repeat, leaving _succ to simply\n    // spin on a CPU.\n\n    if (_succ == current) _succ = NULL;\n\n    // Invariant: after clearing _succ a thread *must* retry _owner before parking.\n    OrderAccess::fence();\n  }\n\n  // Egress :\n  // current has acquired the lock -- Unlink current from the cxq or EntryList.\n  // Normally we\'ll find current on the EntryList .\n  // From the perspective of the lock owner (this thread), the\n  // EntryList is stable and cxq is prepend-only.\n  // The head of cxq is volatile but the interior is stable.\n  // In addition, current.TState is stable.\n\n  assert(owner_raw() == current, "invariant");\n\n  UnlinkAfterAcquire(current, &amp;node);\n  if (_succ == current) _succ = NULL;\n\n  assert(_succ != current, "invariant");\n  if (_Responsible == current) {\n    _Responsible = NULL;\n    OrderAccess::fence(); // Dekker pivot-point\n\n    // We may leave threads on cxq|EntryList without a designated\n    // "Responsible" thread.  This is benign.  When this thread subsequently\n    // exits the monitor it can "see" such preexisting "old" threads --\n    // threads that arrived on the cxq|EntryList before the fence, above --\n    // by LDing cxq|EntryList.  Newly arrived threads -- that is, threads\n    // that arrive on cxq after the ST:MEMBAR, above -- will set Responsible\n    // non-null and elect a new "Responsible" timer thread.\n    //\n    // This thread executes:\n    //    ST Responsible=null; MEMBAR    (in enter epilogue - here)\n    //    LD cxq|EntryList               (in subsequent exit)\n    //\n    // Entering threads in the slow/contended path execute:\n    //    ST cxq=nonnull; MEMBAR; LD Responsible (in enter prolog)\n    //    The (ST cxq; MEMBAR) is accomplished with CAS().\n    //\n    // The MEMBAR, above, prevents the LD of cxq|EntryList in the subsequent\n    // exit operation from floating above the ST Responsible=null.\n  }\n\n  // We\'ve acquired ownership with CAS().\n  // CAS is serializing -- it has MEMBAR/FENCE-equivalent semantics.\n  // But since the CAS() this thread may have also stored into _succ,\n  // EntryList, cxq or Responsible.  These meta-data updates must be\n  // visible __before this thread subsequently drops the lock.\n  // Consider what could occur if we didn\'t enforce this constraint --\n  // STs to monitor meta-data and user-data could reorder with (become\n  // visible after) the ST in exit that drops ownership of the lock.\n  // Some other thread could then acquire the lock, but observe inconsistent\n  // or old monitor meta-data and heap data.  That violates the JMM.\n  // To that end, the 1-0 exit() operation must have at least STST|LDST\n  // "release" barrier semantics.  Specifically, there must be at least a\n  // STST|LDST barrier in exit() before the ST of null into _owner that drops\n  // the lock.   The barrier ensures that changes to monitor meta-data and data\n  // protected by the lock will be visible before we release the lock, and\n  // therefore before some other thread (CPU) has a chance to acquire the lock.\n  // See also: http://gee.cs.oswego.edu/dl/jmm/cookbook.html.\n  //\n  // Critically, any prior STs to _succ or EntryList must be visible before\n  // the ST of null into _owner in the *subsequent* (following) corresponding\n  // monitorexit.  Recall too, that in 1-0 mode monitorexit does not necessarily\n  // execute a serializing instruction.\n\n  return;\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br"),e("span",{staticClass:"line-number"},[n._v("90")]),e("br"),e("span",{staticClass:"line-number"},[n._v("91")]),e("br"),e("span",{staticClass:"line-number"},[n._v("92")]),e("br"),e("span",{staticClass:"line-number"},[n._v("93")]),e("br"),e("span",{staticClass:"line-number"},[n._v("94")]),e("br"),e("span",{staticClass:"line-number"},[n._v("95")]),e("br"),e("span",{staticClass:"line-number"},[n._v("96")]),e("br"),e("span",{staticClass:"line-number"},[n._v("97")]),e("br"),e("span",{staticClass:"line-number"},[n._v("98")]),e("br"),e("span",{staticClass:"line-number"},[n._v("99")]),e("br"),e("span",{staticClass:"line-number"},[n._v("100")]),e("br"),e("span",{staticClass:"line-number"},[n._v("101")]),e("br"),e("span",{staticClass:"line-number"},[n._v("102")]),e("br"),e("span",{staticClass:"line-number"},[n._v("103")]),e("br"),e("span",{staticClass:"line-number"},[n._v("104")]),e("br"),e("span",{staticClass:"line-number"},[n._v("105")]),e("br"),e("span",{staticClass:"line-number"},[n._v("106")]),e("br"),e("span",{staticClass:"line-number"},[n._v("107")]),e("br"),e("span",{staticClass:"line-number"},[n._v("108")]),e("br"),e("span",{staticClass:"line-number"},[n._v("109")]),e("br"),e("span",{staticClass:"line-number"},[n._v("110")]),e("br"),e("span",{staticClass:"line-number"},[n._v("111")]),e("br"),e("span",{staticClass:"line-number"},[n._v("112")]),e("br"),e("span",{staticClass:"line-number"},[n._v("113")]),e("br"),e("span",{staticClass:"line-number"},[n._v("114")]),e("br"),e("span",{staticClass:"line-number"},[n._v("115")]),e("br"),e("span",{staticClass:"line-number"},[n._v("116")]),e("br"),e("span",{staticClass:"line-number"},[n._v("117")]),e("br"),e("span",{staticClass:"line-number"},[n._v("118")]),e("br"),e("span",{staticClass:"line-number"},[n._v("119")]),e("br"),e("span",{staticClass:"line-number"},[n._v("120")]),e("br"),e("span",{staticClass:"line-number"},[n._v("121")]),e("br"),e("span",{staticClass:"line-number"},[n._v("122")]),e("br"),e("span",{staticClass:"line-number"},[n._v("123")]),e("br"),e("span",{staticClass:"line-number"},[n._v("124")]),e("br"),e("span",{staticClass:"line-number"},[n._v("125")]),e("br"),e("span",{staticClass:"line-number"},[n._v("126")]),e("br"),e("span",{staticClass:"line-number"},[n._v("127")]),e("br"),e("span",{staticClass:"line-number"},[n._v("128")]),e("br"),e("span",{staticClass:"line-number"},[n._v("129")]),e("br"),e("span",{staticClass:"line-number"},[n._v("130")]),e("br"),e("span",{staticClass:"line-number"},[n._v("131")]),e("br"),e("span",{staticClass:"line-number"},[n._v("132")]),e("br"),e("span",{staticClass:"line-number"},[n._v("133")]),e("br"),e("span",{staticClass:"line-number"},[n._v("134")]),e("br"),e("span",{staticClass:"line-number"},[n._v("135")]),e("br"),e("span",{staticClass:"line-number"},[n._v("136")]),e("br"),e("span",{staticClass:"line-number"},[n._v("137")]),e("br"),e("span",{staticClass:"line-number"},[n._v("138")]),e("br"),e("span",{staticClass:"line-number"},[n._v("139")]),e("br"),e("span",{staticClass:"line-number"},[n._v("140")]),e("br"),e("span",{staticClass:"line-number"},[n._v("141")]),e("br"),e("span",{staticClass:"line-number"},[n._v("142")]),e("br"),e("span",{staticClass:"line-number"},[n._v("143")]),e("br"),e("span",{staticClass:"line-number"},[n._v("144")]),e("br"),e("span",{staticClass:"line-number"},[n._v("145")]),e("br"),e("span",{staticClass:"line-number"},[n._v("146")]),e("br"),e("span",{staticClass:"line-number"},[n._v("147")]),e("br"),e("span",{staticClass:"line-number"},[n._v("148")]),e("br"),e("span",{staticClass:"line-number"},[n._v("149")]),e("br"),e("span",{staticClass:"line-number"},[n._v("150")]),e("br"),e("span",{staticClass:"line-number"},[n._v("151")]),e("br"),e("span",{staticClass:"line-number"},[n._v("152")]),e("br"),e("span",{staticClass:"line-number"},[n._v("153")]),e("br"),e("span",{staticClass:"line-number"},[n._v("154")]),e("br"),e("span",{staticClass:"line-number"},[n._v("155")]),e("br"),e("span",{staticClass:"line-number"},[n._v("156")]),e("br"),e("span",{staticClass:"line-number"},[n._v("157")]),e("br"),e("span",{staticClass:"line-number"},[n._v("158")]),e("br"),e("span",{staticClass:"line-number"},[n._v("159")]),e("br"),e("span",{staticClass:"line-number"},[n._v("160")]),e("br"),e("span",{staticClass:"line-number"},[n._v("161")]),e("br"),e("span",{staticClass:"line-number"},[n._v("162")]),e("br"),e("span",{staticClass:"line-number"},[n._v("163")]),e("br"),e("span",{staticClass:"line-number"},[n._v("164")]),e("br"),e("span",{staticClass:"line-number"},[n._v("165")]),e("br"),e("span",{staticClass:"line-number"},[n._v("166")]),e("br"),e("span",{staticClass:"line-number"},[n._v("167")]),e("br"),e("span",{staticClass:"line-number"},[n._v("168")]),e("br"),e("span",{staticClass:"line-number"},[n._v("169")]),e("br"),e("span",{staticClass:"line-number"},[n._v("170")]),e("br"),e("span",{staticClass:"line-number"},[n._v("171")]),e("br"),e("span",{staticClass:"line-number"},[n._v("172")]),e("br"),e("span",{staticClass:"line-number"},[n._v("173")]),e("br"),e("span",{staticClass:"line-number"},[n._v("174")]),e("br"),e("span",{staticClass:"line-number"},[n._v("175")]),e("br"),e("span",{staticClass:"line-number"},[n._v("176")]),e("br"),e("span",{staticClass:"line-number"},[n._v("177")]),e("br"),e("span",{staticClass:"line-number"},[n._v("178")]),e("br"),e("span",{staticClass:"line-number"},[n._v("179")]),e("br"),e("span",{staticClass:"line-number"},[n._v("180")]),e("br"),e("span",{staticClass:"line-number"},[n._v("181")]),e("br"),e("span",{staticClass:"line-number"},[n._v("182")]),e("br"),e("span",{staticClass:"line-number"},[n._v("183")]),e("br"),e("span",{staticClass:"line-number"},[n._v("184")]),e("br"),e("span",{staticClass:"line-number"},[n._v("185")]),e("br"),e("span",{staticClass:"line-number"},[n._v("186")]),e("br"),e("span",{staticClass:"line-number"},[n._v("187")]),e("br"),e("span",{staticClass:"line-number"},[n._v("188")]),e("br"),e("span",{staticClass:"line-number"},[n._v("189")]),e("br"),e("span",{staticClass:"line-number"},[n._v("190")]),e("br"),e("span",{staticClass:"line-number"},[n._v("191")]),e("br"),e("span",{staticClass:"line-number"},[n._v("192")]),e("br"),e("span",{staticClass:"line-number"},[n._v("193")]),e("br"),e("span",{staticClass:"line-number"},[n._v("194")]),e("br"),e("span",{staticClass:"line-number"},[n._v("195")]),e("br"),e("span",{staticClass:"line-number"},[n._v("196")]),e("br"),e("span",{staticClass:"line-number"},[n._v("197")]),e("br"),e("span",{staticClass:"line-number"},[n._v("198")]),e("br"),e("span",{staticClass:"line-number"},[n._v("199")]),e("br"),e("span",{staticClass:"line-number"},[n._v("200")]),e("br"),e("span",{staticClass:"line-number"},[n._v("201")]),e("br"),e("span",{staticClass:"line-number"},[n._v("202")]),e("br"),e("span",{staticClass:"line-number"},[n._v("203")]),e("br"),e("span",{staticClass:"line-number"},[n._v("204")]),e("br"),e("span",{staticClass:"line-number"},[n._v("205")]),e("br"),e("span",{staticClass:"line-number"},[n._v("206")]),e("br"),e("span",{staticClass:"line-number"},[n._v("207")]),e("br"),e("span",{staticClass:"line-number"},[n._v("208")]),e("br"),e("span",{staticClass:"line-number"},[n._v("209")]),e("br"),e("span",{staticClass:"line-number"},[n._v("210")]),e("br"),e("span",{staticClass:"line-number"},[n._v("211")]),e("br"),e("span",{staticClass:"line-number"},[n._v("212")]),e("br"),e("span",{staticClass:"line-number"},[n._v("213")]),e("br"),e("span",{staticClass:"line-number"},[n._v("214")]),e("br"),e("span",{staticClass:"line-number"},[n._v("215")]),e("br"),e("span",{staticClass:"line-number"},[n._v("216")]),e("br"),e("span",{staticClass:"line-number"},[n._v("217")]),e("br"),e("span",{staticClass:"line-number"},[n._v("218")]),e("br"),e("span",{staticClass:"line-number"},[n._v("219")]),e("br"),e("span",{staticClass:"line-number"},[n._v("220")]),e("br"),e("span",{staticClass:"line-number"},[n._v("221")]),e("br"),e("span",{staticClass:"line-number"},[n._v("222")]),e("br"),e("span",{staticClass:"line-number"},[n._v("223")]),e("br"),e("span",{staticClass:"line-number"},[n._v("224")]),e("br"),e("span",{staticClass:"line-number"},[n._v("225")]),e("br"),e("span",{staticClass:"line-number"},[n._v("226")]),e("br"),e("span",{staticClass:"line-number"},[n._v("227")]),e("br"),e("span",{staticClass:"line-number"},[n._v("228")]),e("br"),e("span",{staticClass:"line-number"},[n._v("229")]),e("br"),e("span",{staticClass:"line-number"},[n._v("230")]),e("br"),e("span",{staticClass:"line-number"},[n._v("231")]),e("br"),e("span",{staticClass:"line-number"},[n._v("232")]),e("br"),e("span",{staticClass:"line-number"},[n._v("233")]),e("br"),e("span",{staticClass:"line-number"},[n._v("234")]),e("br"),e("span",{staticClass:"line-number"},[n._v("235")]),e("br"),e("span",{staticClass:"line-number"},[n._v("236")]),e("br"),e("span",{staticClass:"line-number"},[n._v("237")]),e("br"),e("span",{staticClass:"line-number"},[n._v("238")]),e("br"),e("span",{staticClass:"line-number"},[n._v("239")]),e("br"),e("span",{staticClass:"line-number"},[n._v("240")]),e("br"),e("span",{staticClass:"line-number"},[n._v("241")]),e("br"),e("span",{staticClass:"line-number"},[n._v("242")]),e("br"),e("span",{staticClass:"line-number"},[n._v("243")]),e("br"),e("span",{staticClass:"line-number"},[n._v("244")]),e("br"),e("span",{staticClass:"line-number"},[n._v("245")]),e("br"),e("span",{staticClass:"line-number"},[n._v("246")]),e("br"),e("span",{staticClass:"line-number"},[n._v("247")]),e("br"),e("span",{staticClass:"line-number"},[n._v("248")]),e("br"),e("span",{staticClass:"line-number"},[n._v("249")]),e("br"),e("span",{staticClass:"line-number"},[n._v("250")]),e("br"),e("span",{staticClass:"line-number"},[n._v("251")]),e("br"),e("span",{staticClass:"line-number"},[n._v("252")]),e("br"),e("span",{staticClass:"line-number"},[n._v("253")]),e("br")])]),e("h2",{attrs:{id:"exit释放锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#exit释放锁"}},[n._v("#")]),n._v(" exit释放锁")]),n._v(" "),e("h3",{attrs:{id:"objectmonitor的exit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#objectmonitor的exit"}},[n._v("#")]),n._v(" ObjectMonitor的exit")]),n._v(" "),e("p",[n._v("为了提高性能，ObjectMonitor的exit实现会做很多优化，比如如果锁冲突比较激烈，\nexit会倾向于只设置owner为NULL然后返回，因为在spin过程中的线程会通过cas获取到锁，不需要由释放锁的线程去唤醒。\n节省了unpark的唤醒开销。如果出现罕见的等待线程没被唤醒的情况，通过前面EnterI中的_Responsible机制保证等待线程能够获取到锁。")]),n._v(" "),e("p",[n._v("_succ字段（successor的意思），是用于减少多余的warkup调用量。")]),n._v(" "),e("ul",[e("li",[n._v("release_clear_owner(current)：设置owner为NULL")]),n._v(" "),e("li",[n._v("OrderAccess::storeload()：storeload保证之后的其他线程能够读取到owner的新值（即NULL）")]),n._v(" "),e("li",[e("code",[n._v("(intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL)")]),n._v(" "),e("ul",[e("li",[n._v("说明要么两个队列都是空的，不需要唤醒，如果有并发情况（其他线程cas失败再入队，这里没有读取到），可以通过_Responsible机制保证等待线程不会无限等待。")]),n._v(" "),e("li",[n._v("如果队列不为空，并且_succ不为空，_succ不为空说明有其他线程是spin，不需要主动唤醒，可以直接返回。")])])]),n._v(" "),e("li",[e("code",[n._v("try_set_owner_from(NULL, current) != NULL")]),n._v("：说明修改_owner为NULL之后有其他线程获取了锁，可以退出。")]),n._v(" "),e("li",[n._v("判断_EntryList不为空，则"),e("code",[n._v("ExitEpilog(current, w)")]),n._v("设置_succ为EntryList头结点，并调用unpark唤醒。")]),n._v(" "),e("li",[n._v("如果_EntryList为空，但是_cxq不为空，则将_cxq队列元素转移到_EntryList，在通过"),e("code",[n._v("ExitEpilog(current, w)")]),n._v("唤醒EntryList等待的头结点。")])]),n._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('  for (;;) {\n    assert(current == owner_raw(), "invariant");\n\n    // Drop the lock.\n    // release semantics: prior loads and stores from within the critical section\n    // must not float (reorder) past the following store that drops the lock.\n    // Uses a storeload to separate release_store(owner) from the\n    // successor check. The try_set_owner() below uses cmpxchg() so\n    // we get the fence down there.\n    release_clear_owner(current);\n    OrderAccess::storeload();\n\n    if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {\n      return;\n    }\n    // Other threads are blocked trying to acquire the lock.\n\n    // Normally the exiting thread is responsible for ensuring succession,\n    // but if other successors are ready or other entering threads are spinning\n    // then this thread can simply store NULL into _owner and exit without\n    // waking a successor.  The existence of spinners or ready successors\n    // guarantees proper succession (liveness).  Responsibility passes to the\n    // ready or running successors.  The exiting thread delegates the duty.\n    // More precisely, if a successor already exists this thread is absolved\n    // of the responsibility of waking (unparking) one.\n    //\n    // The _succ variable is critical to reducing futile wakeup frequency.\n    // _succ identifies the "heir presumptive" thread that has been made\n    // ready (unparked) but that has not yet run.  We need only one such\n    // successor thread to guarantee progress.\n    // See http://www.usenix.org/events/jvm01/full_papers/dice/dice.pdf\n    // section 3.3 "Futile Wakeup Throttling" for details.\n    //\n    // Note that spinners in Enter() also set _succ non-null.\n    // In the current implementation spinners opportunistically set\n    // _succ so that exiting threads might avoid waking a successor.\n    // Another less appealing alternative would be for the exiting thread\n    // to drop the lock and then spin briefly to see if a spinner managed\n    // to acquire the lock.  If so, the exiting thread could exit\n    // immediately without waking a successor, otherwise the exiting\n    // thread would need to dequeue and wake a successor.\n    // (Note that we\'d need to make the post-drop spin short, but no\n    // shorter than the worst-case round-trip cache-line migration time.\n    // The dropped lock needs to become visible to the spinner, and then\n    // the acquisition of the lock by the spinner must become visible to\n    // the exiting thread).\n\n    // It appears that an heir-presumptive (successor) must be made ready.\n    // Only the current lock owner can manipulate the EntryList or\n    // drain _cxq, so we need to reacquire the lock.  If we fail\n    // to reacquire the lock the responsibility for ensuring succession\n    // falls to the new owner.\n    //\n    if (try_set_owner_from(NULL, current) != NULL) {\n      return;\n    }\n\n    guarantee(owner_raw() == current, "invariant");\n\n    ObjectWaiter* w = NULL;\n\n    w = _EntryList;\n    if (w != NULL) {\n      // I\'d like to write: guarantee (w->_thread != current).\n      // But in practice an exiting thread may find itself on the EntryList.\n      // Let\'s say thread T1 calls O.wait().  Wait() enqueues T1 on O\'s waitset and\n      // then calls exit().  Exit release the lock by setting O._owner to NULL.\n      // Let\'s say T1 then stalls.  T2 acquires O and calls O.notify().  The\n      // notify() operation moves T1 from O\'s waitset to O\'s EntryList. T2 then\n      // release the lock "O".  T2 resumes immediately after the ST of null into\n      // _owner, above.  T2 notices that the EntryList is populated, so it\n      // reacquires the lock and then finds itself on the EntryList.\n      // Given all that, we have to tolerate the circumstance where "w" is\n      // associated with current.\n      assert(w->TState == ObjectWaiter::TS_ENTER, "invariant");\n      ExitEpilog(current, w);\n      return;\n    }\n\n    // If we find that both _cxq and EntryList are null then just\n    // re-run the exit protocol from the top.\n    w = _cxq;\n    if (w == NULL) continue;\n\n    // Drain _cxq into EntryList - bulk transfer.\n    // First, detach _cxq.\n    // The following loop is tantamount to: w = swap(&amp;cxq, NULL)\n    for (;;) {\n      assert(w != NULL, "Invariant");\n      ObjectWaiter* u = Atomic::cmpxchg(&amp;_cxq, w, (ObjectWaiter*)NULL);\n      if (u == w) break;\n      w = u;\n    }\n\n    assert(w != NULL, "invariant");\n    assert(_EntryList == NULL, "invariant");\n\n    // Convert the LIFO SLL anchored by _cxq into a DLL.\n    // The list reorganization step operates in O(LENGTH(w)) time.\n    // It\'s critical that this step operate quickly as\n    // "current" still holds the outer-lock, restricting parallelism\n    // and effectively lengthening the critical section.\n    // Invariant: s chases t chases u.\n    // TODO-FIXME: consider changing EntryList from a DLL to a CDLL so\n    // we have faster access to the tail.\n\n    _EntryList = w;\n    ObjectWaiter* q = NULL;\n    ObjectWaiter* p;\n    for (p = w; p != NULL; p = p->_next) {\n      guarantee(p->TState == ObjectWaiter::TS_CXQ, "Invariant");\n      p->TState = ObjectWaiter::TS_ENTER;\n      p->_prev = q;\n      q = p;\n    }\n\n    // In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL\n    // The MEMBAR is satisfied by the release_store() operation in ExitEpilog().\n\n    // See if we can abdicate to a spinner instead of waking a thread.\n    // A primary goal of the implementation is to reduce the\n    // context-switch rate.\n    if (_succ != NULL) continue;\n\n    w = _EntryList;\n    if (w != NULL) {\n      guarantee(w->TState == ObjectWaiter::TS_ENTER, "invariant");\n      ExitEpilog(current, w);\n      return;\n    }\n  }\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br"),e("span",{staticClass:"line-number"},[n._v("35")]),e("br"),e("span",{staticClass:"line-number"},[n._v("36")]),e("br"),e("span",{staticClass:"line-number"},[n._v("37")]),e("br"),e("span",{staticClass:"line-number"},[n._v("38")]),e("br"),e("span",{staticClass:"line-number"},[n._v("39")]),e("br"),e("span",{staticClass:"line-number"},[n._v("40")]),e("br"),e("span",{staticClass:"line-number"},[n._v("41")]),e("br"),e("span",{staticClass:"line-number"},[n._v("42")]),e("br"),e("span",{staticClass:"line-number"},[n._v("43")]),e("br"),e("span",{staticClass:"line-number"},[n._v("44")]),e("br"),e("span",{staticClass:"line-number"},[n._v("45")]),e("br"),e("span",{staticClass:"line-number"},[n._v("46")]),e("br"),e("span",{staticClass:"line-number"},[n._v("47")]),e("br"),e("span",{staticClass:"line-number"},[n._v("48")]),e("br"),e("span",{staticClass:"line-number"},[n._v("49")]),e("br"),e("span",{staticClass:"line-number"},[n._v("50")]),e("br"),e("span",{staticClass:"line-number"},[n._v("51")]),e("br"),e("span",{staticClass:"line-number"},[n._v("52")]),e("br"),e("span",{staticClass:"line-number"},[n._v("53")]),e("br"),e("span",{staticClass:"line-number"},[n._v("54")]),e("br"),e("span",{staticClass:"line-number"},[n._v("55")]),e("br"),e("span",{staticClass:"line-number"},[n._v("56")]),e("br"),e("span",{staticClass:"line-number"},[n._v("57")]),e("br"),e("span",{staticClass:"line-number"},[n._v("58")]),e("br"),e("span",{staticClass:"line-number"},[n._v("59")]),e("br"),e("span",{staticClass:"line-number"},[n._v("60")]),e("br"),e("span",{staticClass:"line-number"},[n._v("61")]),e("br"),e("span",{staticClass:"line-number"},[n._v("62")]),e("br"),e("span",{staticClass:"line-number"},[n._v("63")]),e("br"),e("span",{staticClass:"line-number"},[n._v("64")]),e("br"),e("span",{staticClass:"line-number"},[n._v("65")]),e("br"),e("span",{staticClass:"line-number"},[n._v("66")]),e("br"),e("span",{staticClass:"line-number"},[n._v("67")]),e("br"),e("span",{staticClass:"line-number"},[n._v("68")]),e("br"),e("span",{staticClass:"line-number"},[n._v("69")]),e("br"),e("span",{staticClass:"line-number"},[n._v("70")]),e("br"),e("span",{staticClass:"line-number"},[n._v("71")]),e("br"),e("span",{staticClass:"line-number"},[n._v("72")]),e("br"),e("span",{staticClass:"line-number"},[n._v("73")]),e("br"),e("span",{staticClass:"line-number"},[n._v("74")]),e("br"),e("span",{staticClass:"line-number"},[n._v("75")]),e("br"),e("span",{staticClass:"line-number"},[n._v("76")]),e("br"),e("span",{staticClass:"line-number"},[n._v("77")]),e("br"),e("span",{staticClass:"line-number"},[n._v("78")]),e("br"),e("span",{staticClass:"line-number"},[n._v("79")]),e("br"),e("span",{staticClass:"line-number"},[n._v("80")]),e("br"),e("span",{staticClass:"line-number"},[n._v("81")]),e("br"),e("span",{staticClass:"line-number"},[n._v("82")]),e("br"),e("span",{staticClass:"line-number"},[n._v("83")]),e("br"),e("span",{staticClass:"line-number"},[n._v("84")]),e("br"),e("span",{staticClass:"line-number"},[n._v("85")]),e("br"),e("span",{staticClass:"line-number"},[n._v("86")]),e("br"),e("span",{staticClass:"line-number"},[n._v("87")]),e("br"),e("span",{staticClass:"line-number"},[n._v("88")]),e("br"),e("span",{staticClass:"line-number"},[n._v("89")]),e("br"),e("span",{staticClass:"line-number"},[n._v("90")]),e("br"),e("span",{staticClass:"line-number"},[n._v("91")]),e("br"),e("span",{staticClass:"line-number"},[n._v("92")]),e("br"),e("span",{staticClass:"line-number"},[n._v("93")]),e("br"),e("span",{staticClass:"line-number"},[n._v("94")]),e("br"),e("span",{staticClass:"line-number"},[n._v("95")]),e("br"),e("span",{staticClass:"line-number"},[n._v("96")]),e("br"),e("span",{staticClass:"line-number"},[n._v("97")]),e("br"),e("span",{staticClass:"line-number"},[n._v("98")]),e("br"),e("span",{staticClass:"line-number"},[n._v("99")]),e("br"),e("span",{staticClass:"line-number"},[n._v("100")]),e("br"),e("span",{staticClass:"line-number"},[n._v("101")]),e("br"),e("span",{staticClass:"line-number"},[n._v("102")]),e("br"),e("span",{staticClass:"line-number"},[n._v("103")]),e("br"),e("span",{staticClass:"line-number"},[n._v("104")]),e("br"),e("span",{staticClass:"line-number"},[n._v("105")]),e("br"),e("span",{staticClass:"line-number"},[n._v("106")]),e("br"),e("span",{staticClass:"line-number"},[n._v("107")]),e("br"),e("span",{staticClass:"line-number"},[n._v("108")]),e("br"),e("span",{staticClass:"line-number"},[n._v("109")]),e("br"),e("span",{staticClass:"line-number"},[n._v("110")]),e("br"),e("span",{staticClass:"line-number"},[n._v("111")]),e("br"),e("span",{staticClass:"line-number"},[n._v("112")]),e("br"),e("span",{staticClass:"line-number"},[n._v("113")]),e("br"),e("span",{staticClass:"line-number"},[n._v("114")]),e("br"),e("span",{staticClass:"line-number"},[n._v("115")]),e("br"),e("span",{staticClass:"line-number"},[n._v("116")]),e("br"),e("span",{staticClass:"line-number"},[n._v("117")]),e("br"),e("span",{staticClass:"line-number"},[n._v("118")]),e("br"),e("span",{staticClass:"line-number"},[n._v("119")]),e("br"),e("span",{staticClass:"line-number"},[n._v("120")]),e("br"),e("span",{staticClass:"line-number"},[n._v("121")]),e("br"),e("span",{staticClass:"line-number"},[n._v("122")]),e("br"),e("span",{staticClass:"line-number"},[n._v("123")]),e("br"),e("span",{staticClass:"line-number"},[n._v("124")]),e("br"),e("span",{staticClass:"line-number"},[n._v("125")]),e("br"),e("span",{staticClass:"line-number"},[n._v("126")]),e("br"),e("span",{staticClass:"line-number"},[n._v("127")]),e("br"),e("span",{staticClass:"line-number"},[n._v("128")]),e("br"),e("span",{staticClass:"line-number"},[n._v("129")]),e("br"),e("span",{staticClass:"line-number"},[n._v("130")]),e("br"),e("span",{staticClass:"line-number"},[n._v("131")]),e("br")])])])}),[],!1,null,null,null);s.default=t.exports}}]);