(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{680:function(r,e,t){"use strict";t.r(e);var a=t(34),i=Object(a.a)({},(function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"dragonwell-wisp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dragonwell-wisp"}},[r._v("#")]),r._v(" dragonwell wisp")]),r._v(" "),t("p",[r._v("dragonwelll是阿里在openjdk上扩展的jdk，提供了阿里基于阿里丰富Java实用经验的优化。\n其中wisp是用户态线程也就是常说的协程，并且支持透明协程，能够将全部的线程转换为协程（可以加黑名单控制一些线程不转）。")]),r._v(" "),t("p",[r._v("协程相比普通线程，优势在于创建成本低、上下文切换极小。")]),r._v(" "),t("p",[r._v("创建成本低，是因为协程是应用层的对象，创建协程的开销几乎等于创建一个对象的开销，而创建普通线程，需要调用操作系统的功能，\n普通线程数量有上限，并且每个普通线程都会占用一定的内存空间（比如通过Xss配置的ThreadStackSize大小）。")]),r._v(" "),t("p",[r._v("另外协程在上下文切换上的开销会显著大幅降低，上下文切换是指当一个线程执行到阻塞点时，比如条件等待，会将自己的线程挂起，保存上下文，释放底层的cpu\n去执行其他的线程任务，当线程可以恢复时，比如锁释放后这个线程可以重新争抢锁，线程又会变成可运行状态，cpu就能重新恢复它的上下文。\n这样一个挂起、恢复的过程就是上下文切换，上下文切换的开销来源于 1. 用户态和内核态的切换，上下文切换导致cpu缓存失效命中率较低 2. 内核需要进行调度\n决定下一个要运行的任务。切换的开销耗时大概在几微妙。")]),r._v(" "),t("p",[r._v("而协程的做法是，将锁等线程阻塞恢复的执行，改为jvm内部控制，jvm内部控制线程运行哪些代码，由此减少了和内核的交互，在io密集型场景下会涉及到非常多的\n上下文切换（因为io操作时，原请求处理线程需要阻塞等待结果），所以通过协程能够降低上下文切换。")]),r._v(" "),t("h2",{attrs:{id:"使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[r._v("#")]),r._v(" 使用")]),r._v(" "),t("p",[r._v("下载dragonwell jdk，地址在"),t("a",{attrs:{href:"https://github.com/alibaba/dragonwell11/releases",target:"_blank",rel:"noopener noreferrer"}},[r._v("github release"),t("OutboundLink")],1)]),r._v(" "),t("p",[r._v("其中名称中Standard是和openjdk功能一样的jdk版本，包含Extended的是包含JWarmup、wisp功能的jdk版本。我们需要下载Extended版本的jdk。\n下载完成后，解压，配置JAVA_HOME或直接使用bin/java启动应用，启动参数中增加"),t("code",[r._v("-XX:+UseWisp2 -Dio.netty.transport.noNative=true -Dio.grpc.netty.shaded.io.netty.transport.noNative=true")]),r._v("\n后面的参数是为了避免netty的native-transport模式把wisp线程阻塞在Epoll JNI。")]),r._v(" "),t("h2",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[r._v("#")]),r._v(" 实现")]),r._v(" "),t("p",[r._v("wisp基于JVM栈操作、结合Runtime对阻塞方法的支持以及加入调度器，来让应用无需改动地获得异步的性能。")]),r._v(" "),t("h3",{attrs:{id:"wisp和loom的对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wisp和loom的对比"}},[r._v("#")]),r._v(" wisp和loom的对比")]),r._v(" "),t("p",[r._v("loom是jdk19中新加入的协程项目，提供了virtual thread，需要用户显式创建virtual thread即协程。\n在已有项目中使用，需要等待框架支持或修改底层代码，成本较高。\n而Wisp完全兼容已有代码，不需要代码改动，只需要修改启动参数，对于研发使用更加友好。\nWisp基于JKU大学的"),t("a",{attrs:{href:"https://ssw.jku.at/Research/Projects/JVM/Coroutines.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("研究项目"),t("OutboundLink")],1),r._v("实现")]),r._v(" "),t("ul",[t("li",[r._v("Loom: 共享栈、协程占用内存少。支持百万级协程的新编程模型")]),r._v(" "),t("li",[r._v("Wisp2: 独立栈，切换速度快。基于现有的编程模型，通过减少OS的介入以及高效的调度透明提升性能。")])]),r._v(" "),t("h3",{attrs:{id:"概念术语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念术语"}},[r._v("#")]),r._v(" 概念术语")]),r._v(" "),t("ul",[t("li",[r._v("Carrier: 代码的实际执行者，对应一个操作系统提供的线程，同时包括调度所需的上下文信息（IO事件、定时事件），调度维护所需数据结构。")]),r._v(" "),t("li",[r._v("WispEngine: 一组Carrier组成的执行器，协程创建出来后会绑定到一个engine，由engine下的carrier交替执行。")]),r._v(" "),t("li",[r._v("Scheduler: 对应一个WispEngine, carrier之间的协作以及steal策略都由scheduler实现")]),r._v(" "),t("li",[r._v("WorkStealing: carrier之间互相窃取任务以平衡队列长度")]),r._v(" "),t("li",[r._v("SysMonitor: SysMonitor负责监控每个Carrier上任务的执行状态，在长时间未发生切换时抢占协程")]),r._v(" "),t("li",[r._v("抢占：让长时间执行CPU代码的协程主动yield出CPU")]),r._v(" "),t("li",[r._v("Coroutine: JKU提供的协程，主要提供了切换的能力")]),r._v(" "),t("li",[r._v("WispTask: 一个协程所需的调度结构，对应一个Coroutine。一般是映射到一个Thread对象")]),r._v(" "),t("li",[r._v("EventPump: 事件源，一般是网络上的fd事件，在Linux下对应一个epoll eventloop")]),r._v(" "),t("li",[r._v("全转模式：将所有线程转为协程")]),r._v(" "),t("li",[r._v("有栈、无栈：")]),r._v(" "),t("li",[r._v("对称、非对称：")])]),r._v(" "),t("h3",{attrs:{id:"分层设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分层设计"}},[r._v("#")]),r._v(" 分层设计")]),r._v(" "),t("ul",[t("li",[r._v("Coroutine: 主要提供栈切换能力，基于JKU的开源项目")]),r._v(" "),t("li",[r._v("WispEngine: 依赖Coroutine的切换能力，提供park/unpark/registerEvent/timer等接口供core library调用")]),r._v(" "),t("li",[r._v("Runtime支持：在JDK需要阻塞的标准库以及synchronized等需要阻塞的地方调用WispEngine的接口")])]),r._v(" "),t("h2",{attrs:{id:"调度执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度执行"}},[r._v("#")]),r._v(" 调度执行")]),r._v(" "),t("p",[r._v("carrier线程本身会执行不断从workQueue上拉取协程，并切换至该协程中执行，此时carrier被这个协程占据。当协程执行过程中需要挂起，\n会触发切换至carrier线程原先的上下文，继续触发调度。当carrier发现自身队列全空时会考虑steal任务，帮其他carrier减少压力。\n我们以一个读取jdbc的协程来举例：")]),r._v(" "),t("ol",[t("li",[r._v("协程读取jdbc driver底层的Socket，此时数据包尚未收到，协程需要等待，于是\n"),t("ol",[t("li",[r._v("将这个socket的读事件注册到eventPump")]),r._v(" "),t("li",[r._v("切换到carrier的逻辑，让出控制流")])])]),r._v(" "),t("li",[r._v("carrier扫描队列，发现没有任务需要执行，将自己挂起，节约资源")]),r._v(" "),t("li",[r._v("eventPump上的事件就绪，唤醒协程\n"),t("ol",[t("li",[r._v("将协程入队")]),r._v(" "),t("li",[r._v("向os唤醒carrier")])])]),r._v(" "),t("li",[r._v("carrier从队列上拿到协程，继续读取socket，并执行后续的逻辑")])]),r._v(" "),t("p",[r._v("通过上述方式，协程分片使用Carrier的计算资源。")]),r._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"img.png","data-src":"img.png",loading:"lazy"}})]),r._v(" "),t("h2",{attrs:{id:"核心实现点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心实现点"}},[r._v("#")]),r._v(" 核心实现点")]),r._v(" "),t("ol",[t("li",[r._v("如何实现协程阻塞后再恢复时，从之前的上下文状态和代码运行位置继续执行？")]),r._v(" "),t("li",[r._v("对ThreadLocal是否有影响？对于用户使用没有影响，因为ThreadLocal基于Thread对象存储，用户使用的现成还是原来的Thread对象。只是start被替换。")]),r._v(" "),t("li",[r._v("对LockSupport(jdk的阻塞)和synchronized做了哪些改造？对AQS的阻塞唤醒是否有影响？")]),r._v(" "),t("li",[r._v("透明切换如何实现的？修改Thread.start类")]),r._v(" "),t("li",[r._v("如何防止个别coroutine长时间占用cpu导致其他coroutine得不到调度?")]),r._v(" "),t("li",[r._v("对gc有什么影响？")]),r._v(" "),t("li",[r._v("IO阻塞、唤醒是如何处理的？")]),r._v(" "),t("li",[r._v("Thread.sleep如何处理的？")]),r._v(" "),t("li",[r._v("coroutine之间是如何调度的？WispCarrier如何决定下一个要执行的coroutine")]),r._v(" "),t("li",[r._v("多核性能问题？为什么16核以上（不包含）会浪费大量资源在调度上？")]),r._v(" "),t("li",[r._v("work steal如何实现的？")])]),r._v(" "),t("h2",{attrs:{id:"实现疑问todo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现疑问todo"}},[r._v("#")]),r._v(" 实现疑问TODO")]),r._v(" "),t("ul",[t("li",[r._v("Worker的queue中的任务是什么时机入队的？")]),r._v(" "),t("li",[r._v("yieldTo如何切换到另一个协程继续执行的？如果没有可运行协程，如何挂起线程？")])]),r._v(" "),t("h2",{attrs:{id:"不同实现方案对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同实现方案对比"}},[r._v("#")]),r._v(" 不同实现方案对比")]),r._v(" "),t("p",[r._v("loom、kotlin coroutine")]),r._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[r._v("#")]),r._v(" 参考")]),r._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/alibaba/dragonwell8/wiki/Wisp%E6%96%87%E6%A1%A3",target:"_blank",rel:"noopener noreferrer"}},[r._v("wisp文档"),t("OutboundLink")],1)]),r._v(" "),t("li",[t("a",{attrs:{href:"https://medium.com/the-polyglot-programmer/what-are-goroutines-and-how-do-they-actually-work-f2a734f6f991",target:"_blank",rel:"noopener noreferrer"}},[r._v("how goroutines work"),t("OutboundLink")],1)]),r._v(" "),t("li",[t("a",{attrs:{href:"https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("scheduling-in-go-part1"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=i.exports}}]);