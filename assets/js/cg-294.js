(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{725:function(a,s,n){"use strict";n.r(s);var e=n(34),t=Object(e.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"性能分析利器-async-profiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能分析利器-async-profiler"}},[a._v("#")]),a._v(" 性能分析利器: async-profiler")]),a._v(" "),n("h2",{attrs:{id:"介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),n("p",[a._v("性能分析优化是高级工程师的必备能力，在需要提升服务性能、降低成本、排查定位服务性能问题时，工程师需要能够\n及时的了解服务运行状态、了解性能瓶颈并进行优化。")]),a._v(" "),n("p",[a._v("了解服务运行状态，最重要的是服务的内部运行状态观测，即我的程序在执行什么代码？哪些方法消耗CPU最多？哪些方法申请内存最多？")]),a._v(" "),n("p",[a._v("在出现线上问题时，我想很多同学都了解通过java自带的一些命令和linux自带的命令比如top、jstat、jstack等来进行简单的问题定位，\n但是有时使用这些工具仍然不能很好的发现问题，比如一些一些方法的执行分散在多个线程中，通过jstack并不能直观的统计出来，因为jstack只能\n按照线程维度统计，而不是方法维度。")]),a._v(" "),n("p",[a._v("这时，我们就需要一些其他的工具来帮助我们查看运行状态，async-profiler就是一个非常使用的工具，通过async-profiler，我们能够\n绘制CPU火焰图、内存分配火焰图，直观的看出消耗CPU最多的函数。")]),a._v(" "),n("p",[a._v("并且async-profiler不同于jstack的是解决了safepoint bias问题（简单来解释是jstack捕获的状态并不准确）。")]),a._v(" "),n("p",[a._v("async-profiler能够追踪的事件有")]),a._v(" "),n("ul",[n("li",[a._v("CPU cycles即CPU运行")]),a._v(" "),n("li",[a._v("perf count, 比如cache missed, branch missed, page faults, context switches")]),a._v(" "),n("li",[a._v("Allocation内存申请")]),a._v(" "),n("li",[a._v("lock加锁，包含monitor lock和ReentrantLock")])]),a._v(" "),n("h2",{attrs:{id:"使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[a._v("#")]),a._v(" 使用")]),a._v(" "),n("h3",{attrs:{id:"直接安装使用async-profiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#直接安装使用async-profiler"}},[a._v("#")]),a._v(" 直接安装使用async-profiler")]),a._v(" "),n("h4",{attrs:{id:"安装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[a._v("#")]),a._v(" 安装")]),a._v(" "),n("p",[a._v("在"),n("a",{attrs:{href:"https://github.com/async-profiler/async-profiler/releases",target:"_blank",rel:"noopener noreferrer"}},[a._v("github release"),n("OutboundLink")],1),a._v("中查找最新的安装包")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("## 下载async-profiler包，对于其他系统可以参考")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("wget")]),a._v(" https://github.com/async-profiler/async-profiler/releases/download/v3.0/async-profiler-3.0-linux-arm64.tar.gz\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("## 解压")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("tar")]),a._v(" -zxvf async-profiler-3.0-linux-arm64.tar.gz\n"),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("cd")]),a._v(" async-profiler-3.0-linux-x64/bin\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 通过jps等方式找到目标pid")]),a._v("\n./asprof list "),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${pid}")]),a._v(" \n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br")])]),n("p",[a._v("采集cpu信息")]),a._v(" "),n("p",[a._v("如下命令，表示给进程id为123的Java进行进行60s的采样，输出结果到/tmp/profile.html文件中，完成之后，我们就可以打开/tmp/profile.html文件\n查看火焰图信息。")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[a._v("./asprof -d "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("60")]),a._v(" -f /tmp/profile.html "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("123")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("h3",{attrs:{id:"启动时开启async-profiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#启动时开启async-profiler"}},[a._v("#")]),a._v(" 启动时开启async-profiler")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[a._v("java -agentpath:/path/to/libasyncProfiler.so"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("start,event"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("cpu,timeout"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("60s,file"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("profile.html\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("h3",{attrs:{id:"通过arthas使用async-profiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通过arthas使用async-profiler"}},[a._v("#")]),a._v(" 通过arthas使用async-profiler")]),a._v(" "),n("h3",{attrs:{id:"使用asyncprofiler查看特定方法调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用asyncprofiler查看特定方法调用"}},[a._v("#")]),a._v(" 使用asyncprofiler查看特定方法调用")]),a._v(" "),n("p",[a._v("比如通过asyncprofiler查看堆外内存的申请情况")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[a._v("./asprof -d "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("60")]),a._v(" -e java.nio.Bits.reserveMemory "),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${pid}")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("h2",{attrs:{id:"通过火焰图查看代码问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通过火焰图查看代码问题"}},[a._v("#")]),a._v(" 通过火焰图查看代码问题")]),a._v(" "),n("p",[a._v("./asprof -d 60 -e cpu -f /tmp/profile.html ${pid}")]),a._v(" "),n("p",[a._v("完成之后即可通过查看html文件，寻找横向比较宽的代码来确认cpu开销是否合理。")]),a._v(" "),n("h2",{attrs:{id:"内存申请"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存申请"}},[a._v("#")]),a._v(" 内存申请")]),a._v(" "),n("p",[a._v("如果有gc、内存相关问题，除了使用jmap -histo、dump内存之后mat分析，来可以通过asyncprofiler查看内存申请的代码。\n只需要把event换成alloc即可。")]),a._v(" "),n("h2",{attrs:{id:"async-profiler代码实现分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#async-profiler代码实现分析"}},[a._v("#")]),a._v(" async-profiler代码实现分析")]),a._v(" "),n("h3",{attrs:{id:"启动脚本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#启动脚本"}},[a._v("#")]),a._v(" 启动脚本")]),a._v(" "),n("p",[a._v("async-profiler提供了一个shell脚本profiler.sh，提供了常用的命令支持。\nprofiler.sh核心的执行逻辑是通过java attach机制attach到目标jvm进程，加载async-profiler的jvmti实现libasyncProfiler.so(linux下)，\nlibasyncProfiler中实现了async-profiler的实行逻辑。")]),a._v(" "),n("p",[a._v("jattach是async-profiler封装的attach工具")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$ACTION")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v("\n    start"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("resume"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        fdtransfer\n        jattach "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$ACTION")]),a._v(",file="),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$FILE")]),a._v(","),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$OUTPUT")]),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$FORMAT")]),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$PARAMS")]),a._v('"')]),a._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    check"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        jattach "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$ACTION")]),a._v(",file="),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$FILE")]),a._v(","),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$OUTPUT")]),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$FORMAT")]),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$PARAMS")]),a._v('"')]),a._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v(".\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br")])]),n("p",[a._v("java attach机制在之前讲解jstack实现的文章中有详细介绍，交互方式是通过socket进行通信，async-profiler这里通过c语言实现了attach。")]),a._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('int jattach_hotspot(int pid, int nspid, int argc, char** argv) {\n    if (check_socket(nspid) != 0 &amp;&amp; start_attach_mechanism(pid, nspid) != 0) {\n        perror("Could not start attach mechanism");\n        return 1;\n    }\n\n    int fd = connect_socket(nspid);\n    if (fd == -1) {\n        perror("Could not connect to socket");\n        return 1;\n    }\n\n    printf("Connected to remote JVM\\n");\n\n    if (write_command(fd, argc, argv) != 0) {\n        perror("Error writing to socket");\n        close(fd);\n        return 1;\n    }\n\n    int result = read_response(fd, argc, argv);\n    close(fd);\n\n    return result;\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br")])]),n("h3",{attrs:{id:"libasyncprofiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#libasyncprofiler"}},[a._v("#")]),a._v(" libasyncProfiler")]),a._v(" "),n("h4",{attrs:{id:"vmentry"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vmentry"}},[a._v("#")]),a._v(" vmEntry")]),a._v(" "),n("p",[a._v("vmEntry是async-profiler的入口类，里面提供了Agent_OnAttach等jvmti要求的接口实现，\n在运行时attach async-profiler时，jvm会调用Agent_OnAttach。")]),a._v(" "),n("ol",[n("li",[a._v("解析参数")]),a._v(" "),n("li",[a._v("VM::init，初始化，会获取jvm的AsyncGetCallTrace方法。")]),a._v(" "),n("li",[a._v("Profiler::instance()->run(args)：")])]),a._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('extern "C" DLLEXPORT jint JNICALL\nAgent_OnAttach(JavaVM* vm, char* options, void* reserved) {\n    Arguments args(true);\n    Error error = args.parse(options);\n\n    Log::open(args);\n\n    if (error) {\n        Log::error("%s", error.message());\n        return ARGUMENTS_ERROR;\n    }\n\n    if (!VM::init(vm, true)) {\n        Log::error("JVM does not support Tool Interface");\n        return COMMAND_ERROR;\n    }\n\n    // Save the arguments in case of shutdown\n    if (args._action == ACTION_START || args._action == ACTION_RESUME) {\n        _agent_args.save(args);\n    }\n\n    error = Profiler::instance()->run(args);\n    if (error) {\n        Log::error("%s", error.message());\n        return COMMAND_ERROR;\n    }\n\n    return 0;\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br")])]),n("h3",{attrs:{id:"vm-init"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vm-init"}},[a._v("#")]),a._v(" VM::init")]),a._v(" "),n("ul",[n("li",[a._v("获取AsyncGetCallTrace")]),a._v(" "),n("li",[a._v("Profiler::instance->updateSymbols")])]),a._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('bool VM::init(JavaVM* vm, bool attach) {\n    _libjvm = getLibraryHandle("libjvm.so");\n    _asyncGetCallTrace = (AsyncGetCallTrace)dlsym(_libjvm, "AsyncGetCallTrace");\n    _getManagement = (JVM_GetManagement)dlsym(_libjvm, "JVM_GetManagement");\n\n    Profiler* profiler = Profiler::instance();\n    profiler->updateSymbols(false);\n    CodeCache* lib = isOpenJ9()\n        ? profiler->findJvmLibrary("libj9vm")\n        : profiler->findLibraryByAddress((const void*)_asyncGetCallTrace);\n    if (lib == NULL) {\n        return false;\n    }\n\n    VMStructs::init(lib);\n    \n    if (attach) {\n        ready();\n    }\n\n    jvmtiCapabilities capabilities = {0};\n    capabilities.can_generate_all_class_hook_events = 1;\n    capabilities.can_retransform_classes = 1;\n    capabilities.can_retransform_any_class = isOpenJ9() ? 0 : 1;\n    capabilities.can_generate_vm_object_alloc_events = isOpenJ9() ? 1 : 0;\n    capabilities.can_generate_sampled_object_alloc_events = _can_sample_objects ? 1 : 0;\n    capabilities.can_get_bytecodes = 1;\n    capabilities.can_get_constant_pool = 1;\n    capabilities.can_get_source_file_name = 1;\n    capabilities.can_get_line_numbers = 1;\n    capabilities.can_generate_compiled_method_load_events = 1;\n    capabilities.can_generate_monitor_events = 1;\n    capabilities.can_tag_objects = 1;\n    if (_jvmti->AddCapabilities(&amp;capabilities) != 0) {\n        _can_sample_objects = false;\n        capabilities.can_generate_sampled_object_alloc_events = 0;\n        _jvmti->AddCapabilities(&amp;capabilities);\n    }\n\n    jvmtiEventCallbacks callbacks = {0};\n    callbacks.VMInit = VMInit;\n    callbacks.VMDeath = VMDeath;\n    callbacks.ClassLoad = ClassLoad;\n    callbacks.ClassPrepare = ClassPrepare;\n    callbacks.ClassFileLoadHook = Instrument::ClassFileLoadHook;\n    callbacks.CompiledMethodLoad = Profiler::CompiledMethodLoad;\n    callbacks.DynamicCodeGenerated = Profiler::DynamicCodeGenerated;\n    callbacks.ThreadStart = Profiler::ThreadStart;\n    callbacks.ThreadEnd = Profiler::ThreadEnd;\n    callbacks.MonitorContendedEnter = LockTracer::MonitorContendedEnter;\n    callbacks.MonitorContendedEntered = LockTracer::MonitorContendedEntered;\n    callbacks.VMObjectAlloc = J9ObjectSampler::VMObjectAlloc;\n    callbacks.SampledObjectAlloc = ObjectSampler::SampledObjectAlloc;\n    _jvmti->SetEventCallbacks(&amp;callbacks, sizeof(callbacks));\n\n    _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n    _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n    _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n    _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\n\n    if (hotspot_version() == 0 || !CodeHeap::available()) {\n        // Workaround for JDK-8173361: avoid CompiledMethodLoad events when possible\n        _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n    } else {\n        // DebugNonSafepoints is automatically enabled with CompiledMethodLoad,\n        // otherwise we set the flag manually\n        char* flag_addr = (char*)JVMFlag::find("DebugNonSafepoints");\n        if (flag_addr != NULL) {\n            *flag_addr = 1;\n        }\n    }\n\n    if (attach) {\n        loadAllMethodIDs(jvmti(), jni());\n        _jvmti->GenerateEvents(JVMTI_EVENT_DYNAMIC_CODE_GENERATED);\n        _jvmti->GenerateEvents(JVMTI_EVENT_COMPILED_METHOD_LOAD);\n    } else {\n        _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n    }\n\n    OS::installSignalHandler(WAKEUP_SIGNAL, NULL, wakeupHandler);\n\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br"),n("span",{staticClass:"line-number"},[a._v("33")]),n("br"),n("span",{staticClass:"line-number"},[a._v("34")]),n("br"),n("span",{staticClass:"line-number"},[a._v("35")]),n("br"),n("span",{staticClass:"line-number"},[a._v("36")]),n("br"),n("span",{staticClass:"line-number"},[a._v("37")]),n("br"),n("span",{staticClass:"line-number"},[a._v("38")]),n("br"),n("span",{staticClass:"line-number"},[a._v("39")]),n("br"),n("span",{staticClass:"line-number"},[a._v("40")]),n("br"),n("span",{staticClass:"line-number"},[a._v("41")]),n("br"),n("span",{staticClass:"line-number"},[a._v("42")]),n("br"),n("span",{staticClass:"line-number"},[a._v("43")]),n("br"),n("span",{staticClass:"line-number"},[a._v("44")]),n("br"),n("span",{staticClass:"line-number"},[a._v("45")]),n("br"),n("span",{staticClass:"line-number"},[a._v("46")]),n("br"),n("span",{staticClass:"line-number"},[a._v("47")]),n("br"),n("span",{staticClass:"line-number"},[a._v("48")]),n("br"),n("span",{staticClass:"line-number"},[a._v("49")]),n("br"),n("span",{staticClass:"line-number"},[a._v("50")]),n("br"),n("span",{staticClass:"line-number"},[a._v("51")]),n("br"),n("span",{staticClass:"line-number"},[a._v("52")]),n("br"),n("span",{staticClass:"line-number"},[a._v("53")]),n("br"),n("span",{staticClass:"line-number"},[a._v("54")]),n("br"),n("span",{staticClass:"line-number"},[a._v("55")]),n("br"),n("span",{staticClass:"line-number"},[a._v("56")]),n("br"),n("span",{staticClass:"line-number"},[a._v("57")]),n("br"),n("span",{staticClass:"line-number"},[a._v("58")]),n("br"),n("span",{staticClass:"line-number"},[a._v("59")]),n("br"),n("span",{staticClass:"line-number"},[a._v("60")]),n("br"),n("span",{staticClass:"line-number"},[a._v("61")]),n("br"),n("span",{staticClass:"line-number"},[a._v("62")]),n("br"),n("span",{staticClass:"line-number"},[a._v("63")]),n("br"),n("span",{staticClass:"line-number"},[a._v("64")]),n("br"),n("span",{staticClass:"line-number"},[a._v("65")]),n("br"),n("span",{staticClass:"line-number"},[a._v("66")]),n("br"),n("span",{staticClass:"line-number"},[a._v("67")]),n("br"),n("span",{staticClass:"line-number"},[a._v("68")]),n("br"),n("span",{staticClass:"line-number"},[a._v("69")]),n("br"),n("span",{staticClass:"line-number"},[a._v("70")]),n("br"),n("span",{staticClass:"line-number"},[a._v("71")]),n("br"),n("span",{staticClass:"line-number"},[a._v("72")]),n("br"),n("span",{staticClass:"line-number"},[a._v("73")]),n("br"),n("span",{staticClass:"line-number"},[a._v("74")]),n("br"),n("span",{staticClass:"line-number"},[a._v("75")]),n("br"),n("span",{staticClass:"line-number"},[a._v("76")]),n("br"),n("span",{staticClass:"line-number"},[a._v("77")]),n("br"),n("span",{staticClass:"line-number"},[a._v("78")]),n("br"),n("span",{staticClass:"line-number"},[a._v("79")]),n("br"),n("span",{staticClass:"line-number"},[a._v("80")]),n("br"),n("span",{staticClass:"line-number"},[a._v("81")]),n("br"),n("span",{staticClass:"line-number"},[a._v("82")]),n("br"),n("span",{staticClass:"line-number"},[a._v("83")]),n("br")])]),n("h3",{attrs:{id:"asyncgetcalltrace"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncgetcalltrace"}},[a._v("#")]),a._v(" AsyncGetCallTrace")]),a._v(" "),n("p",[a._v("通过"),n("code",[a._v("perf_event")]),a._v("获取线程调用栈，通过"),n("code",[a._v("AsyncGetCallTree")]),a._v("方法进行匹配。")]),a._v(" "),n("p",[a._v("async-profiler通过jvm内部提供的一个"),n("code",[a._v("AsyncGetCallTrace")]),a._v("方法来获得线程栈，这也是async-profiler名称中async的来源。\n"),n("code",[a._v("AsyncGetCallTrace")])]),a._v(" "),n("h3",{attrs:{id:"allocation-profiling"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#allocation-profiling"}},[a._v("#")]),a._v(" allocation profiling")]),a._v(" "),n("p",[a._v("allocation profiling可以对内存申请进行采样，用来排查GC频繁等内存相关问题，脚本中-e参数增加alloc，比如-e cpu,alloc开启。")]),a._v(" "),n("p",[a._v("allocation profiling的实现，不是在Object对象中加入采样逻辑（会有非常大的性能开销），是通过TLAB采样的方式实现的，hotspot jdk\n在TLAB的创建、TLAB外分配对象时会发送相关event事件。")]),a._v(" "),n("ul",[n("li",[a._v("对象在新创建的TLAB中分配内存时")]),a._v(" "),n("li",[a._v("对象因为在TLAB剩余空间放不下需要在TLAB外分配时")])]),a._v(" "),n("p",[a._v("如果发现使用G1收集器时，humonguous区比较多，可以通过\nG1CollectedHeap::humongous_obj_allocate这个event来查看humongous对象申请的栈")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[a._v("./asprof -d "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("20")]),a._v(" -e G1CollectedHeap::humongous_obj_allocate "),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$pid")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("h3",{attrs:{id:"deoptimization"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#deoptimization"}},[a._v("#")]),a._v(" deoptimization")]),a._v(" "),n("p",[a._v("通过"),n("code",[a._v("Deoptimization::uncommon_trap_inner")]),a._v("这个event可以获取deoptimize事件的路径。")]),a._v(" "),n("h3",{attrs:{id:"其他的native方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他的native方法"}},[a._v("#")]),a._v(" 其他的native方法")]),a._v(" "),n("p",[a._v("如何找到类似Deoptimization::uncommon_trap_inner其他的方法？")]),a._v(" "),n("p",[a._v("通过"),n("code",[a._v("nm $JAVA_HOME/lib/server/libjvm.so")]),a._v("查看所有的方法（mac平台libjvm.so换成libjvm.dylib)，然后找自己关心的方法，第三列就是方法名可以传入"),n("code",[a._v("-e")]),a._v("的参数中")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[a._v("nm "),n("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$JAVA_HOME")]),a._v("/lib/server/libjvm.so \n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("h3",{attrs:{id:"java-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-api"}},[a._v("#")]),a._v(" Java API")]),a._v(" "),n("h3",{attrs:{id:"no-java-frame问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#no-java-frame问题"}},[a._v("#")]),a._v(" no_java_frame问题")]),a._v(" "),n("div",{staticClass:"language-shell line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# sysctl kernel.perf_event_paranoid=1")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# sysctl kernel.kptr_restrict=0")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br")])]),n("h2",{attrs:{id:"实现层面"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现层面"}},[a._v("#")]),a._v(" 实现层面")]),a._v(" "),n("h3",{attrs:{id:"为什么async-profiler不会遇到常规的sampling-profiler的safepoint-bias问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么async-profiler不会遇到常规的sampling-profiler的safepoint-bias问题"}},[a._v("#")]),a._v(" 为什么async-profiler不会遇到常规的sampling profiler的safepoint bias问题？")]),a._v(" "),n("p",[a._v("sampling profiler通常使用Java提供的获取所有线程的线程栈的API实现，而这个API是通过VM_Operation这个包装来实现的，\n即会停止所有的线程（进入safepoint），然后采集所有线程的线程栈。")]),a._v(" "),n("p",[a._v("为什么需要暂停所有的线程？如果不暂停，采集线程在遍历栈数据时，被采集线程也可能在修改栈，产生并发异常问题。")]),a._v(" "),n("p",[a._v("safepoint有哪些问题呢？线程要进入safepoint需要检查当前是否需要进入safepoint了，并且在进入safepoint之前需要准备好oopMap数据。\noopMap是记录当前frame中哪些位置存储了对象指针，这是为gc时进行gc tracing遍历使用的，因为栈上引用的对象会作为gc root。")]),a._v(" "),n("p",[a._v("为了性能考虑，不能在所有的代码执行位置都去检查是否要进入safepoint以及生成oopMap数据，所以在目前hotspot中，之后在方法调用、非有最大次数循环回边、阻塞操作等\n位置去检查safepoint状态，所以safepoint内的操作看到的当前线程状态也是在这些位置，这就导致线程栈数据看到的总是方法调用、回边等这些位置的栈。")]),a._v(" "),n("p",[a._v("那么async-profiler是如何实现的？")]),a._v(" "),n("p",[a._v("async-profiler在kernel中注册信号处理器，信号出现时（比如间隔10ms一个信号），每个线程都会收到信号并去执行\n信号处理代码，在信号处理代码中完成sample数据采集比如获取当前线程栈，因为每个线程各自负责自己的栈并且此时线程不会执行代码不会修改栈内存，\n这样也就不需要同时在一个safepoint内暂停所有的线程，也就没有了safepiont带来的safepoint bias问题。")]),a._v(" "),n("p",[a._v("async-profiler当前使用的是hotspot jvm内的一个内部方法AsyncGetCallTrace，但是由于是一个内部API在用起来难度很大，也没有充分的测试底阿妈。\n现在有一个"),n("a",{attrs:{href:"https://openjdk.org/jeps/435",target:"_blank",rel:"noopener noreferrer"}},[a._v("JEP435"),n("OutboundLink")],1),a._v("提议创建一个新的AsyncGetStackTrace API，这个新的API能够像getThreadInfos接口一样在其他线程执行，\n即通过一个线程获取其他线程的线程栈，在获取一个线程的线程栈时暂停对应线程的执行。")]),a._v(" "),n("h2",{attrs:{id:"参考资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://netflixtechblog.com/java-in-flames-e763b3d32166",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java in Flames"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("CPU Flame Graphs"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Differential Flame Graphs"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Off-CPU Flame Graphs"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://krzysztofslusarski.github.io/2022/12/12/async-manual.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("async-profiler manual"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=t.exports}}]);