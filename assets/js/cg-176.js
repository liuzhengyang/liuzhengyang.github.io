(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{608:function(s,a,t){"use strict";t.r(a);var e=t(34),l=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"匿名内部类的支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匿名内部类的支持"}},[s._v("#")]),s._v(" 匿名内部类的支持")]),s._v(" "),t("h2",{attrs:{id:"解决的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决的问题"}},[s._v("#")]),s._v(" 解决的问题")]),s._v(" "),t("p",[s._v("匿名内部类的classname是编译器自动生成的。\n比如当前的类是MyClass，则生成出来的匿名内部类是MyClass$1, MyClass$2。\n编号是按照在类中的顺序决定的。")]),s._v(" "),t("p",[s._v("这也就可能导致一个问题，如果代码前后匿名内部类的代码相对位置变化了，则新旧编号可能发生变化。\n比如之前MyClass$1匿名内部类的新classname变成了MyClass$2，此时因为dcevm目前不支持继承关系的更新，会导致reload失败。")]),s._v(" "),t("p",[s._v("AnonymousClassPatchPlugin会记录reload前后的匿名内部类信息，并匹配前后的匿名内部类（class签名、方法签名、字段签名的总的拼接字符串）")]),s._v(" "),t("p",[s._v("然后通过Javassist的CtClass提供的replaceClassName方法替换匿名内部类。")])])}),[],!1,null,null,null);a.default=l.exports}}]);