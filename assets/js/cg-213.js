(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{643:function(s,a,e){"use strict";e.r(a);var t=e(34),_=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"redefine"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redefine"}},[s._v("#")]),s._v(" redefine")]),s._v(" "),e("h2",{attrs:{id:"基本实现思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本实现思路"}},[s._v("#")]),s._v(" 基本实现思路")]),s._v(" "),e("ul",[e("li",[s._v("解析传过来的class byte数组；验证参数（包括后面解析之后的方法验证等）；Parse成Klass，记为scratch_class，使用的class loader是the_class的class loader。")]),s._v(" "),e("li",[s._v("要被redefine的class记为the_class")]),s._v(" "),e("li",[s._v("scratch_class中的数据最终会复制到the_class，这样系统中其他位置对于the_class的引用不用修改（比如heap中对象头的metadata指针）。")]),s._v(" "),e("li",[s._v("清理codecache等缓存")])]),s._v(" "),e("p",[s._v("执行阶段")]),s._v(" "),e("ul",[e("li",[s._v("doit_prologue：在JavaThread中运行，解析构建scratch_class、link the_class(如果没link过，link过程中会初始化vtable itable)、合并constant pool重写字节码")]),s._v(" "),e("li",[s._v("doit：在VM Thread中运行，deoptimize compiled code；替换scratch_class中的方法到the_class；调整其他类到the_class的引用(利用ClassLoaderDataGraph::classes_do来遍历所有类和方法等)")]),s._v(" "),e("li",[s._v("doit_epilogue：清理doit_prologue和doit中申请的内存")])]),s._v(" "),e("h2",{attrs:{id:"执行步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行步骤"}},[s._v("#")]),s._v(" 执行步骤")]),s._v(" "),e("p",[s._v('RedefineClasses API用来实现修改一个或多个类的定义。\n我们按照修改一个类的场景下进行讨论，把当前的类成为 the_class，要修改的新类成为 "scratch_class"，\n使用the_class是因为只有一个表示特定类的机构，redefinition不会替换成一个新的class对象，只会替换其中的一部分数据。\n使用"scratch_class"（scratch意为草稿的）是因为这个scratch_class用来保存新类的一部分数据，这些数据会进行合并再放到the_class中,\nredefine结束scratch_class就没有用了。')]),s._v(" "),e("p",[s._v("RedefineClasses执行分为几个步骤，doit_prologue(), doit()和doit_epilogue()")]),s._v(" "),e("ol",[e("li",[s._v("doit_prologue表示前序准备阶段，要在safepoint中由JavaThread运行。会检查参数然后\n"),e("ul",[e("li",[s._v("解析新类的定义")]),s._v(" "),e("li",[s._v("链接(link)scratch_class")]),s._v(" "),e("li",[s._v("合并constant polls常量池，并根据合并的常量池按需修改bytecode")]),s._v(" "),e("li",[s._v("验证scratch_class的bytecode")]),s._v(" "),e("li",[s._v("设置常量池缓存，并且修改bytecode来使用缓存")]),s._v(" "),e("li",[s._v("把scratch_class和the_cass进行比较，验证scratch_class是合法的替换类")]),s._v(" "),e("li",[s._v("如果一切正常，保存scratch_class，在后面的doit中使用")])])]),s._v(" "),e("li",[s._v("doit()被VMThread调用，在safepoint中运行。\n"),e("ul",[e("li",[s._v("获取scratch_class")]),s._v(" "),e("li",[s._v("house keeping(清理breakpoints和cache，deoptimize依赖当前类的JIT编译的代码）")]),s._v(" "),e("li",[s._v("把scratch_class中的数据替换到the_class中")]),s._v(" "),e("li",[s._v("给the_class中被淘汰但是仍然感兴趣的部分增加weakreference")]),s._v(" "),e("li",[s._v("调整其他类的对the_class有方法引用的常量池缓存和vtable。这个调整使用ClassLoaderDataGraph::classes_do()")]),s._v(" "),e("li",[s._v("通知SystemDictionary")])])]),s._v(" "),e("li",[s._v("doit_epilogue()方法在VM op结束和safepoint完成后被JavaThread调用，负责清理前面操作申请的内存。")])]),s._v(" "),e("p",[s._v("常量池的细节：")]),s._v(" "),e("p",[s._v("redefine the_class时，我们不能直接把scratch_class的常量池替换到the_class中，因为可能有旧的方法在运行，\n可能导致常量池错误，所以为了兼容旧方法和新方法同时使用，需要对常量池进行合并，并修改新方法的字节码来使用合并后的常量池。")]),s._v(" "),e("p",[s._v("合并时，先把旧的常量池复制到合并常量中，保存之前的顺序。然后把scratch_class中的唯一的常量池entry追加到常量池中，\n并且记录常量池索引index的变化。\n合并完成后，旧方法不会察觉到任何变化，对于新的bytecode，需要修改使用合并常量池。")])])}),[],!1,null,null,null);a.default=_.exports}}]);