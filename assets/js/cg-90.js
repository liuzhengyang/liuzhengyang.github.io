(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{520:function(r,a,e){"use strict";e.r(a);var n=e(34),o=Object(n.a)({},(function(){var r=this,a=r.$createElement,e=r._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"profiler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#profiler"}},[r._v("#")]),r._v(" profiler")]),r._v(" "),e("p",[r._v("当出现性能问题时，需要工程师需排查定位解决相关问题，方法有很多种，今天我们来了解一种很实用的profiler方法。")]),r._v(" "),e("p",[r._v("profiler是用于profile/profiling的工具，profile英文含义中的动词，表示 "),e("strong",[r._v("概述，扼要介绍；给......画侧面像，显出......侧面轮廓")]),r._v("。")]),r._v(" "),e("p",[r._v("在程序领域，表示查看程序运行过程中的各种内部状态，比如CPU消耗、内存使用情况等。")]),r._v(" "),e("p",[r._v("profiler通常采取采样的方式获取数据，比如定期获取程序的线程栈（jstack），收集一定量的数据后进行合并、排序，就能发现哪些方法出现次数最多，\n也说明这些函数中的代码，消耗的CPU最多（）。")]),r._v(" "),e("p",[r._v("常见的profiler工具，有async-profiler, JFR(Java Mission Control)，jProfiler等。")]),r._v(" "),e("p",[r._v("其中async-profiler是目前Java领域比较推荐的profiler工具并且是开源软件。")]),r._v(" "),e("h2",{attrs:{id:"async-profiler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-profiler"}},[r._v("#")]),r._v(" async-profiler")]),r._v(" "),e("p",[r._v("async-profiler的核心特点是开源、无safepoint-bias问题。")]),r._v(" "),e("p",[r._v("safepoint-bias在我之前的jstack文章中有提到，简单来讲就是类似通过定期调用Java提供的获取线程栈的方式，得到的线程栈采样会有失真，因为\n通过jstack或等价的Java API等方式获取线程栈，会在jvm的safepoint中执行，而safepoint只会在某些特定的执行条件下（方法进入、退出、noncounted loop backedge）\n才会进入，所以导致某些代码的执行并不能采样到。")]),r._v(" "),e("p",[r._v("而开源的特点，会让我们使用更加方便，并且开源用户众多会不断推动优化改进async-profiler。")]),r._v(" "),e("h3",{attrs:{id:"async-profiler-介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-profiler-介绍"}},[r._v("#")]),r._v(" async-profiler 介绍")]),r._v(" "),e("h3",{attrs:{id:"async-profiler-参数配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-profiler-参数配置"}},[r._v("#")]),r._v(" async-profiler 参数配置")]),r._v(" "),e("h2",{attrs:{id:"continuous-profiling"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#continuous-profiling"}},[r._v("#")]),r._v(" continuous profiling")]),r._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[r._v("#")]),r._v(" 参考")]),r._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://grafana.com/blog/2022/11/02/announcing-grafana-phlare-oss-continuous-profiling-database/",target:"_blank",rel:"noopener noreferrer"}},[r._v("grafana phlare continuous profiling"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzkxNTE3ODU0NA==&mid=2247512000&idx=1&sn=67a5e15f52d7cc31fe173e15a9ae1909&chksm=c161fa9ff6167389679e9ba0fe5e46cf7366bdf879e82b4c865fdc2d10c06bc59bb2d2602f62&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[r._v("线程剖析 - 助力定位代码层面高耗时问题｜得物技术"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://grafana.com/blog/2024/05/15/ai-powered-insights-for-continuous-profiling-introducing-flame-graph-ai-in-grafana-cloud/?utm_source=grafana_news&utm_medium=rss",target:"_blank",rel:"noopener noreferrer"}},[r._v("AI-powered insights for continuous profiling: introducing Flame graph AI in Grafana Cloud"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=o.exports}}]);