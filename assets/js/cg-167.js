(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{598:function(e,a,r){"use strict";r.r(a);var t=r(34),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"g1-gc是如何运行的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1-gc是如何运行的"}},[e._v("#")]),e._v(" G1 GC是如何运行的")]),e._v(" "),r("p",[e._v("本文目的：了解G1 GC的运行机制、了解G1 GC的常用配置和最佳实践、了解G1 GC场景问题的排查解决方法。")]),e._v(" "),r("p",[e._v("个人介绍：8年丰富的Java服务端开发使用经验，高并发业务、活动架构设计。\n课程介绍：深入了解G1 GC的执行流程、运行机制、设计思想；了解G1的常用配置；了解常见GC问题的排查定位优化方法。")]),e._v(" "),r("h2",{attrs:{id:"gc简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc简介"}},[e._v("#")]),e._v(" GC简介")]),e._v(" "),r("p",[e._v("GC，自动内存管理，内存申请、内存回收。\n内存申请: TLAB\n内存回收:\n什么对象可以回收、什么对象不可以回收（图遍历）。存活对象移动\n存活，有用，能在程序中使用到。如果一个对象是存活对象，则这个对象引用的对象也是存活对象。使用到的起始位置（线程 栈 本地变量表、操作数栈，ClassLoader，Heap部分回收时其他区域的引用）。\nGC Roots，遍历，标记。清除、复制、整理。\n标记复制：移动对象到新区域（survivor或old），修改引用来源的指针值。")]),e._v(" "),r("h2",{attrs:{id:"g1-gc简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1-gc简介"}},[e._v("#")]),e._v(" G1 GC简介")]),e._v(" "),r("p",[e._v("G1 GC又称为Garbage First GC，具备低延迟（停顿时间）、高吞吐的特性，是当前JDK(JDK9以上)默认的垃圾回收器。")]),e._v(" "),r("p",[e._v("G1 GC是分代的、按照region划分堆内存，在回收内存时，选择回收效率最高的若干个region进行回收，从而实现可控低延迟和高吞吐。\n同时，G1 GC在回收老年代时会通过并发标记来降低对应用(mutator)的停顿影响。")]),e._v(" "),r("h3",{attrs:{id:"为什么创造出g1-gc-之前的gc遇到了什么问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么创造出g1-gc-之前的gc遇到了什么问题"}},[e._v("#")]),e._v(" 为什么创造出G1 GC，之前的GC遇到了什么问题？")]),e._v(" "),r("p",[e._v("在对外提供实时服务的服务端领域，G1 GC出现之前，普遍使用的GC是CMS，\nCMS通过并发标记清除解决了普通的标记清除算法在回收老年代时的长时间停顿。\n为什么普通标记清除会出现长时间停顿？\n因为在服务端开始使用更大的内存（8G、16G、32G甚至更多），使用大内存的原因有随着业务逻辑复杂常驻内存对象越来越多、大内存提供更强的性能（相比多个小内存进程能够复用一些内存空间）。\n但是对于普通的标记清除或标记整理算法，暂停耗时基本和内存大小以及回收区域内的存活对象总大小成正比，因为标记清除需要对存活对象图进行图遍历。")]),e._v(" "),r("p",[e._v("所以对于内存较大、存活对象较多的老年代，普通标记清除算法需要的暂停时间就比较长。\nCMS通过并发标记，能够降低老年代一定的停顿时间。")]),e._v(" "),r("p",[e._v("但是CMS会存在内存碎片问题，需要搭配Compaction压缩来进行内存整理，压缩时对象的移动，也会导致较长时间的停顿。")]),e._v(" "),r("p",[e._v("另外对于年轻代，CMS需要搭配ParNew进行并行收集，ParNew（多线程标记复制算法）的回收暂停时间也会随着年轻代大小的变大而变长。")]),e._v(" "),r("p",[e._v("所以G1 GC以前的GC，在堆内存比较大时，可能会遇到长达几秒的停顿时间。")]),e._v(" "),r("p",[e._v("长时间的停顿可能带来什么样问题呢？")]),e._v(" "),r("p",[e._v("如果是一个http服务，可能导致客户端请求超时或让用户体验变差。\n如果Java服务调用其他资源（比如rpc、缓存、数据库等），长时间的停顿可能导致调用超时，导致调用方自身因素出现的资源访问失败。")]),e._v(" "),r("h3",{attrs:{id:"g1-gc是如何解决上述问题的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1-gc是如何解决上述问题的"}},[e._v("#")]),e._v(" G1 GC是如何解决上述问题的？")]),e._v(" "),r("p",[e._v("G1 GC通过将堆内存划分为若干个相同大小的逻辑区域即region，每个region的大小为2的指数幂个byte大小（最小1MB，最大32MB）。\n用户可以通过-XX:MaxGCPauseMillis参数配置希望的最大暂停时间，然后G1 GC通过这个参数来控制每次回收时回收的region数量，\n通过控制region数量，就能够控制暂停时间。")]),e._v(" "),r("p",[e._v("G1 GC也实现了分代收集，在逻辑上将region划分为了young和old即年轻代和老年代。\n在平时主要采用young-only的回收模式，即回收全部的young region，通过控制young region的数量，能够控制young-only gc的暂停时间。\n当老年代空间大小超过一定阈值后（默认堆内存大小的45%），G1 GC会开始进行并发标记，\n并发标记阶段不会暂停mutator，并发标记完成后会进行短暂的重新标记和清理，这两个阶段会暂停但是时间很短。\n并发标记周期结束后，G1 GC会开始进行多次mixed gc，mixed GC会回收全部的young region和一部分回收效率最高的old region。\n回收效率最高的old region是通过并发标记周期中的标记信息获得的。")]),e._v(" "),r("h2",{attrs:{id:"g1实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1实现"}},[e._v("#")]),e._v(" G1实现")]),e._v(" "),r("h3",{attrs:{id:"内存分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[e._v("#")]),e._v(" 内存分配")]),e._v(" "),r("p",[e._v("内存管理包含分配和回收两个方面。")]),e._v(" "),r("p",[e._v("分配阶段默认采用TLAB的策略，即Thread Local Allocation Buffer。\n每个线程在申请对象内存时，会优先使用本地的TLAB，即线程缓存的一段内存空间，\n第一次申请时，会到g1当前分配内存的region中去申请一段内存。\n然后在TLAB这段内存内部给这个对象分配内存空间，只需要记录并修改TLAB的top即可实现。\n在TLAB剩余空间不够当前对象使用时，TLAB会判断当前剩余的空间是否大于等于waste limit值，\n如果小于，TLAB会回退到region中去分配，然后调大waste limit值，否则呢会重新申请一个TLAB\n来给这个对象分配内存。")]),e._v(" "),r("h3",{attrs:{id:"young-only"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#young-only"}},[e._v("#")]),e._v(" Young Only")]),e._v(" "),r("p",[e._v("图遍历")]),e._v(" "),r("p",[e._v("创建一个queue队列；\n队列中放入若干个初始Node节点；")]),e._v(" "),r("p",[e._v("while (队列不为空) {")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language-text line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Queue queue;\nqueue.enqueue(roots);\nBFS(G) {\n   while (!queue.empty()) {\n        Node node = queue.poll();\n        visit(node);\n        node.setVisited();\n        for(Node child : node.children()) {\n            if (!child.visited()) {\n                queue.enqueue(child);\n            }\n        }\n   }\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br")])]),r("p",[e._v("回收时机\n回收范围\nSafepoint: http://psy-lob-saw.blogspot.com/2015/12/safepoints.html")]),e._v(" "),r("ul",[r("li",[e._v("Pre Evacuation Collection Set\n"),r("ul",[r("li",[e._v("Prepare TLABs")]),e._v(" "),r("li",[e._v("Choose Collection Set")]),e._v(" "),r("li",[e._v("Humongous Register")])])]),e._v(" "),r("li",[e._v("Evacuate Collection Set\n"),r("ul",[r("li",[e._v("Ext Root Scanning")]),e._v(" "),r("li",[e._v("Update RS\n"),r("ul",[r("li",[e._v("Processed Buffers")]),e._v(" "),r("li",[e._v("Scanned Cards")]),e._v(" "),r("li",[e._v("Skipped Cars")])])]),e._v(" "),r("li",[e._v("Scan RS\n"),r("ul",[r("li",[e._v("Scanned Cards")]),e._v(" "),r("li",[e._v("Claimed Cards")]),e._v(" "),r("li",[e._v("Skipped Cards")])])]),e._v(" "),r("li",[e._v("Code Root Scanning")]),e._v(" "),r("li",[e._v("Object Copy")]),e._v(" "),r("li",[e._v("Termination")]),e._v(" "),r("li",[e._v("GC Worker Other")])])]),e._v(" "),r("li",[e._v("Post Evacuation Collection Set\n"),r("ul",[r("li",[e._v("Code Roots Fixup")]),e._v(" "),r("li",[e._v("Clear Card Table")]),e._v(" "),r("li",[e._v("Reference Processing")])])]),e._v(" "),r("li",[e._v("Code Roots Purge")]),e._v(" "),r("li",[e._v("Redirty Cards")]),e._v(" "),r("li",[e._v("Free Collection Set")]),e._v(" "),r("li",[e._v("Humongous Reclaim")]),e._v(" "),r("li",[e._v("Resize TLABs")])]),e._v(" "),r("p",[e._v("young only 触发时机。")]),e._v(" "),r("p",[e._v("在内存分配器分配，发现没有可用的region后（当前的young region的数量达到了年轻代上限，G1会根据G1ReservePercent配置预留出一定数量region以便在gc时用于survirvor区域和promotion到老年代)")]),e._v(" "),r("p",[e._v("年轻代大小计算控制")]),e._v(" "),r("p",[e._v("Safepoint中执行。(Stop The World)")]),e._v(" "),r("p",[e._v("Why, 为什么需要在Safepoint中执行？")]),e._v(" "),r("ol",[r("li",[e._v("safepoint中mutator是暂停之中的。和mutator并发执行回收，实现复杂、效率不高，因为需要进行大量的同步协调，比如tracing过程中如果mutator修改了引用关系，则需要用write barrier等机制来通知gc")]),e._v(" "),r("li",[e._v("Safepoint中，gc能够确定地枚举根节点，比如线程栈的栈帧中的局部变量表、本地操作栈中哪些位置持有的是引用，这些引用是gc roots也是gc 图遍历的起始节点，这个信息成为stack map。为了提升效率，jvm不会在所有的位置生成stack map，而是在特定情况下（比如方法调用、return等时机生成），进入safepoint需要等待mutator暂停，mutator暂停又是在这些特殊位置（能获取到stack map)才会暂停，因为在safepoint中就可以获取gc需要的stack map从而进行gc root遍历处理了。")])]),e._v(" "),r("p",[e._v("Young only执行步骤")]),e._v(" "),r("p",[e._v("remembered set")]),e._v(" "),r("ol",[r("li",[e._v("触发时机，young region list用完")]),e._v(" "),r("li",[e._v("safepoint")]),e._v(" "),r("li",[e._v("scan roots\n"),r("ol",[r("li",[e._v("Threads root processor")]),e._v(" "),r("li",[e._v("ClassLoader root processor")]),e._v(" "),r("li",[e._v("rem set scan heap roots\n"),r("ol",[r("li",[e._v("遍历Heap Region的Remembered Set（以及未扫描完成的card table？）")])])]),e._v(" "),r("li",[e._v("rem set scan collection set regions")])])]),e._v(" "),r("li",[e._v("evacuate live objects")])]),e._v(" "),r("h4",{attrs:{id:"remembered-set"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#remembered-set"}},[e._v("#")]),e._v(" Remembered Set")]),e._v(" "),r("p",[e._v("region:\n全局维护一个rem set state，其中包含_card_table_scan_state数组，元素值表示对应的region scan的card索引，索引增加到CardsPerRegion表示扫描完成。\ncard table: value值 clean, dirty, scanned。\nchunk：连续的card表示的范围。worker分配任务时，是按照更大的chunk粒度进行划分的，chunk表示连续的若干个card。")]),e._v(" "),r("div",{staticClass:"language-text line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("uint _scan_chunks_per_region\nbool* _region_scan_chunks\nsize_t _num_total_scan_chunks\nuint8_t _scan_chunks_shift\n\n_all_dirty_regions\n_next_dirty_regions\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br")])]),r("div",{staticClass:"language-text line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("OtherRegionsTable\n\nCHeapBitMap _coarse_map;\nPerRegionTable** _fine_grain_regions; // 每个from region，都有自己的PerRegionTable数组，PerRegionTable内部维护bitmap。\nSparsePRT _sparse_table; // sparse 保存稀疏映射，包含引用来源所在region的index到引用来源的card index的映射。\n\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br")])]),r("p",[e._v("Young Only阶段只回收年轻代的region，那么该如何判断这些region中哪些对象可以回收（等价于反过来判断，哪些对象是活跃对象？）\n如果要进行全局的tracing图遍历，则会导致一个问题，遍历的耗时和堆大小正相关。")]),e._v(" "),r("p",[e._v("为了控制暂停耗时，对于这种部分回收的gc，普遍采用引用记录的方式，在G1中，定义了一个Remembered Set，每个region都有自己的Remembered Set。")]),e._v(" "),r("p",[e._v("表示当前region中的对象，被哪些位置(范围)的对象引用了。Remembered Set只保留来自其他的old region的引用，以为所有的young region都会在gc时进行回收，\n都会进行引用遍历，不需要再保存Remembered Set。")]),e._v(" "),r("p",[e._v("在引用修改时（比如astore等指令的引用修改），jvm会在修改引用后，插入一点write barrier代码。\ng1的write barrier会保存一个card table(card table是一个数组，数组元素是byte)，每512byte的内存范围对应card table中的一个位置(数组的index)。\n然后每个对象就能对应到card table中的一个值。\ng1 write barrier会把当前引用来源的对象对应的card值标记为dirty，并将card index放入到线程本地的dirty card queue set即dirty card队列中。\n当然在card table中已经标记为dirty的card不会重复处理。\ndirty表示堆内存中这个范围的对象需要单独处理维护remembered set。")]),e._v(" "),r("p",[e._v("在放入线程本地的dirty card queue set时，队列会有一个上限，如果超过上限，则把本地的队列的数据全部放到global queue全局queue中。")]),e._v(" "),r("p",[e._v("然后激活ConcurrentRefine线程，ConcurrentRefine线程负责扫描对应的card所对应的内存范围内的对象，\n查找对象的引用字段指向的对象，给这些对象所在的region的remembered set增加记录。")]),e._v(" "),r("p",[e._v("在应用实际处理过程中，还可能出现一些非常热门的card，比如有一个全局变量，会不断引用其他region的对象，则这个全局变量对象的card会不断加入到dirty card queue中，\n为了解决这类热点问题，")]),e._v(" "),r("p",[e._v("hot card")]),e._v(" "),r("p",[e._v("另外还有一种情况，当前region中，来自某个region的引用过多，为了降低remembered set的大小，则会把对应的来源region变成粗粒度的记录，即\n记录这个region有引用。称为coarse_map，即稀疏的map。")]),e._v(" "),r("p",[e._v("coarse")]),e._v(" "),r("p",[e._v("ConcurrentRefinementThread: 处理remembered set log")]),e._v(" "),r("h3",{attrs:{id:"mixed-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mixed-gc"}},[e._v("#")]),e._v(" Mixed GC")]),e._v(" "),r("h3",{attrs:{id:"concurrentmarking"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrentmarking"}},[e._v("#")]),e._v(" ConcurrentMarking")]),e._v(" "),r("p",[e._v("TODO: 如果concurrent marking阶段没完成，young区满了，需要进行young gc，如何处理？")]),e._v(" "),r("h4",{attrs:{id:"g1-root-region"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1-root-region"}},[e._v("#")]),e._v(" g1 root region")]),e._v(" "),r("p",[e._v("从g1 gc root能够直接引用到的对象（若干个内存区域范围），区域信息是通过上一次的young only gc中的根扫描获取的。\nconcurrent marking时不再需要重新扫描。")]),e._v(" "),r("p",[e._v("root region就是图遍历的起始节点(集合）（就像经典算法题中的01湖水遍历）")]),e._v(" "),r("p",[e._v("initial mark: 初始标记")]),e._v(" "),r("p",[e._v("如果上一次young only gc或其他触发原因判断出来需要进行concurrent marking阶段了，则在接下来，还会进行一次young only gc，\n这次gc的root processing的时候即对gc root进行处理的时候，会标记concurrent marking bitmap。")]),e._v(" "),r("p",[e._v("G1ConcurrentStartMarkClosures")]),e._v(" "),r("p",[e._v("只会标记引用目标不在collection set中的对象。为什么？collection set中的gc root直接引用如何处理？")]),e._v(" "),r("p",[e._v("因为young region区域内的对象在以后的mixed gc中，也会进行图遍历标记，不会出现漏标。\n所以只需要扫描gc root图遍历中对old region的引用，标记mark bitmap。")]),e._v(" "),r("p",[e._v("G1RootRegionScanClosure:")]),e._v(" "),r("h4",{attrs:{id:"mark-from-roots"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mark-from-roots"}},[e._v("#")]),e._v(" mark from roots")]),e._v(" "),r("p",[e._v("G1CMConcurrentMarkingTask:do_marking_step")]),e._v(" "),r("h4",{attrs:{id:"concurrent-marking-remark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-marking-remark"}},[e._v("#")]),e._v(" concurrent marking & remark")]),e._v(" "),r("p",[e._v("G1CMTask")]),e._v(" "),r("ul",[r("li",[e._v("_task queue: task queue of this task，每个gc线程维护自己的task queue可以减少并发冲突，没有任务的线程还可以steal其他线程的task。")]),e._v(" "),r("li",[e._v("_next_mark_bitmap: 全局的next mark bitmap, next表示当前正在处理中的bitmap，prev是已经处理完的bitmap。mark bitmap")]),e._v(" "),r("li",[e._v("_curr_region: 当前task正在扫描的region")]),e._v(" "),r("li",[e._v("_finger: local finger of this task，表示当前task在当前处理的region内已经处理到哪里了。")]),e._v(" "),r("li",[e._v("global finger: global finger表示g1 allocator内存分配到哪里了。")]),e._v(" "),r("li",[e._v("global mark stack: 当task的local queue满了之后，会把queue里的task放到global mark stack中。")]),e._v(" "),r("li",[e._v("SATB Buffer Queue: 记录并发标记阶段 mutator做的引用修改，以便Remark的时候进行修正。")])]),e._v(" "),r("p",[e._v("G1CMTask::do_mark_step")]),e._v(" "),r("p",[e._v("G1CMBitMapClosure:")]),e._v(" "),r("ul",[r("li",[e._v("do_addr:\n"),r("ul",[r("li",[e._v("move_finger_to")]),e._v(" "),r("li",[e._v("scan_task_entry")]),e._v(" "),r("li",[e._v("drain_local_queue partially")]),e._v(" "),r("li",[e._v("drain_global_stack partially")])])])]),e._v(" "),r("p",[e._v("G1CMOopClosure:")]),e._v(" "),r("ul",[r("li",[e._v("do_oop_word\n"),r("ul",[r("li",[e._v("load reference oop, obj")]),e._v(" "),r("li",[e._v("return if obj null")]),e._v(" "),r("li",[e._v("mark_reference_grey\n"),r("ul",[r("li",[e._v("mark_in_next_bitmap")]),e._v(" "),r("li",[e._v("if obj below global_finger\n"),r("ul",[r("li",[e._v("create G1TaskQueueEntry\n"),r("ul",[r("li",[e._v("if obj is array\n"),r("ul",[r("li",[e._v("process_grey_task_entry")])])]),e._v(" "),r("li",[e._v("obj is not array\n"),r("ul",[r("li",[e._v("push(entry), push to local task queue, if full, move queue to global stack.")])])])])])])])])])])])]),e._v(" "),r("p",[e._v("cm.claim_region，获取一块heap region分配给一个worker。")]),e._v(" "),r("p",[e._v("然后扫描这块region中的next markBitMap，对标记的对象的字段引用进行扫描处理（标记并加入到task queue中），还会drain local queue/global stack partially。")]),e._v(" "),r("p",[e._v("drain_satb_buffer\ndrain_local_queue partially\ndrain_global_stack partially")]),e._v(" "),r("p",[e._v("abort: 一些情况下marking step可以abort中断，比如1. 出现Full GC。2. global stack overflow，然后会重启。3. 有足够的SATB buffer可以处理，do_marking_step只会从头处理SATB buffer，会重启。4. yield。")]),e._v(" "),r("p",[e._v("Marking Bitmap")]),e._v(" "),r("p",[e._v("并发标记中的三色标记，白: 未标记的对象；灰：对象已经标记，但是字段引用还没处理；黑：对象已经标记且字段引用都已经处理；\n对应于图遍历算法，白就是没有遍历到的对象；灰：就是已经访问到，但是还没把字段放入到遍历队列中，即在task queue中？；黑：已经访问到，且字段引用已经放绕到遍历队列中。")]),e._v(" "),r("h4",{attrs:{id:"remark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#remark"}},[e._v("#")]),e._v(" Remark")]),e._v(" "),r("p",[e._v("并发标记时，mutator还一直在运行，需要暂停，把并发标记期间mutator做的一些修改，进行处理、修正。\n如果不暂停，可能永远无法获得一个准确的最终标记信息（哪些对象区域是存活对象，其他区域可以回收）。")]),e._v(" "),r("p",[e._v("Remark通过VM_Operation执行。")]),e._v(" "),r("p",[e._v("G1ConcurrentMark::finalize_marking")]),e._v(" "),r("p",[e._v("G1CMRemarkTask:work 多个worker并行执行\ntask->do_marking_step(target_ms: 1000000000.0, do_termination: true, is_serial: false)")]),e._v(" "),r("p",[e._v("和并发标记过程中的marking_step的区别是，在safepoint中执行，mutator不会创建新的SATB buffer。\n会steal其他线程的task，target_ms无限大。")]),e._v(" "),r("p",[e._v("交换mark bitmap。")]),e._v(" "),r("p",[e._v("计算mark bytes，保存到region中，用于后面的mixed gc中选择collection set。")]),e._v(" "),r("p",[e._v("reclaim empty region。没有活跃对象的region，提前回收。")]),e._v(" "),r("h4",{attrs:{id:"cleanup清理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cleanup清理"}},[e._v("#")]),e._v(" Cleanup清理")]),e._v(" "),r("p",[e._v("phase_cleanup: G1UpdateRemSetTrackingAfterRebuild\n清理rem set清理工作。")]),e._v(" "),r("h4",{attrs:{id:"stab"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stab"}},[e._v("#")]),e._v(" STAB")]),e._v(" "),r("p",[e._v("由于在并发标记时，mutator还在进行对象的创建、引用的修改。所以需要对concurrent marking过程中的修改进行记录。")]),e._v(" "),r("ol",[r("li",[e._v("当前young only gc结束后计算发现IHOP已经超过需要进行concurrent marking cycle了。")]),e._v(" "),r("li",[e._v("标记_in_concurrent_start_gc为true")]),e._v(" "),r("li",[e._v("下一次young only gc时会标记old region中的引用。这一次young only gc最后结束前，调用start_concurrent_cycle。通过satb_mq_set.set_active_all_threads，这样这些线程之后的引用修改操作就会写入到satb buffer中。新加入的线程也会判断。")]),e._v(" "),r("li",[e._v("satb_mark_queue_set active之后，会通过Write Barrier机制在引用修改是，将修改的引用写入到satb buffer中")]),e._v(" "),r("li",[e._v("在concurrent marking阶段中，会不断处理satb buffer，对这些引用引用的对象标记到mark bitmap中。")])]),e._v(" "),r("div",{staticClass:"language-shell line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[e._v("inline void G1BarrierSet::write_ref_field_pre"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("T* field"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("HasDecorator"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("decorators, IS_DEST_UNINITIALIZED"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("::value "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("||")]),e._v("\n      HasDecorator"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("decorators, AS_NO_KEEPALIVE"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("::value"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("return")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n  T heap_oop "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" RawAccess"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("MO_RELAXED"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("::oop_load"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("field"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),e._v("CompressedOops::is_null"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("heap_oop"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("))")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    enqueue"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("CompressedOops::decode_not_null"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("heap_oop"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("))")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br")])]),r("p",[e._v("post_concurrent_mark_start")]),e._v(" "),r("h4",{attrs:{id:"tams"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tams"}},[e._v("#")]),e._v(" TAMS")]),e._v(" "),r("p",[e._v("TAMS是top at mark start，是开始并发标记时，各个region中的内存top位置（即能表示region内哪些位置是有数据的），\n对于TAMS之上的对象，则会认为是存活对象（虽然可能并不存活，不过不影响gc正确性）。")]),e._v(" "),r("h3",{attrs:{id:"mixed-gc-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mixed-gc-2"}},[e._v("#")]),e._v(" Mixed GC")]),e._v(" "),r("p",[e._v("collection set chosen: 如何选择要回收的olg region？")]),e._v(" "),r("p",[e._v("G1BuildCandidateRegionsTask get_sorted_candidates")]),e._v(" "),r("p",[e._v("G1BuildCandidateRegionsClosure: 对每个region计算gc回收效率、决定要不要加入到candidates中。")]),e._v(" "),r("h3",{attrs:{id:"full-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#full-gc"}},[e._v("#")]),e._v(" Full GC")]),e._v(" "),r("p",[e._v("Evacuation Failure")]),e._v(" "),r("ol",[r("li",[e._v("Young only GC过程中，如果要转移到old区，但是没有可用空间了，触发Full GC?")]),e._v(" "),r("li",[e._v("Concurrent Marking过程中，young区空间不足了，触发Full GC?")])]),e._v(" "),r("p",[e._v("G1ReservePercent")]),e._v(" "),r("p",[e._v("Concurrent")]),e._v(" "),r("p",[e._v("Phases:")]),e._v(" "),r("ol",[r("li",[e._v("phase1: mark live objects")]),e._v(" "),r("li",[e._v("phase2: prepare compaction")]),e._v(" "),r("li",[e._v("adjust pointers")]),e._v(" "),r("li",[e._v("do_compaction")])]),e._v(" "),r("h3",{attrs:{id:"停顿预测、调度控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#停顿预测、调度控制"}},[e._v("#")]),e._v(" 停顿预测、调度控制")]),e._v(" "),r("p",[e._v("标准差、方差")]),e._v(" "),r("p",[e._v("decay，衰退均值\n可信度，衰退标准差。")]),e._v(" "),r("h3",{attrs:{id:"其他实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其他实现"}},[e._v("#")]),e._v(" 其他实现")]),e._v(" "),r("h4",{attrs:{id:"humongous-region"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#humongous-region"}},[e._v("#")]),e._v(" Humongous Region")]),e._v(" "),r("p",[e._v("如果一个对象的大小超过了region大小的一半，则认为这个对象为Humongous Object巨型对象，会单独放到一个或多个连续的region中。\n为什么要单独处理Humongous Object？因为移动Humongous Object的成本比较高，所以单独放到Humongous Region，减少移动次数。")]),e._v(" "),r("p",[e._v("Humongous Object一般是数组对象，因为数组对象大小包含数组长度*元素长度（比如引用4byte）")]),e._v(" "),r("h4",{attrs:{id:"reference-process"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reference-process"}},[e._v("#")]),e._v(" Reference Process")]),e._v(" "),r("h4",{attrs:{id:"metaspace-classloader回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#metaspace-classloader回收"}},[e._v("#")]),e._v(" Metaspace, ClassLoader回收")]),e._v(" "),r("h4",{attrs:{id:"usecompressedoops"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#usecompressedoops"}},[e._v("#")]),e._v(" UseCompressedOops")]),e._v(" "),r("h2",{attrs:{id:"g1参数配置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1参数配置"}},[e._v("#")]),e._v(" G1参数配置")]),e._v(" "),r("h3",{attrs:{id:"为什么xms和xmx配置成一样的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么xms和xmx配置成一样的"}},[e._v("#")]),e._v(" 为什么Xms和Xmx配置成一样的？")]),e._v(" "),r("p",[e._v("堆扩展的副作用")]),e._v(" "),r("h2",{attrs:{id:"扩展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[e._v("#")]),e._v(" 扩展")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://blog.jetbrains.com/clion/2020/03/openjdk-with-clion/",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何在本地编译debug openjdk代码"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"questions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#questions"}},[e._v("#")]),e._v(" Questions")]),e._v(" "),r("ul",[r("li",[e._v("标记压缩，如何修改引用来源指针的？")]),e._v(" "),r("li",[e._v("为什么satb的write barrier在pre中，修改字段引用之前？避免并发问题？")]),e._v(" "),r("li",[e._v("prevBitMap和nextBitMap的作用?")])])])}),[],!1,null,null,null);a.default=s.exports}}]);