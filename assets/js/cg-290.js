(window.webpackJsonp=window.webpackJsonp||[]).push([[290],{720:function(a,t,e){"use strict";e.r(t);var r=e(34),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"netty-allocator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty-allocator"}},[a._v("#")]),a._v(" netty allocator")]),a._v(" "),e("p",[a._v("ByteBufAllocator上netty中用来负责内存管理（内存分配和回收）的模块。\nnetty大量借鉴jemalloc的思想并结合Java的使用场景进行优化，从中我们能学到非常多的优秀设计思想。")]),a._v(" "),e("h2",{attrs:{id:"poolarena"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#poolarena"}},[a._v("#")]),a._v(" PoolArena")]),a._v(" "),e("p",[a._v("Arena名称直译是舞台、竞技场，这个名词也来自于jemalloc，netty的Allocator中将内存\n通过多个Arena进行管理，每个线程中申请内存的时候到自己绑定的Arena中去申请，在多核环境下\n能够降低CPU间的并发冲突，提高性能。")]),a._v(" "),e("h2",{attrs:{id:"thread-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#thread-cache"}},[a._v("#")]),a._v(" Thread Cache")]),a._v(" "),e("p",[a._v("Thread Local Cache线程维度的缓存，也是一种非常常用的优化思路，将内存中线程本地缓存，\n可以继续降低线程间的冲突和加锁开销。")]),a._v(" "),e("h2",{attrs:{id:"slab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#slab"}},[a._v("#")]),a._v(" slab")]),a._v(" "),e("p",[a._v("slab上一种按照不同大小分类进行申请内存的思想，能够有效降低fragmentation碎片。\nallocator为了方便记录那块内存被分配出去，采取的是使用几种固定大小的内存块来分配，比如\n申请3B的内存，allocator不会从direct memory中拿出3B的内存块，而是拿出一块4B的，\n因为4B更容易管理（使用index就能表示是那一块内存，相反保存3B的起止位置需要管理的数据就会多很多）。\n使用固定块也能比较好的减少外部碎片（external fragmentation)，但是会有一定的内部碎片（就是固定块中剩余的没有使用的部分，比如上面例子4B中只用了3B，有1B就是内部碎片）\n为了减少内部碎片，slab分配算法会把内存块分为若干个不同的大小级别，比如4B，8B，16B。")])])}),[],!1,null,null,null);t.default=n.exports}}]);