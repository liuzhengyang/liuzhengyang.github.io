(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{652:function(a,s,e){"use strict";e.r(s);var n=e(34),t=Object(n.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"tlab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tlab"}},[a._v("#")]),a._v(" TLAB")]),a._v(" "),e("p",[a._v("TLAB(Thread Local Allocation Buffer)是jvm用来提升对象内存分配速度的机制。")]),a._v(" "),e("p",[a._v("TLAB和id生成器中很多地方又有类似的设计思想。")]),a._v(" "),e("p",[a._v("假如我们要设计一个内存分配器，给一个对象分配内存空间，可以通过一个top指针指向当前内存的位置，如果有对象要分配，则将\ntop加上对象的大小得到新的top值，则老的top到新的top之间的空间就分配给这个对象了。\n但是在实际使用过程中，多线程都在申请内存，那么top的修改就会出现比较多的冲突，为了减少线程间的冲突，可以采用本地缓存的思想，\n每个线程每次拿一大块内存，自己慢慢分配使用，用完了再来申请下一大块内存，由此就降低了线程间的冲突，提升了分配效率。\n这就是Thread Local Allocation Buffer简称TLAB的核心思想。")]),a._v(" "),e("p",[a._v("在实际进行分配时，申请的TLAB的大小、TLAB什么时候更换新的，也是需要考虑的，\nTLAB太小，可能会出现对象频繁放不下，放不下我们只能回退到比较慢的到eden中去分配内存或者更换新的TLAB。\nTLAB如果太大，线程比较多的情况下，可能会导致内存不够用。\nTLAB什么时候更换新的也有讲究，TLAB最后剩下了一块内存，如果一直不更换新的TLAB，则可能会有大量的对象分配使用不了TLAB而降级到\n避免慢的慢速分配，如果轻易就更换新的TLAB，则之前的TLAB中剩余的内存就浪费了，所以要在分配速度和内存浪费之间取得一个权衡，在jdk中\n能够通过参数控制浪费的比例并且有自动调节机制。")]),a._v(" "),e("h2",{attrs:{id:"tlab的配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tlab的配置"}},[a._v("#")]),a._v(" TLAB的配置")]),a._v(" "),e("p",[a._v("TLAB相关的配置可以通过"),e("code",[a._v("java -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version | grep 'TLAB'")]),a._v("\n命令查看。")]),a._v(" "),e("p",[a._v("ResizeTLAB")]),a._v(" "),e("h2",{attrs:{id:"tlab的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tlab的实现"}},[a._v("#")]),a._v(" TLAB的实现")]),a._v(" "),e("h3",{attrs:{id:"usetlab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usetlab"}},[a._v("#")]),a._v(" UseTLAB")]),a._v(" "),e("p",[a._v("是否使用TLAB，默认为true。对于大多数应用，也不建议关闭。")]),a._v(" "),e("h3",{attrs:{id:"resizetlab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#resizetlab"}},[a._v("#")]),a._v(" ResizeTLAB")]),a._v(" "),e("p",[a._v("是否动态调整TLAB的大小，默认为true。一般也不建议关闭，因为如果关闭，TLAB的大小固定，很考验TLAB大小的设置，而不能利用自动调整\n机制中分配效率和内存浪费间进行权衡。")]),a._v(" "),e("h3",{attrs:{id:"mintlabsize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mintlabsize"}},[a._v("#")]),a._v(" MinTLABSize")]),a._v(" "),e("p",[a._v("TLAB的最小的大小，单位是bytes，默认2k。")]),a._v(" "),e("h3",{attrs:{id:"tlabsize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tlabsize"}},[a._v("#")]),a._v(" TLABSize")]),a._v(" "),e("p",[a._v("初始时TLAB的大小，默认值0，则")]),a._v(" "),e("p",[a._v("TLAB size size change")]),a._v(" "),e("p",[a._v("jvm word是什么含义")]),a._v(" "),e("p",[a._v("dummy object\n_word_size\nretire\nrefill\ninside tlab\noutside tlab\nslow alloc\nfast alloc")]),a._v(" "),e("p",[a._v("TLAB保存、gc回收")]),a._v(" "),e("p",[a._v("和GC的关系")]),a._v(" "),e("p",[a._v("浪费的数量")]),a._v(" "),e("h3",{attrs:{id:"关键概念、流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键概念、流程"}},[a._v("#")]),a._v(" 关键概念、流程")]),a._v(" "),e("p",[a._v("对象内存分配过程")]),a._v(" "),e("p",[a._v("collectedHeap.inline.hpp中定义了在heap中创建对象申请内存的方法")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("inline oop CollectedHeap::obj_allocate(Klass* klass, size_t size, TRAPS) {\n  ObjAllocator allocator(klass, size, THREAD);\n  return allocator.allocate();\n}\n\ninline oop CollectedHeap::array_allocate(Klass* klass, size_t size, int length, bool do_zero, TRAPS) {\n  ObjArrayAllocator allocator(klass, size, length, do_zero, THREAD);\n  return allocator.allocate();\n}\n\ninline oop CollectedHeap::class_allocate(Klass* klass, size_t size, TRAPS) {\n  ClassAllocator allocator(klass, size, THREAD);\n  return allocator.allocate();\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br")])]),e("p",[a._v("ObjAllocator等都继承与MemAllocator，调用memAllocator.cpp中的allocate方法负责创建对象\nmem_allocate方法判断如果启用了UseTLAB，先调用allocate_inside_tlab尝试中tlab中申请，\n如果申请失败，调用allocate_outside_tlab中tlab之外申请。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("oop MemAllocator::allocate() const {\n  oop obj = NULL;\n  {\n    Allocation allocation(*this, &obj);\n    HeapWord* mem = mem_allocate(allocation);\n    if (mem != NULL) {\n      obj = initialize(mem);\n    } else {\n      // The unhandled oop detector will poison local variable obj,\n      // so reset it to NULL if mem is NULL.\n      obj = NULL;\n    }\n  }\n  return obj;\n}\nHeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n  if (UseTLAB) {\n    HeapWord* result = allocate_inside_tlab(allocation);\n    if (result != NULL) {\n      return result;\n    }\n  }\n\n  return allocate_outside_tlab(allocation);\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br")])]),e("p",[a._v("allocate_inside_tlab方法先调用allocate_inside_tlab_fast尝试中当前tlab申请进行分配，\n如果当前tlab剩余空间无法容纳要分配的对象大小，则返回NULL，否则分配成功返回。\n分配失败后调用allocate_inside_tlab_slow，判断下是否可以更换当前的tlab，更换一块新的tlab内存，\n如果更换成功，在新的里面分配对象，否则返回NULL。")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('HeapWord* MemAllocator::allocate_inside_tlab(Allocation&amp; allocation) const {\n  assert(UseTLAB, "should use UseTLAB");\n\n  // Try allocating from an existing TLAB.\n  HeapWord* mem = allocate_inside_tlab_fast();\n  if (mem != NULL) {\n    return mem;\n  }\n\n  // Try refilling the TLAB and allocating the object in it.\n  return allocate_inside_tlab_slow(allocation);\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br")])]),e("p",[a._v("allocate_inside_tlab_fast调用的是ThreadLocalAllocBuffer的allocate方法")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("HeapWord* MemAllocator::allocate_inside_tlab_fast() const {\n  return _thread->tlab().allocate(_word_size);\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("threadLocalAllocBuffer.inline.hpp中定义了allocate的实现，判断当前\nend和top之间的差也就是当前剩余的内存空间，是否大于等于size，即能否放下新对象，\n如果放不下，返回NULL。如果可以，则向分配中的空间填充badHeapWordVal（header不会填充），然后更新top值（加上size）。")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("inline HeapWord* ThreadLocalAllocBuffer::allocate(size_t size) {\n  invariants();\n  HeapWord* obj = top();\n  if (pointer_delta(end(), obj) >= size) {\n    // successful thread-local allocation\n#ifdef ASSERT\n    // Skip mangling the space corresponding to the object header to\n    // ensure that the returned space is not considered parsable by\n    // any concurrent GC thread.\n    size_t hdr_size = oopDesc::header_size();\n    Copy::fill_to_words(obj + hdr_size, size - hdr_size, badHeapWordVal);\n#endif // ASSERT\n    // This addition is safe because we know that top is\n    // at least size below end, so the add can't wrap.\n    set_top(obj + size);\n\n    invariants();\n    return obj;\n  }\n  return NULL;\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br")])]),e("p",[a._v("allocate_inside_tlab_slow方法负责中tlab_fast失败之后（即当前剩余空间不够分配新对象），判断是否要替换tlab。\nshould_post_sampled_object_alloc负责处理jvmti的sample逻辑，我们暂时不用关心。\n然后回判断tlab.free()是否大于tlab.refill_waste_limit()，refill_waste_limit是\n当前更换tlab允许浪费的内存的一个limit限制，小于等于它才能替换tlab，否则直接返回NULL，refill_waste_limit值也会动态调整稍后讲到。\n如果free小于等于refill_waste_limit，则通过"),e("code",[a._v("tlab.compute_size(_word_size)")]),a._v("计算下一个要创建的tlab的大小\n然后通过Universe::heap()->allocate_new_tlab创建新的tlab，然后在新的tlab中给对象分配内存并返回。")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation&amp; allocation) const {\n  HeapWord* mem = NULL;\n  ThreadLocalAllocBuffer&amp; tlab = _thread->tlab();\n\n  if (JvmtiExport::should_post_sampled_object_alloc()) {\n    tlab.set_back_allocation_end();\n    mem = tlab.allocate(_word_size);\n\n    // We set back the allocation sample point to try to allocate this, reset it\n    // when done.\n    allocation._tlab_end_reset_for_sample = true;\n\n    if (mem != NULL) {\n      return mem;\n    }\n  }\n\n  // Retain tlab and allocate object in shared space if\n  // the amount free in the tlab is too large to discard.\n  if (tlab.free() > tlab.refill_waste_limit()) {\n    tlab.record_slow_allocation(_word_size);\n    return NULL;\n  }\n\n  // Discard tlab and allocate a new one.\n  // To minimize fragmentation, the last TLAB may be smaller than the rest.\n  size_t new_tlab_size = tlab.compute_size(_word_size);\n\n  tlab.retire_before_allocation();\n\n  if (new_tlab_size == 0) {\n    return NULL;\n  }\n\n  // Allocate a new TLAB requesting new_tlab_size. Any size\n  // between minimal and new_tlab_size is accepted.\n  size_t min_tlab_size = ThreadLocalAllocBuffer::compute_min_size(_word_size);\n  mem = Universe::heap()->allocate_new_tlab(min_tlab_size, new_tlab_size, &amp;allocation._allocated_tlab_size);\n  if (mem == NULL) {\n    assert(allocation._allocated_tlab_size == 0,\n           "Allocation failed, but actual size was updated. min: " SIZE_FORMAT\n           ", desired: " SIZE_FORMAT ", actual: " SIZE_FORMAT,\n           min_tlab_size, new_tlab_size, allocation._allocated_tlab_size);\n    return NULL;\n  }\n  assert(allocation._allocated_tlab_size != 0, "Allocation succeeded but actual size not updated. mem at: "\n         PTR_FORMAT " min: " SIZE_FORMAT ", desired: " SIZE_FORMAT,\n         p2i(mem), min_tlab_size, new_tlab_size);\n\n  if (ZeroTLAB) {\n    // ..and clear it.\n    Copy::zero_to_words(mem, allocation._allocated_tlab_size);\n  } else {\n    // ...and zap just allocated object.\n#ifdef ASSERT\n    // Skip mangling the space corresponding to the object header to\n    // ensure that the returned space is not considered parsable by\n    // any concurrent GC thread.\n    size_t hdr_size = oopDesc::header_size();\n    Copy::fill_to_words(mem + hdr_size, allocation._allocated_tlab_size - hdr_size, badHeapWordVal);\n#endif // ASSERT\n  }\n\n  tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);\n  return mem;\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br"),e("span",{staticClass:"line-number"},[a._v("30")]),e("br"),e("span",{staticClass:"line-number"},[a._v("31")]),e("br"),e("span",{staticClass:"line-number"},[a._v("32")]),e("br"),e("span",{staticClass:"line-number"},[a._v("33")]),e("br"),e("span",{staticClass:"line-number"},[a._v("34")]),e("br"),e("span",{staticClass:"line-number"},[a._v("35")]),e("br"),e("span",{staticClass:"line-number"},[a._v("36")]),e("br"),e("span",{staticClass:"line-number"},[a._v("37")]),e("br"),e("span",{staticClass:"line-number"},[a._v("38")]),e("br"),e("span",{staticClass:"line-number"},[a._v("39")]),e("br"),e("span",{staticClass:"line-number"},[a._v("40")]),e("br"),e("span",{staticClass:"line-number"},[a._v("41")]),e("br"),e("span",{staticClass:"line-number"},[a._v("42")]),e("br"),e("span",{staticClass:"line-number"},[a._v("43")]),e("br"),e("span",{staticClass:"line-number"},[a._v("44")]),e("br"),e("span",{staticClass:"line-number"},[a._v("45")]),e("br"),e("span",{staticClass:"line-number"},[a._v("46")]),e("br"),e("span",{staticClass:"line-number"},[a._v("47")]),e("br"),e("span",{staticClass:"line-number"},[a._v("48")]),e("br"),e("span",{staticClass:"line-number"},[a._v("49")]),e("br"),e("span",{staticClass:"line-number"},[a._v("50")]),e("br"),e("span",{staticClass:"line-number"},[a._v("51")]),e("br"),e("span",{staticClass:"line-number"},[a._v("52")]),e("br"),e("span",{staticClass:"line-number"},[a._v("53")]),e("br"),e("span",{staticClass:"line-number"},[a._v("54")]),e("br"),e("span",{staticClass:"line-number"},[a._v("55")]),e("br"),e("span",{staticClass:"line-number"},[a._v("56")]),e("br"),e("span",{staticClass:"line-number"},[a._v("57")]),e("br"),e("span",{staticClass:"line-number"},[a._v("58")]),e("br"),e("span",{staticClass:"line-number"},[a._v("59")]),e("br"),e("span",{staticClass:"line-number"},[a._v("60")]),e("br"),e("span",{staticClass:"line-number"},[a._v("61")]),e("br"),e("span",{staticClass:"line-number"},[a._v("62")]),e("br"),e("span",{staticClass:"line-number"},[a._v("63")]),e("br"),e("span",{staticClass:"line-number"},[a._v("64")]),e("br"),e("span",{staticClass:"line-number"},[a._v("65")]),e("br"),e("span",{staticClass:"line-number"},[a._v("66")]),e("br")])]),e("p",[a._v("在tlab.free()>tlab.refill_waste_limit()时，会调用record_slow_allocation调整refill_waste_limit并统计_slow_acclocations，\n每次slow allocation（即tlab无法分配新对象的空间且free > refill_waste_limit），则给refill_waste_limit加上refill_waste_limit_increment。\n避免TLAB出现卡在这里一直走out of TLAB的情况。")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('void ThreadLocalAllocBuffer::record_slow_allocation(size_t obj_size) {\n  // Raise size required to bypass TLAB next time. Why? Else there\'s\n  // a risk that a thread that repeatedly allocates objects of one\n  // size will get stuck on this slow path.\n\n  set_refill_waste_limit(refill_waste_limit() + refill_waste_limit_increment());\n\n  _slow_allocations++;\n\n  log_develop_trace(gc, tlab)("TLAB: %s thread: " INTPTR_FORMAT " [id: %2d]"\n                              " obj: " SIZE_FORMAT\n                              " free: " SIZE_FORMAT\n                              " waste: " SIZE_FORMAT,\n                              "slow", p2i(thread()), thread()->osthread()->thread_id(),\n                              obj_size, free(), refill_waste_limit());\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br")])]),e("p",[a._v("allocate_inside_tlab返回为NULL的时候，会调用allocate_outside_tlab在tlab之外分配内存。")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("HeapWord* MemAllocator::mem_allocate(Allocation&amp; allocation) const {\n  if (UseTLAB) {\n    HeapWord* result = allocate_inside_tlab(allocation);\n    if (result != NULL) {\n      return result;\n    }\n  }\n\n  return allocate_outside_tlab(allocation);\n}\n\nHeapWord* MemAllocator::allocate_outside_tlab(Allocation&amp; allocation) const {\n  allocation._allocated_outside_tlab = true;\n  HeapWord* mem = Universe::heap()->mem_allocate(_word_size, &amp;allocation._overhead_limit_exceeded);\n  if (mem == NULL) {\n    return mem;\n  }\n\n  NOT_PRODUCT(Universe::heap()->check_for_non_bad_heap_word_value(mem, _word_size));\n  size_t size_in_bytes = _word_size * HeapWordSize;\n  _thread->incr_allocated_bytes(size_in_bytes);\n\n  return mem;\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br")])]),e("p",[a._v("mem_allocate方法是在堆内存中分配内存的方法，对于g1的实现在G1CollectedHeap.cpp中，会先判断是否是Humongous巨型对象，\n如果是进行巨型对象分配，巨型对象单独占用若干块连续region")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("HeapWord*\nG1CollectedHeap::mem_allocate(size_t word_size,\n                              bool*  gc_overhead_limit_was_exceeded) {\n  assert_heap_not_locked_and_not_at_safepoint();\n\n  if (is_humongous(word_size)) {\n    return attempt_allocation_humongous(word_size);\n  }\n  size_t dummy = 0;\n  return attempt_allocation(word_size, word_size, &amp;dummy);\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br")])]),e("p",[a._v("普通对象的分配，最终会调用到heapRegion.inline.hpp中，par_allocate_impl方法中会通过cas top指针的方式分配内存。")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('inline HeapWord* HeapRegion::par_allocate_impl(size_t min_word_size,\n                                               size_t desired_word_size,\n                                               size_t* actual_size) {\n  do {\n    HeapWord* obj = top();\n    size_t available = pointer_delta(end(), obj);\n    size_t want_to_allocate = MIN2(available, desired_word_size);\n    if (want_to_allocate >= min_word_size) {\n      HeapWord* new_top = obj + want_to_allocate;\n      HeapWord* result = Atomic::cmpxchg(&amp;_top, obj, new_top);\n      // result can be one of two:\n      //  the old top value: the exchange succeeded\n      //  otherwise: the new value of the top is returned.\n      if (result == obj) {\n        assert(is_object_aligned(obj) &amp;&amp; is_object_aligned(new_top), "checking alignment");\n        *actual_size = want_to_allocate;\n        return obj;\n      }\n    } else {\n      return NULL;\n    }\n  } while (true);\n}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br")])]),e("h3",{attrs:{id:"关于tlab的大小size的计算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于tlab的大小size的计算"}},[a._v("#")]),a._v(" 关于TLAB的大小size的计算")]),a._v(" "),e("p",[a._v("TLAB可以理解为线程每次从eden中获取的批量内存大小。为了在内存利用率和n")]),a._v(" "),e("h3",{attrs:{id:"tlab结构定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tlab结构定义"}},[a._v("#")]),a._v(" TLAB结构定义")]),a._v(" "),e("p",[a._v("_start: 当前TLAB的地址起始位置\n_top: 当前内存分配已经使用到的地方\n_pf_top: prefetch watermark\n_end: 当前TLAB的地址结束位置\n_allocation_end: 当前TLAB的地址结束位置\n_desired_size: 目标大小\n_refill_waste_limit: refill时waste的limit\n_allocated_before_last_gc:\n_bytes_since_last_sample_point:")]),a._v(" "),e("p",[a._v("_max_size: TLAB的最大大小\n_reserve_for_allocation_prefetch:\n_target_refills:")]),a._v(" "),e("p",[a._v("_number_of_refills:\n_refill_waste:\n_gc_waste:\n_slow_allocations:\n_allocated_size:\n_allocation_fraction: 在eden分配内存时，分配中TLAB中的比例")]),a._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class ThreadLocalAllocBuffer: public CHeapObj&lt;mtThread> {\n  friend class VMStructs;\n  friend class JVMCIVMStructs;\nprivate:\n  HeapWord* _start;                              // address of TLAB\n  HeapWord* _top;                                // address after last allocation\n  HeapWord* _pf_top;                             // allocation prefetch watermark\n  HeapWord* _end;                                // allocation end (can be the sampling end point or _allocation_end)\n  HeapWord* _allocation_end;                     // end for allocations (actual TLAB end, excluding alignment_reserve)\n\n  size_t    _desired_size;                       // desired size   (including alignment_reserve)\n  size_t    _refill_waste_limit;                 // hold onto tlab if free() is larger than this\n  size_t    _allocated_before_last_gc;           // total bytes allocated up until the last gc\n  size_t    _bytes_since_last_sample_point;      // bytes since last sample point.\n\n  static size_t   _max_size;                          // maximum size of any TLAB\n  static int      _reserve_for_allocation_prefetch;   // Reserve at the end of the TLAB\n  static unsigned _target_refills;                    // expected number of refills between GCs\n\n  unsigned  _number_of_refills;\n  unsigned  _refill_waste;\n  unsigned  _gc_waste;\n  unsigned  _slow_allocations;\n  size_t    _allocated_size;\n\n  AdaptiveWeightedAverage _allocation_fraction;  // fraction of eden allocated in tlabs\n\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br")])]),e("h3",{attrs:{id:"init-size"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#init-size"}},[a._v("#")]),a._v(" init size")]),a._v(" "),e("h3",{attrs:{id:"max-size"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#max-size"}},[a._v("#")]),a._v(" max size")]),a._v(" "),e("h3",{attrs:{id:"resize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#resize"}},[a._v("#")]),a._v(" resize")]),a._v(" "),e("h3",{attrs:{id:"tlab-log查看"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tlab-log查看"}},[a._v("#")]),a._v(" TLAB log查看")]),a._v(" "),e("h3",{attrs:{id:"通过jfr监控tlab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过jfr监控tlab"}},[a._v("#")]),a._v(" 通过JFR监控TLAB")]),a._v(" "),e("h3",{attrs:{id:"通过perf监控tlab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过perf监控tlab"}},[a._v("#")]),a._v(" 通过perf监控TLAB")]),a._v(" "),e("h2",{attrs:{id:"plab"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#plab"}},[a._v("#")]),a._v(" PLAB")]),a._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("h2",{attrs:{id:"其他参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他参考"}},[a._v("#")]),a._v(" 其他参考")])])}),[],!1,null,null,null);s.default=t.exports}}]);