<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>AQS详解 | bytejava Java进阶手册</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <script charset="utf-8" async="async" src="/js/jquery.min.js"></script>
    <script charset="utf-8" async="async" src="/js/global.js"></script>
    <script charset="utf-8" async="async" src="/js/fingerprint2.min.js"></script>
    <script charset="utf-8" async="async" src="https://s9.cnzz.com/z_stat.php?id=12782949&amp;web_id=1272949"></script>
    <script>
              var _hmt = _hmt || [];
              (function() {
                var hm = document.createElement("script");
                hm.src = "https://hm.baidu.com/hm.js?fa0fbf0fef3bba94118b912a64766cee";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
              })();
            </script>
    <meta name="description" content="包含: Java 基础，高并发缓存，JVM，中间件，字节码编程...">
    <meta property="og:title" content="AQS详解">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/md/java/basic/AbstractQueuedSynchronizer.html">
    <meta name="twitter:title" content="AQS详解">
    <meta name="twitter:url" content="/md/java/basic/AbstractQueuedSynchronizer.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="robots" content="all">
    <meta name="author" content="bytejava">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="keywords" content="bytejava 高级Java，Java设计模式, 字节码编程, 中间件, Spring, Java基础, 面经手册">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <link rel="preload" href="/assets/css/0.styles.8fb5e8ac.css" as="style"><link rel="preload" href="/assets/css/styles.css?v=1729221831211" as="style"><link rel="preload" href="/assets/js/cg-styles.js?v=1729221831211" as="script"><link rel="preload" href="/assets/js/cg-app.js?v=1729221831211" as="script"><link rel="preload" href="/assets/js/cg-4.js?v=1729221831211" as="script"><link rel="preload" href="/assets/js/cg-3.js?v=1729221831211" as="script"><link rel="preload" href="/assets/js/cg-111.js?v=1729221831211" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8fb5e8ac.css"><link rel="stylesheet" href="/assets/css/styles.css?v=1729221831211">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">bytejava Java进阶手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/java/basic/java线程池.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/md/java/compiler/javac.html" class="nav-link">
  Java编译器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JVM" class="dropdown-title"><span class="title">JVM</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/jvm/bytecode/class字节码文件格式.html" class="nav-link">
  字节码
</a></li><li class="dropdown-item"><!----> <a href="/md/jvm/jvm/javaagent.html" class="nav-link">
  jvm
</a></li><li class="dropdown-item"><!----> <a href="/md/jvm/jvmti/jvmti介绍和开发.html" class="nav-link">
  jvmti
</a></li><li class="dropdown-item"><!----> <a href="/md/jvm/gc/g1/g1-all-intro.html" class="nav-link">
  G1 GC
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="缓存" class="dropdown-title"><span class="title">缓存</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/cache/redis/redis.html" class="nav-link">
  零基础到高并发应用专家，深入理解redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><span class="title">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/spring/springboot启动请求处理过程.html" class="nav-link">
  Spring实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Kafka" class="dropdown-title"><span class="title">Kafka</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/kafka/kafka.html" class="nav-link">
  kafka
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MyBatis" class="dropdown-title"><span class="title">MyBatis</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/mybatis/mybatis-use-general.html" class="nav-link">
  MyBatis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="业务开发" class="dropdown-title"><span class="title">业务开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/develop/" class="nav-link">
  业务开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><span class="title">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/distribute/raft.html" class="nav-link">
  raft
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/algorithm/leetcode.html" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软技能通用技能" class="dropdown-title"><span class="title">软技能通用技能</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/soft/晋升答辩.html" class="nav-link">
  晋升答辩
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专栏" class="dropdown-title"><span class="title">专栏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/column/column.html" class="nav-link">
  订阅我的专栏
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/liuzhengyang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/java/basic/java线程池.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/md/java/compiler/javac.html" class="nav-link">
  Java编译器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JVM" class="dropdown-title"><span class="title">JVM</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/jvm/bytecode/class字节码文件格式.html" class="nav-link">
  字节码
</a></li><li class="dropdown-item"><!----> <a href="/md/jvm/jvm/javaagent.html" class="nav-link">
  jvm
</a></li><li class="dropdown-item"><!----> <a href="/md/jvm/jvmti/jvmti介绍和开发.html" class="nav-link">
  jvmti
</a></li><li class="dropdown-item"><!----> <a href="/md/jvm/gc/g1/g1-all-intro.html" class="nav-link">
  G1 GC
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="缓存" class="dropdown-title"><span class="title">缓存</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/cache/redis/redis.html" class="nav-link">
  零基础到高并发应用专家，深入理解redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><span class="title">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/spring/springboot启动请求处理过程.html" class="nav-link">
  Spring实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Kafka" class="dropdown-title"><span class="title">Kafka</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/kafka/kafka.html" class="nav-link">
  kafka
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MyBatis" class="dropdown-title"><span class="title">MyBatis</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/mybatis/mybatis-use-general.html" class="nav-link">
  MyBatis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="业务开发" class="dropdown-title"><span class="title">业务开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/develop/" class="nav-link">
  业务开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><span class="title">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/distribute/raft.html" class="nav-link">
  raft
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/algorithm/leetcode.html" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软技能通用技能" class="dropdown-title"><span class="title">软技能通用技能</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/soft/晋升答辩.html" class="nav-link">
  晋升答辩
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专栏" class="dropdown-title"><span class="title">专栏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/column/column.html" class="nav-link">
  订阅我的专栏
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/liuzhengyang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/md/java/basic/java线程池.html" class="sidebar-link">ThreadPoolExecutor</a></li><li><a href="/md/java/basic/HashMap.html" class="sidebar-link">HashMap源码分析</a></li><li><a href="/md/java/basic/ConcurrentHashMap.html" class="sidebar-link">ConcurrentHashMap</a></li><li><a href="/md/java/basic/ThreadLocal.html" class="sidebar-link">ThreadLocal源码分析</a></li><li><a href="/md/java/basic/ArrayBlockingQueue阻塞队列.html" class="sidebar-link">ArrayBlockingQueue</a></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html" aria-current="page" class="active sidebar-link">AQS详解</a></li><li><a href="/md/java/basic/ReentrantLock.html" class="sidebar-link">ReentrantLock</a></li><li><a href="/md/java/basic/ReentrantReadWriteLock.html" class="sidebar-link">ReentrantReadWriteLock</a></li><li><a href="/md/java/basic/CountDownLatch.html" class="sidebar-link">CountDownLatch</a></li><li><a href="/md/java/basic/LongAdder.html" class="sidebar-link">高并发计数类LongAdder</a></li><li><a href="/md/java/basic/AtomicInteger.html" class="sidebar-link">AtomicInteger</a></li><li><a href="/md/java/basic/动态代理.html" class="sidebar-link">Java动态代理</a></li><li><a href="/md/java/basic/lambda.html" class="sidebar-link">lambda表达式实现原理分析</a></li><li><a href="/md/java/basic/why-lambda-final.html" class="sidebar-link">lambda中的final修饰符</a></li><li><a href="/md/java/basic/ThreadLocalRandom.html" class="sidebar-link">ThreadLocalRandom</a></li><li><a href="/md/java/basic/rate-limit.html" class="sidebar-link">rate limiter关于限速器所需要了解的知识</a></li></ul></section></li></ul> </aside> <div><main class="page"> <div class="theme-default-content content__default"><h1 id="aqs详解"><a href="#aqs详解" class="header-anchor">#</a> AQS详解</h1> <p>在解决并发问题时，开发者需要各种同步功能进行线程间的通信、协调、控制，比如信号量、锁、条件等待通知等等。
JDK提供了AQS作为实现这些同步器(synchronizer)的基础，jdk中的并发工具类比如ReentrantLock, Semaphore, CountDownLatch等都是使用AQS来实现各自的线程同步能力的。</p> <p>AQS因为方法命名比较抽象，导致很多朋友开始难以理解各个方法的作用、原理，不用担心，通过学习本文今天我们彻底掌握AQS。</p> <h2 id="aqs使用"><a href="#aqs使用" class="header-anchor">#</a> AQS使用</h2> <h2 id="aqs整体实现设计"><a href="#aqs整体实现设计" class="header-anchor">#</a> AQS整体实现设计</h2> <p>AQS把同步器的操作分成两个操作，分别是acquire获取和release释放。
acquire和release操作的对象是AQS中的state变量。</p> <p>比如对于锁来说，加锁对应acquire，释放锁对应release；对于Semaphore信号量来说，获取permit对应acquire，释放permit对应release。</p> <p>在实现具体的同步器时，需要实现tryAcquire和tryRelease。
tryAcquire定义了获取成功的定义，比如在ReentrantLock中，state为0表示未加锁，大于0表示已加锁, tryAcquire就需要定义如何操作state表示当前线程获得了锁。
AQS中state字段是一个volatile的int实例字段，AQS提供了get,set和compareAndSetState方法来查看修改state的值。对于一个简单的锁实现来说acquire实现就是从0的状态下cas成1说明acquire成功，
release就是把state设置为0，完善的锁实现还需要考虑重入、读写锁等功能，在后面会详细讲解。 tryRelease是释放时对state的修改。</p> <p><img alt="img.png" data-src="/assets/images/java/aqs/aqs-01.png" loading="lazy" class="lazy"></p> <p>AQS内部包含一个线程等待队列，若干个条件队列。</p> <p>线程等待队列中存放的是等待的线程，线程要等待去执行一些代码，但是没有满足条件。</p> <p>AQS把同步器的操作抽象等两个类型，一个是acquire获取，一个是release。acquire表示线程尝试获取某个资源，可能会被阻塞（比如加锁等），线程获取到之后
执行完自己的逻辑可以释放这个资源，也就是通过release，release可能能够使得在等待acquire的线程从挂起状态唤醒尝试重新获取。
如果一个线程acquire失败时，怎么处理呢？对于大部分的同步器来说，等待是一个很好的选择，等待到acquire成功，那么如何等待、如何唤醒、如何重新尝试acquire等
细节都是由AQS内部实现的。</p> <p>当acquire调用tryAcquire失败时，就会将线程封装成一个Node放到Node队列中，Node等待其他线程唤醒，已经acquire成功的线程负责在release时唤醒Node队列中等待的
Node，Node唤醒后会重新尝试tryAcquire，如果tryAcquire成功则出队，否则继续等待。</p> <p>让一个线程等待同步器，方法是将线程挂起，并将包含线程信息的Node通过cas追加到队列的尾部，保证并发场景下的原子性。</p> <p>让一个线程从同步器中释放，表示通过了同步器的条件，可以执行特定代码，方法是从队列中出队一个Node节点，把队列head指向下一个等待的线程Node，保证原子性。</p> <p>在独占锁这类场景中，同一时间只能有一个线程获取到锁(acquire)，但是在读写锁、Semaphore、CountDownLatch等场景是要支持同一时间多个线程同时能acquire成功的。
所以AQS提供了独占(exclusived)和共享(shared)两种模式。
默认的独占模式下acquire和release调用的尝试方法为tryAcquire和tryRelease，共享模式下acquire和release的尝试方法对应tryAcquireShared和tryReleaseShared。</p> <h3 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h3> <p>为了方便操作，AQS中有一个dummy头结点，这个头结点便于判断一个Node是否是第一个节点（通过prev==head判断能够和null区分开），
为了节省内存，初始状态下head和tail都为null，第一次入队时初始化，给head和tail指向一个dummy节点无意义的Node对象上。</p> <h3 id="队列原子操作"><a href="#队列原子操作" class="header-anchor">#</a> 队列原子操作</h3> <p>队列的基本操作包含入队、出队、遍历节点、删除节点。</p> <h4 id="入队"><a href="#入队" class="header-anchor">#</a> 入队</h4> <p>无并发场景下，给一个队列入队，只需要找到队尾的Node对象，然后将该对象的next指针指向新的队尾Node对象，然后将队尾指针指向新的队尾Node对象。
不过在并发场景下，入队操作中包含若干个子步骤，所以不能保证原子性，一般要解决这类问题需要加锁，但是AQS是实现锁的底层技术，不适合套娃（性能等方面考虑）。
所以AQS中入队采取了弱一致性策略，只保证tail指针的正确性，tail指针指向真正的队尾结点，入队操作是cas tail指针由旧队尾节点改为新节点，cas成功说明这个
新Node对象入队成功，否则需要重试。所以其他的一些条件会有可能不一致，比如队列中一个Node的next==null并不能保证这个Node节点是队尾节点。
AQS在入队前会给新tail的prev设置为旧的tail，所以prev!=null不能说明Node在队列中，但是prev==null说明Node一定不在队列中。
又因为next引用的不一致性，所以遍历队列需要从队尾向前遍历。</p> <p>入队时先设置prev再cas tail，能够保证在队列阻塞中的node一定能够被通知到（对于cancelled节点会通过cleanQueue来通知）
通知的实现机制是，被通知的线程先设置WAITING状态，然后重新尝试tryAcquire，然后再在blocking前重新检查status。进行通知的线程在unpark队列中阻塞的Node之前通过cas原子清理Node的WAITING状态。
具体的实现和原有后面会分析。</p> <p>first节点(head的next)acquire成功后需要出队，会把first节点作为新的Node节点。步骤是先把first节点的prev设置为null，然后再更新head引用。
所以head指向一个对象并不能保证这个Node在AQS队列中，因为出队是先修改first节点的prev，再更新的head引用，Node的prev==null是可以说明这个Node是head节点的。</p> <p>在队列中等待的节点，它的前继节点(predecessor、prev)在等待过程中可能会变化，因为prev节点可能会因为超时或中断变成CANCELLED然后被清理。
除非节点已经变成first节点，head不会cancel。acquire方法中会在进入WAITING挂起前检查一下pred的status，如果是CANCELLED，则会cleanQueue清理队列。</p> <p>在cleanQueue中，会对找到的CANCELLED节点的前后节点的prev和next字段通过cas进行修改，一个线程成功cas修改prev后，其他线程可以帮忙cas修改next。
每次调用cleanQueue方法，都会不断遍历队列直到队列清理完成。如果清理之后Node变成了first节点，则一定调用unpark避免出现前继节点cancelled导致节点没有唤醒的边界情况。</p> <p>插队问题: 即使线程位于first节点，也不能保证在acquire时一定acquire成功，因为有可能有其他线程调用acquire时，会先tryAcquire而不是先入队，所以可能有插队问题，这是为了
提升整体的吞吐率考虑的，因为有可能在first唤醒到tryAcquire成功之间，另一个线程已经完成了acquire和release，提升了吞吐。
发生了插队导致first节点tryAcquire失败的，first节点还需要继续等待，为了避免first节点长期抢不到tryAcquire，first节点会尝试穿插自旋等待和tryAcquire重试，重试一定次数后再park，每次park前增加重试次数最大127，超过之后不再park一直重试。</p> <p>为了提升GC效率，从队列中出队的Node的字段都会设置为null。这会让getFirstQueuedThread稍微复杂，在实现过程中如果出现了数据不一致情况，则会从tail开始遍历。</p> <p>队列需要一个dummy header node节点，但是为了节省内存空间，head和tail在第一次出现tryAcquire竞争（有线程tryAcquire失败）后才会创建head和tail节点。</p> <p>shared模式和exclusive模式的区别是，一个node acquire成功后，如果next节点也是shared节点，会继续signal这个节点让它也唤醒尝试tryAcquire而不需要等待release才signal。</p> <p>每个条件对象中存在一个条件队列，条件队列不需要支持并发，因为条件队列只在exclusive模式下使用，也就是同一时间只有一个线程能访问修改队列。
线程要在条件上等待时，会将node入队到条件队列中，signal的时候，node会从条件队列转移到AQS等待队列。</p> <p>Node类中的head,tail,state字段使用volatile声明，并且使用Unsafe类的cas等方法进行访问修改。
waiter字段没有使用volatile声明，因为waiter字段总是在其他的volatile字段读写之间使用，能够利用jmm规则保证可见性。</p> <h2 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h2> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>

<span class="token comment">/**
 * Tail of the wait queue. After initialization, modified only via casTail.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>

<span class="token comment">/**
 * The synchronization state.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Node定义了几个volatile字段, 并且提供了常用的cas、get、set方法。</p> <p>waiter为什么不是volatile字段呢？因为waiter线程字段只会在入队时设置一次，并且在其他字段的volatile写之前写入，在其他volatile字段之后读取从而保证可见性。</p> <p>Node中的setPrevRelaxed、setStatusRelaxed等方法，没有使用volatile语义，而是在使用时通过调用前后其他字段的volatile读写的happen-before语义保证可见性，降低内存屏障的使用提高性能。</p> <p>比如以acquire方法中入队的步骤为例。
对于一个线程来说，执行acquire方法时，按照Java内存模型(Java Memory Model)，代码的先后顺序在线程内符合happen-before原则，
所以setPrevRelaxed happen before与casTail，又因为casTail是Unsafe.compareAndSetReference，保证tail引用的volatile读写语义，
happen before与之后其他线程的tail读，所以，这里的setPrevRelaxed设置prev引用也happen before与之后其他线程的tail读。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>node<span class="token punctuation">.</span><span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// avoid unnecessary fence</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token function">tryInitializeHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>
    node<span class="token punctuation">.</span><span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// back out</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>其他线程在读取tail后happen before与之后的读取prev，也就能推断出写入prev happen before与读取prev</p> <p>比如getQueuedThreads方法，会先读取tail，再读取tail Node的prev，就能保证写入prev happen before与读取prev，也就能保证可见性。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> p <span class="token operator">=</span> tail<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> p<span class="token punctuation">.</span>waiter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>       <span class="token comment">// initially attached via casTail</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>       <span class="token comment">// visibly nonnull when signallable</span>
    <span class="token class-name">Thread</span> waiter<span class="token punctuation">;</span>            <span class="token comment">// visibly nonnull when enqueued</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>      <span class="token comment">// written by owner, atomic bit ops by others</span>

    <span class="token comment">// methods for atomic operations</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">casPrev</span><span class="token punctuation">(</span><span class="token class-name">Node</span> c<span class="token punctuation">,</span> <span class="token class-name">Node</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// for cleanQueue</span>
        <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">weakCompareAndSetReference</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> PREV<span class="token punctuation">,</span> c<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">casNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span> c<span class="token punctuation">,</span> <span class="token class-name">Node</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// for cleanQueue</span>
        <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">weakCompareAndSetReference</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> NEXT<span class="token punctuation">,</span> c<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndUnsetStatus</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// for signalling</span>
        <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getAndBitwiseAndInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> STATUS<span class="token punctuation">,</span> <span class="token operator">~</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span><span class="token class-name">Node</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// for off-queue assignment</span>
        <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">putReference</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> PREV<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setStatusRelaxed</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// for off-queue assignment</span>
        <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> STATUS<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">clearStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment">// for reducing unneeded signals</span>
        <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">putIntOpaque</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> STATUS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> STATUS
        <span class="token operator">=</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;status&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> NEXT
        <span class="token operator">=</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;next&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> PREV
        <span class="token operator">=</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;prev&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>Node的status有几种状态</p> <p>Node的status默认为0，WAITING(1) 表示Node在队列中等待唤醒，COND(2)表示条件等待，
WAITING和COND作为标记位使用，所以status也可以同时是WAITING和COND状态（状态是3），用bit判断是否是WAITING和COND。
如果Node因为超时或中断，需要取消，Node的状态是CANCELLED(0x80000000)是负数。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Node status bits, also used as argument and return values</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> WAITING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// must be 1</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span> <span class="token comment">// must be negative</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COND      <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment">// in a condition wait</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">{</span>

    <span class="token comment">// Concrete classes tagged by type</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ExclusiveNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SharedNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ConditionNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span>
        <span class="token keyword">implements</span> <span class="token class-name">ForkJoinPool<span class="token punctuation">.</span>ManagedBlocker</span> <span class="token punctuation">{</span>
        <span class="token class-name">ConditionNode</span> nextWaiter<span class="token punctuation">;</span>            <span class="token comment">// link to next waiting node</span>

        <span class="token comment">/**
         * Allows Conditions to be used in ForkJoinPools without
         * risking fixed pool exhaustion. This is usable only for
         * untimed Condition waits, not timed versions.
         */</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> status <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="aqs实现"><a href="#aqs实现" class="header-anchor">#</a> AQS实现</h2> <h3 id="acquire"><a href="#acquire" class="header-anchor">#</a> acquire</h3> <p>acquire方法将JDK8中的acquireQueued、doAcquireNanos、doAcquireShared等各种版本的acquire逻辑统一起来，减少重复代码。</p> <p>acquire方法参数</p> <p>node: 只有Condition条件下不是null，其他情况都是null
arg: acquire的参数
shared: 是shared模式还是exclusive模式
interruptible: 是否能响应中断
timed: 如果是true，会使用time参数作为超时时间实现超时
time: 超时时间，单位纳秒</p> <p>方法的返回值</p> <p>如果acquire成功返回正数
如果acquire超时返回0
如果被interrupt返回负数</p> <p>acquire执行的过程中，在多种情况下都会调用tryAcquire，最后都不成功的情况下才设置WAITING状态等待，让线程进入等待状态一会再唤醒是一个相对比较重的操作。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">boolean</span> shared<span class="token punctuation">,</span>
                      <span class="token keyword">boolean</span> interruptible<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">byte</span> spins <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> postSpins <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// retries upon unpark of first thread</span>
    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> first <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> pred <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// predecessor of node when enqueued</span>

    <span class="token comment">/*
     * Repeatedly:
     *  Check if node now first
     *    if so, ensure head stable, else ensure valid predecessor
     *  if node is first or not yet enqueued, try acquiring
     *  else if node not yet created, create it
     *  else if not yet enqueued, try once to enqueue
     *  else if woken from park, retry (up to postSpins times)
     *  else if WAITING status not set, set and retry
     *  else park and clear WAITING status, and check cancellation
     */</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果first为false（初始值为false)，给pred赋值，值为 null或node.prev，如果pred != null</span>
        <span class="token comment">// 再判断下pred是不是head节点，如果pred是head，赋值first = true, 如果first还是false，进入if</span>
        <span class="token comment">// first赋值为true，只会出现在pred != null的前提下，pred != null说明node != null, 也能推断出来 head != null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>first <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pred <span class="token operator">=</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span><span class="token punctuation">(</span>first <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">cleanQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// predecessor cancelled</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">onSpinWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ensure serialization</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果是first，或者pred是null（node参数传入的null的情况下)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">||</span> pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> acquired<span class="token punctuation">;</span>
            <span class="token comment">// 先快速调用一下tryAcquireShared或tryAcquire尝试修改AQS state状态，如果tryAcquire成功，则不需要入队。</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>shared<span class="token punctuation">)</span>
                    <span class="token comment">// shared模式调用tryAcquireShared</span>
                    acquired <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    <span class="token comment">// 如果不是shared，那就是exclusive mode，调用tryAcquire</span>
                    acquired <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 出现异常调用cancelAcquire</span>
                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> interrupted<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>acquired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// first说明node不为null，pred == head，则需要清理node.prev引用也就是head（避免再遍历到旧head)，把当前的node作为新的head，</span>
                <span class="token comment">// 如果不是first，说明当前线程还没有入队，则不需要修改队列状态 </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    head <span class="token operator">=</span> node<span class="token punctuation">;</span>
                    pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    node<span class="token punctuation">.</span>waiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token comment">// shared模式下，后面的node也有可能acquire成功，需要signal</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>shared<span class="token punctuation">)</span>
                        <span class="token function">signalNextIfShared</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 判断下interrupted状态，如果被interrupted了，调用线程current.interrupt()方法设置中断状态</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>
                        current<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 走到这里，说明Node</span>
        <span class="token comment">// 如果node为空，需要创建Node并加入队列</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment">// allocate; retry before enqueue</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>shared<span class="token punctuation">)</span>
                <span class="token comment">// shared模式创建SharedNode类对象</span>
                node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token comment">// exclusive模式创建ExclusiveNode类对象</span>
                node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExclusiveNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 创建完node后，会从头开始执行if，后面会走到pred == null的 else if判断里</span>
            <span class="token comment">// 没有设置status、prev，是为了能够再次tryAcquire</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// try to enqueue</span>
            <span class="token comment">// pred == null，说明不在队列中</span>
            node<span class="token punctuation">.</span>waiter <span class="token operator">=</span> current<span class="token punctuation">;</span>
            <span class="token comment">// 获取当前tail引用</span>
            <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
            <span class="token comment">// 先设置prev为当前的tail, TODO: 解释为什么可以用releaxed，而不是volatile语义等方法，利用happen before规则</span>
            node<span class="token punctuation">.</span><span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// avoid unnecessary fence</span>
            <span class="token comment">// 如果tail为null，说明队列是空的，调用tryInitializeHead通过cas的方式初始化队列，设置dummy head（同时也是tail）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token function">tryInitializeHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果tail不为null，则通过cas修改tail引用为当前的新node，cas tail成功表示入队成功，否则重试</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 没有入队成功，清理prev引用</span>
                node<span class="token punctuation">.</span><span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// back out </span>
            <span class="token keyword">else</span>
                <span class="token comment">// cas tail 入队成功，修改oldTail的next引用到新的tail</span>
                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token comment">// 入队后依然没有设置成WAITING状态，目的是再给一次循环判断的机会，如果现在Node处于头结点了，并且tryAcquire成功，则acquire成功，否则再降级到WAITING</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">&amp;&amp;</span> spins <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 头结点的情况，使用自旋等待，自旋通过短暂的wait实现</span>
            <span class="token comment">// 如果是头结点，并且spins不为0，则spins减一，并且调用Thread.onSpinWait()方法</span>
            <span class="token operator">--</span>spins<span class="token punctuation">;</span>                        <span class="token comment">// reduce unfairness on rewaits</span>
            <span class="token comment">// Thread.onSpinWait()方法用于此类自旋等待场景，但是当前的线程还不能继续，所以调用短暂的wait等待，运行时可以进行性能优化。</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">onSpinWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果status=0，修改状态为WAITING状态，这样node可以接收signalNext/signalNextIfShared的unpark唤醒</span>
            <span class="token comment">// 为什么不在创建完Node后直接设置status为WAITING呢？目的是这样能创建Node后等情况下调用tryAcquire尝试下acquire，避免过早进入WAITING状态，因为挂起线程是一个相对比较重的操作涉及到线程上下文切换等。</span>
            node<span class="token punctuation">.</span>status <span class="token operator">=</span> WAITING<span class="token punctuation">;</span>          <span class="token comment">// enable signal and recheck</span>
            <span class="token comment">// 设置完成后，还会再运行循环检查下tryAcquire</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 走到这里说明node != null, pred != null, node.status != 0, 不是first或spins=0，且已经给node.status设置了WAITING状态（或CANCELLED)</span>
            <span class="token keyword">long</span> nanos<span class="token punctuation">;</span>
            <span class="token comment">// postSpins = postSpins * 2 + 1，超过byte上限后变为负数</span>
            <span class="token comment">// spins用于解决位于first的节点但是在acquire时被频繁插队的问题，这种情况采取指数级增长的自旋等待重试</span>
            spins <span class="token operator">=</span> postSpins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>postSpins <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
                <span class="token comment">// 如果没有设定超时时间，则调用LockSupport.park让线程等待，直到通过LockSupport.unpark唤醒这个线程</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nanos <span class="token operator">=</span> time <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span>
                <span class="token comment">// 有超时时间的，如果当前还没有超时，则调用LockSupport.parkNanos等待一段时间</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token comment">// 如果有超时时间，现在已经超时了，则跳出循环，走到最后的cancelAcquire中</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment">// 修改node状态为0, 因为状态已经不是WAITING状态了</span>
            node<span class="token punctuation">.</span><span class="token function">clearStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 判断如果当前线程被interrupted中断，并且参数传入的interruptible为true，设置interrupted为true</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interrupted <span class="token operator">|=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptible<span class="token punctuation">)</span>
                <span class="token comment">// 中断后，退出循环，醉倒最后的cancelAcquire中。</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// cancelAcquire会将node状态改为CANCELLED，并且清理队列中断CANCELLED节点。</span>
    <span class="token keyword">return</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> interrupted<span class="token punctuation">,</span> interruptible<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">signalNext</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>signalNext方法负责在release时唤醒队列中的当前Node的后继节点（如果有的话），并且会取消Node的status的WAITING标记位。
如果后继节点已经cancelled，可能会导致它以及后面的非cancelled的WAITING节点不能唤醒，但是cancelAcquire方法能够保证清理cancelled节点时，触发
队首节点唤醒，Node线程唤醒后，会继续执行acquire中的循环逻辑，判断自己是否是头结点是否可以tryAcquire，如果tryAcquire成功说明同步器获取成功执行自己的代码逻辑。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">signalNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> s<span class="token punctuation">;</span>
    <span class="token comment">// 判断下一个Node节点，如果status != null，说明是WAITING状态的Node</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>status <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 清理WAITING状态标记位</span>
        s<span class="token punctuation">.</span><span class="token function">getAndUnsetStatus</span><span class="token punctuation">(</span>WAITING<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用unpark唤醒Node上的线程</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>waiter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="线程挂起、唤醒的locksupport类方法"><a href="#线程挂起、唤醒的locksupport类方法" class="header-anchor">#</a> 线程挂起、唤醒的LockSupport类方法</h2> <p>AQS中需要在需要的时候让线程等待、唤醒线程，有同学可能知道Thread类里也有几个看上去相关的方法，比如 Thread.stop、Thread.suspend、Thread.resume，
但是这些方法因为（线程monitor lock被释放可能导致状态不一致、死锁等）各种不安全问题被废弃了，更详细可以参考文章
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html" target="_blank" rel="noopener noreferrer">threadPrimitiveDeprecation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>在jdk1.5，jdk中提供了LockSupport类，来方便实现线程等待、唤醒功能。</p> <p>park()方法用户让线程挂起处于等待状态（WAITING)</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>除了无参数的park()方法，LockSupport还提供了可以设置超时时间等待的parkNanos方法</p> <p>unpark方法，unpark方法用于唤醒线程。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="条件等待、通知-conditionobject"><a href="#条件等待、通知-conditionobject" class="header-anchor">#</a> 条件等待、通知(ConditionObject)</h2> <p><img alt="img.png" data-src="/assets/images/java/aqs/aqs-condition-01.png" loading="lazy" class="lazy"></p> <p>同步器除了常见的等待，有时还需要实现更细粒度的等待功能，比如条件等待，在某个条件不满足时，线程在条件等待队列（不同于AQS的等待队列）中等待，条件满足后，
会从条件等待队列中移出加入到AQS等待队列中，然后在AQS队列中如果acquire成功，需要再判断条件是否满足（acquire之前条件状态可能已经被其他修改了），满足后执行业务逻辑，否则等待。</p> <p>目前在锁(ReentrantLock, ReentrantReadWriteLock)中使用了这个条件等待通知功能，用于在一些情况下代替java的synchronized以及搭配的wait/notify/notifyAll。</p> <p>等待和通知是条件等待的两个基本方法，等待用于在不满足条件时在条件对象(ConditionObject)中等待，通知用于在条件满足后将在条件等待队列中的Node转移到
AQS等待队列中，好让该Node有机会重新判断条件。</p> <p>需要注意的是等待和通知都需要在已经加锁的前提下使用</p> <p>常见的使用方式是</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">conditionWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 必须要要先加锁，再判断条件，如果反过来可能出现竞态条件，比如两个线程同时判断满足条件，都去加锁，修改状态，</span>
    <span class="token comment">// 慢的线程获取到锁时，条件可能已经不满足了</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// while循环判断，以便条件不满足等待，等待结束后返回还要继续判断条件，知道</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>条件不满足<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// await需要在和condition对应的锁加锁的情况下执行。</span>
                <span class="token comment">// 调用await会使得当前线程释放锁并挂起</span>
                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// await()返回前，会重新获取到锁。</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 走到这里说明条件满足，执行逻辑</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// finally中释放锁，避免异常导致锁无法释放</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">conditionSignal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 需要加锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        修改状态代码
        <span class="token comment">// 修改了状态，可能能使其他线程的等待条件满足，调用signalAll</span>
        <span class="token comment">// 调用signalAll能够避免</span>
        condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// finally中释放锁，避免异常导致锁无法释放</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="条件等待"><a href="#条件等待" class="header-anchor">#</a> 条件等待</h3> <p>条件对象(ConditionObject)是通过AQS对象的newCondition()方法创建出来的。</p> <p>加完锁(AQS实现的锁)后，如果判断条件不满足，需要调用ConditionObject.await()将当前线程加入到条件对象的条件等待队列中，
线程会变成等待状态等待被signal通知后进入到AQS队列中，进入到AQS队列中后，会重新尝试获取AQS的acquire，acquire成功后，在锁的场景下，表示再次拿到了AQS的锁
需要再判断条件，如果条件满足，执行逻辑，否则还需要while循环进入await</p> <p>下面以await()方法代码进行分析。（await还有带超时的版本，实现也类似）</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 提前判断一下是否已经被中断，如果中断，抛出中断异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建一个ConditionNode对象</span>
    <span class="token class-name">ConditionNode</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConditionNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 把ConditionNode加入到当前的ConditionObject的条件等待队列中，会设置Node的status为COND|WAITING</span>
    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">enableWait</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">setCurrentBlocker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// for back-compatibility</span>
    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> cancelled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> rejected <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环等待，canReacquire表示node在AQS的等待队列中，在没有其他线程通过signal/signalAll把当前Node转移到AQS的等待队列之前，canReacquire都返回false</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canReacquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不再AQS队列中不能进行AQS的acquire，需要在条件队列中WAITING等待</span>
        <span class="token comment">// 判断一下线程是否被中断，如果中断，取消Node的COND状态标记位，退出循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted <span class="token operator">|=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cancelled <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">getAndUnsetStatus</span><span class="token punctuation">(</span>COND<span class="token punctuation">)</span> <span class="token operator">&amp;</span> COND<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment">// else interrupted after signal</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>status <span class="token operator">&amp;</span> COND<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 在Node的status中包含COND的情况下</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果被rejected(默认false)，调用node.block</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rejected<span class="token punctuation">)</span>
                    node<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    <span class="token comment">// 否则使用ForkJoinPool.managedBlock使Node挂起(最终还是调用的LockSupport.park())；如果当前线程是ForkJoinWorkerThread则会有拒绝逻辑，也就是rejected</span>
                    <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">managedBlock</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RejectedExecutionException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果被ForkJoinPool reject，设置rejected为true，下次执行会直接调用node.block，最终也会调用到LockSupport.park()</span>
                rejected <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 捕获中断异常，在外层处理中断，需要从等待队列中删除Node</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">onSpinWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// awoke while enqueuing</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Node线程从上面的park等待中恢复的时机有</span>
    <span class="token comment">// 1. 被signal/signalAll之后加入到AQS等待队列，并被AQS release时signalNext唤醒</span>
    <span class="token comment">// 2. 线程被中断</span>
    <span class="token comment">// 3. 如果试用的是带有超时时间的await方法，超过超时时间后也会恢复</span>
    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">setCurrentBlocker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span><span class="token function">clearStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行到这里，说明Node已经在AQS队列中并且是first节点了，还需要acquire才能进入到同步器中，</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cancelled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><p>为什么要用ForkJoinPool.managedBlock(node)</p> <h3 id="条件通知-signal-signalall"><a href="#条件通知-signal-signalall" class="header-anchor">#</a> 条件通知(signal/signalAll)</h3> <p>signal/signalAll实现</p> <p>signal方法负责给ConditionObject的第一个Node(也是等待时间最长的）从条件等待队列中移出加入到AQS的等待队列中。
signalAll方法则把当前ConditionObject对象的条件等待队列上的所有Node都从条件等待队列中移出并加入到AQS的等待队列中。
signal和signalAll代码基本一致，除了调用doSignal中的all参数不同。</p> <p>signal()方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ConditionNode</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>doSignal方法，如果all是false（signal)，则找到队列第一个waiter，出队，然后去掉Node的status的COND状态标记，调用enqueue(first)把这个Node
加入到AQS的等待队列中。对于all是true的情况，则会遍历队列，把所有的Node都出队然后加入到AQS的等待队列中。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">ConditionNode</span> first<span class="token punctuation">,</span> <span class="token keyword">boolean</span> all<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ConditionNode</span> next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">getAndUnsetStatus</span><span class="token punctuation">(</span>COND<span class="token punctuation">)</span> <span class="token operator">&amp;</span> COND<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>all<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        first <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>目前只给signal使用的enqueue方法，和acquire的入队过程类似，先设置prev，判断队列是否为空(tail == null)，如果是初始化队列。队列不为空则cas tail入队。</p> <p>入队完成后，还判断了下Node的status，如果小于0，说明这个Node被Cancelled取消了。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span><span class="token function">setPrevRelaxed</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// avoid unnecessary fence</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                 <span class="token comment">// initialize</span>
                <span class="token function">tryInitializeHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment">// wake up to clean link</span>
                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>waiter<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="aqs和conditionobject的关系-以及两者的队列的关系。"><a href="#aqs和conditionobject的关系-以及两者的队列的关系。" class="header-anchor">#</a> AQS和ConditionObject的关系，以及两者的队列的关系。</h3> <p>创建完AQS对象后，通过对象的实例方法可以创建ConditionObject，对于ConditionObject的await和signal方法都需要保证执行方法在AQS exclusive独占持有的情况下执行，参考ReentrantLock中的使用例子。
在await时，当前线程会创建一个ConditionNode入队到ConditionObject的条件等待队列中然后释放锁,唤醒后需要重新获取AQS锁才能从await方法中返回；在signal/signalAll方法调用时，会将条件队列中的Node（signal第一个/signalAll全部）从条件等待队列中出队并入队到AQS等待队列中并唤醒该Node线程。</p> <h2 id="abstractownablesynchronizer"><a href="#abstractownablesynchronizer" class="header-anchor">#</a> AbstractOwnableSynchronizer</h2> <p>AQS类继承与AbstractOwnableSynchronizer抽象类，AbstractOwnableSynchronizer中定义了setExclusiveOwnerThread，getExclusiveOwnerThread方法
用于设置、获取当前同步器的独占持有线程。</p> <p>判断独占持有线程在锁(ReentrantLock, ReentrantReadWriteLock)中使用，因为这些锁要实现可重入功能，要判断加锁的线程是否是当前线程。</p> <p>要注意的是AbstractOwnableSynchronizer中定义的exclusiveOwnerThread字段没有使用volatile声明，get set方法也没有synchronized加锁,所以
get set方法是不保证其他线程的可见性的。这是因为这两个方法主要用于判断这个线程和当前线程是否是同一个，如果是同一个线程，自然不会有可见性问题，如果不是同一个线程，即使有可见性问题，对于判断是否同一个线程也不会导致出错（肯定不相同）。</p> <h2 id="juc-java-util-concurrent包-中的aqs应用"><a href="#juc-java-util-concurrent包-中的aqs应用" class="header-anchor">#</a> juc(java util concurrent包)中的AQS应用</h2> <p>在ReentrantLock, ReentrantReadWriteLock, Semaphore, CountDownLatch, ThreadPoolExecutor.Worker等并发类中都使用了AQS来实现同步器的功能，在对应的类的实现分析中会详细介绍。</p> <h2 id="疑问"><a href="#疑问" class="header-anchor">#</a> 疑问</h2> <h3 id="如果在signalnext之后加入队列-node会唤醒吗"><a href="#如果在signalnext之后加入队列-node会唤醒吗" class="header-anchor">#</a> 如果在signalNext之后加入队列，Node会唤醒吗？</h3> <p>要分析一下release和acquire之间可能出现的竞态条件。</p> <p>对于signalNext之后才创建队列的情况，创建队列完成还会执行一下tryAcquire。
如果signalNext方法执行tryRelease返回true说明其他线程可能acquire成功，则调用signalNext，
signalNext如果发现现在队列是空的(head == null或head.next == null 或next.status == 0)，则不会唤醒这个Node。</p> <p>这种情况说明Node还没完成最后的设置status增加WAITING标记位的操作，因为设置完成后，根据happen before，release方法是能读取到的。如果能读取到
release方法就会调用LockSupport.unpark(s.waiter)，而LockSupport.unpark的一个特性就是，即使unpark比park在前，之后的第一个park也会立刻唤醒，所以这种情况也不会有liveness（Node无法唤醒）问题</p> <p>如果release判断if条件时，status还没有设置WAITING标记位，因为执行到if判断了（也就是signalNext方法）这时tryRelease一定已经执行了，释放了release，其他线程可以tryAcquire成功（tryRelease返回true的情况）。
那么在acquire方法中设置完WAITING标记位，下一个循环还会尝试一次tryAcquire，这时tryAcquire应该返回true（除非有其他线程插队barging）线程也入队进行LockSupport.park；如果tryAcquire失败入队进行LockSupport.park挂起，
说明有其他线程acquire成功，那么这个线程在release时还会通过release唤醒first结点。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">signalNext</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="acquire中spins的作用"><a href="#acquire中spins的作用" class="header-anchor">#</a> acquire中spins的作用</h3> <p>AQS中等待队列的第一个节点(prev==head)被signalNext唤醒后还需要尝试tryAcquire，如果这时有其他线程（没有入队，不在AQS队列中）调用acquire，
则可能出现插队（这时默认的unfair的策略，能够提升整体的吞吐率，比如锁、Semaphore等），但是如果第一个节点唤醒后被插队再次进入WAITING状态挂起，如果acquire的并发量比较大，下次
唤醒后大概率还可能竞争不过插队的线程，为了避免过于不公平导致AQS队列中的Node太饥饿，AQS中增加了spins自旋等待的策略，进入AQS队列前，AQS会将
spins（默认0）改为2*spins + 1，然后唤醒后，即使tryAcquire失败，这个Node不会继续park，而是进行spins次的Thread.onSpinWait()以及tryAcquire，
如果spins次tryAcquire后，Node还是需要继续park挂起，挂起之前会继续把spins改为(byte)(2 * spins + 1)，下次唤醒后继续重试spins的Thread.onSpinWait()+tryAcquire，
spins最大值为127，127之后会变成-1，spins为-1时，这个Node不再park(<code>else if (first &amp;&amp; spins != 0) --spins</code>)，而是一直自旋等待。</p> <h3 id="超时、中断如何实现的"><a href="#超时、中断如何实现的" class="header-anchor">#</a> 超时、中断如何实现的</h3> <p>超时机制: acquire方法可以传入超时时间，让超过指定时间后，放弃acquire。这是通过LockSupport.parkNanos方法实现的指定时间的等待，超过这个时间后
线程会自动唤醒，并且下次循环时会判断时间是否超过了最开始acquire时计算的deadline，超过后break退出循环，走到cancelAcquire方法中，取消Node。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nanos <span class="token operator">=</span> time <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span><span class="token function">clearStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interrupted <span class="token operator">|=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptible<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> interrupted<span class="token punctuation">,</span> interruptible<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>中断情况，在一些场景下，我们可能希望线程等待acquire能够被中断避免无限等待，比如ReentrantLock.lockInterruptibly等可中断的方法都是中的
AQS的可中断功能，在AQS的acquire方法中有一个boolean类型的interruptible参数，表示acquire是否可以中断。
其他线程可以被其他线程通过Thread.interrupt实例方法设置中断标识，在AQS等待队列中等待(LockSupport.park)的Node或中断后调用LockSupport.park的线程
都会立刻从park中唤醒返回，并且线程的interrupted状态会设置成true。
这里判断如果能响应中断(interruptible为true)并且Thread.interrupted为true，就break退出循环，退出循环后和超时一样要调用cancelAcquire从队列中删除节点。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interrupted <span class="token operator">|=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptible<span class="token punctuation">)</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里要注意的是调动Thread.interrupted()静态方法后，当前线程的中断标记会被清除，所以cancelAcquire中判断了如果是因为中断导致取消但是不是可中断的，
会重新调用<code>Thread.currentThread().interrupt()</code>恢复中断状态，让上层调用代码能够响应中断标识。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">boolean</span> interrupted<span class="token punctuation">,</span>
                              <span class="token keyword">boolean</span> interruptible<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果node不为null，要从队列中删除这个node</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置waiter引用为null，帮助GC</span>
        node<span class="token punctuation">.</span>waiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置状态为CANCELLED</span>
        node<span class="token punctuation">.</span>status <span class="token operator">=</span> CANCELLED<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>prev <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token comment">// prev不为null，说明可能在队列中，调用cleanQueue删除CANCELLED节点</span>
            <span class="token function">cleanQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptible<span class="token punctuation">)</span>
            <span class="token keyword">return</span> CANCELLED<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>注意cleanQueue也是在并发场景下执行的，要考虑线程安全问题。
cleanQueue的代码位于两层循环，定义了p,q,s三个变量，q是指当前遍历的节点，p是q的prev节点，s是q的next节点。
外层循环的推出条件是p == null || (p = q.prev) == null，这个条件说明队列为空或者q已经是head节点，已经遍历完成，cleanQueue完成。
内层循环的遍历中，通过break推出一次清理动作，break完成后再从尾向前遍历循环。</p> <p>内层退出条件有:</p> <ol><li>遍历tail时，tail指针被其他线程修改了(tail != q)</li> <li>遍历其他节点时next节点的prev或status被修改(s.prev != q || s.status &lt; 0)，说明有其他线程也在清理或将next节点设置为CANCELLED</li> <li>q.status &lt; 0，找到一个取消的节点，通过cas将这个节点从队列中删除</li> <li>(n = p.next) != q，</li> <li>q == null || (p = q.prev) == null，队列遍历完成，会退出整个方法</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cleanQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                               <span class="token comment">// restart point</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> q <span class="token operator">=</span> tail<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (p, q, s) triples</span>
            <span class="token comment">// 队列遍历完成</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> q<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>                      <span class="token comment">// end of list</span>
            <span class="token comment">// 出现了前后引用出现了不一致状态，是由于其他线程也进行了清理或者有新Node入队，退出当前循环重新遍历</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> tail <span class="token operator">!=</span> q <span class="token operator">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>prev <span class="token operator">!=</span> q <span class="token operator">||</span> s<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                       <span class="token comment">// inconsistent</span>
            <span class="token comment">// 找到一个CANCELLED节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// cancelled</span>
                <span class="token comment">// 如果是tail，cas修改tail为prev，否则修改next的prev引用为当前节点q的prev p节点</span>
                <span class="token comment">// cas成功后，再判断下q.prev == p，是</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">casTail</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">casPrev</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    q<span class="token punctuation">.</span>prev <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// cas更新p的next引用，cas失败也没有关系，因为至少有一个线程能把p的next修改正确。</span>
                    p<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// OK if fails</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        <span class="token comment">// p.prev == null说明p是head节点，说明first节点因为cancel被删除了，需要通过signalNext唤醒新的first节点，避免第一个节点cancel之后链表后面的节点接收不到signal唤醒</span>
                        <span class="token function">signalNext</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// p.next != q，说明执行到这里时，有其他线程正在执行上面的代码清理q节点，已经修改了q的next引用，当前线程会尝试帮助清理，然后break</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// help finish</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>prev <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// cas更新next引用</span>
                    p<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        <span class="token comment">// 同样对于first节点cancel的情况需要重新signalNext唤醒新的first节点。</span>
                        <span class="token function">signalNext</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            s <span class="token operator">=</span> q<span class="token punctuation">;</span>
            q <span class="token operator">=</span> q<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="如何保证节点一定能唤醒-不会无限等待"><a href="#如何保证节点一定能唤醒-不会无限等待" class="header-anchor">#</a> 如何保证节点一定能唤醒（不会无限等待）</h3> <p>不考虑CANCELLED节点的情况下，已经acquire成功的线程，会在release时调用signalNext唤醒first节点（tryRelease返回true的情况下）。
如果节点已经在first位置等待，会被唤醒。如果不在first位置等待，说明还没有入队或者在队列其他位置。
如果在signalNext的这一瞬间，队列为空，则在设置status的WAITINGT状态后、park前，节点是会重新调用tryAcquire尝试的，如果可以acquire不需要park等待。
如果在signalNext的这一瞬间，队列不为空，节点在first位置，自然会被唤醒。
如果在signalNext的这一瞬间，队列不为空，节点不在first位置，则节点需要等待它的前继节点唤醒它。</p> <p>再考虑下有CANCELLED节点的情况，取消的节点，会调用cleanQueue方法清理队列。清理过程中，如果CANCELLED节点之前是first节点，则会变成head，并且通过signalNext唤醒新的first节点。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/liuzhengyang/liuzhengyang.github.io/edit/master/docs/md/java/basic/AbstractQueuedSynchronizer.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/md/java/basic/ArrayBlockingQueue阻塞队列.html" class="prev">
          ArrayBlockingQueue
        </a></span> <span class="next"><a href="/md/java/basic/ReentrantLock.html">
          ReentrantLock
        </a>
        →
      </span></p></div> </main></div> <aside class="page-sidebar"> <div class="page-side-toolbar"><div class="option-box-toc-fixed"><div class="toc-container-sidebar"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="max-height:650px"><div style="font-weight:bold;text-align:center;">AQS详解</div> <hr> <div class="toc-box"><ul class="toc-sidebar-links"><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs使用" class="toc-sidebar-link">AQS使用</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs整体实现设计" class="toc-sidebar-link">AQS整体实现设计</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#队列" class="toc-sidebar-link">队列</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#队列原子操作" class="toc-sidebar-link">队列原子操作</a></li></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#结构" class="toc-sidebar-link">结构</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs实现" class="toc-sidebar-link">AQS实现</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#acquire" class="toc-sidebar-link">acquire</a></li></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#线程挂起、唤醒的locksupport类方法" class="toc-sidebar-link">线程挂起、唤醒的LockSupport类方法</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#条件等待、通知-conditionobject" class="toc-sidebar-link">条件等待、通知(ConditionObject)</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#条件等待" class="toc-sidebar-link">条件等待</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#条件通知-signal-signalall" class="toc-sidebar-link">条件通知(signal/signalAll)</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs和conditionobject的关系-以及两者的队列的关系。" class="toc-sidebar-link">AQS和ConditionObject的关系，以及两者的队列的关系。</a></li></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#abstractownablesynchronizer" class="toc-sidebar-link">AbstractOwnableSynchronizer</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#juc-java-util-concurrent包-中的aqs应用" class="toc-sidebar-link">juc(java util concurrent包)中的AQS应用</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#疑问" class="toc-sidebar-link">疑问</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#如果在signalnext之后加入队列-node会唤醒吗" class="toc-sidebar-link">如果在signalNext之后加入队列，Node会唤醒吗？</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#acquire中spins的作用" class="toc-sidebar-link">acquire中spins的作用</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#超时、中断如何实现的" class="toc-sidebar-link">超时、中断如何实现的</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#如何保证节点一定能唤醒-不会无限等待" class="toc-sidebar-link">如何保证节点一定能唤醒（不会无限等待）</a></li></ul></li></ul></div></div></div></div></div> <div class="option-box-toc-over"><img src="/images/system/toc.png" class="nozoom"> <span class="show-txt">目录</span> <div class="toc-container"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="max-height:550px"><div style="font-weight:bold;text-align:center;">AQS详解</div> <hr> <div class="toc-box"><ul class="toc-sidebar-links"><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs使用" class="toc-sidebar-link">AQS使用</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs整体实现设计" class="toc-sidebar-link">AQS整体实现设计</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#队列" class="toc-sidebar-link">队列</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#队列原子操作" class="toc-sidebar-link">队列原子操作</a></li></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#结构" class="toc-sidebar-link">结构</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs实现" class="toc-sidebar-link">AQS实现</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#acquire" class="toc-sidebar-link">acquire</a></li></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#线程挂起、唤醒的locksupport类方法" class="toc-sidebar-link">线程挂起、唤醒的LockSupport类方法</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#条件等待、通知-conditionobject" class="toc-sidebar-link">条件等待、通知(ConditionObject)</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#条件等待" class="toc-sidebar-link">条件等待</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#条件通知-signal-signalall" class="toc-sidebar-link">条件通知(signal/signalAll)</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#aqs和conditionobject的关系-以及两者的队列的关系。" class="toc-sidebar-link">AQS和ConditionObject的关系，以及两者的队列的关系。</a></li></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#abstractownablesynchronizer" class="toc-sidebar-link">AbstractOwnableSynchronizer</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#juc-java-util-concurrent包-中的aqs应用" class="toc-sidebar-link">juc(java util concurrent包)中的AQS应用</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/md/java/basic/AbstractQueuedSynchronizer.html#疑问" class="toc-sidebar-link">疑问</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#如果在signalnext之后加入队列-node会唤醒吗" class="toc-sidebar-link">如果在signalNext之后加入队列，Node会唤醒吗？</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#acquire中spins的作用" class="toc-sidebar-link">acquire中spins的作用</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#超时、中断如何实现的" class="toc-sidebar-link">超时、中断如何实现的</a></li><li class="toc-sidebar-sub-header"><a href="/md/java/basic/AbstractQueuedSynchronizer.html#如何保证节点一定能唤醒-不会无限等待" class="toc-sidebar-link">如何保证节点一定能唤醒（不会无限等待）</a></li></ul></li></ul></div></div></div></div></div> <div class="option-box"><img src="/images/system/wechat.png" class="nozoom"> <span class="show-txt">手机看</span> <div class="toc-container"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="text-align:center"><span style="font-size:0.9rem">微信扫一扫</span> <img height="180px" src="https://api.qrserver.com/v1/create-qr-code/?data=https://bytejava.cn/md/java/basic/AbstractQueuedSynchronizer.html" style="margin:10px;">
                可以<b>手机看</b>或分享至<b>朋友圈</b></div></div></div></div> <div class="option-box"><img src="/images/personal/wechat-mp-logo.jpg" height="20" class="nozoom"> <span class="show-txt">公众号</span> <div class="toc-container"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="text-align:center"><span style="font-size:0.9rem">关注公众号bytejava</span> <img src="/images/personal/wechat-mp.png" height="180" width></div></div></div></div> <div class="option-box"><img src="/images/system/toggle.png" width="30px" class="nozoom"> <span class="show-txt">左栏</span></div> <div class="option-box"><img src="/images/system/heart-1.png" width="25px" class="nozoom"> <span class="show-txt">赞赏我</span> <div class="toc-container"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="text-align:center"><span style="font-size:0.8rem;font-weight:bold;">鼓励/支持/赞赏我</span> <img height="180px" src="/images/personal/encourage-head.jpg" style="margin:5px;"> <br>1. 不靠它生存但仍希望得到你的鼓励；
                <br>2. 时刻警醒自己保持技术人的初心，沉淀，分享，成长；
              </div></div></div></div> <div title="ArrayBlockingQueue" class="option-box" style="padding-left:2px;text-align:center;"><a href="/md/java/basic/ArrayBlockingQueue阻塞队列.html"><img src="/images/system/pre2.png" width="30px" class="nozoom"> <span class="show-txt">上一篇</span></a></div> <div title="ReentrantLock" class="option-box" style="padding-left:2px;text-align:center;"><a href="/md/java/basic/ReentrantLock.html"><img src="/images/system/next2.png" width="30px" class="nozoom"> <span class="show-txt">下一篇</span></a></div></div>  <!----> </aside></div><div class="global-ui"></div></div>
    <script src="/assets/js/cg-styles.js?v=1729221831211" defer></script><script src="/assets/js/cg-4.js?v=1729221831211" defer></script><script src="/assets/js/cg-3.js?v=1729221831211" defer></script><script src="/assets/js/cg-111.js?v=1729221831211" defer></script><script src="/assets/js/cg-app.js?v=1729221831211" defer></script>
  </body>
</html>
